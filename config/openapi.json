{
  "openapi": "3.1.0",
  "info": {
    "title": "Opentrons HTTP API Spec",
    "description": "This OpenAPI spec describes the HTTP API for Opentrons robots. It may be retrieved from a robot on port 31950 at /openapi. Some schemas used in requests and responses use the `x-patternProperties` key to mean the JSON Schema `patternProperties` behavior.",
    "version": "4"
  },
  "paths": {
    "/networking/status": {
      "get": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Query the current network connectivity state",
        "description": "Gets information about the robot's network interfaces including their connectivity, their addresses, and their networking info",
        "operationId": "get_networking_status_networking_status_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NetworkingStatus"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/list": {
      "get": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Scan for visible Wi-Fi networks",
        "description": "Returns the list of the visible wifi networks along with some data about their security and strength.",
        "operationId": "get_wifi_networks_wifi_list_get",
        "parameters": [
          {
            "name": "rescan",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If `true`, forces a rescan for beaconing Wi-Fi networks. This is an expensive operation that can take ~10 seconds, so only do it based on user needs like clicking a \"scan network\" button, not just to poll. If `false`, returns the cached Wi-Fi networks, letting the system decide when to do a rescan.",
              "default": false,
              "title": "Rescan"
            },
            "description": "If `true`, forces a rescan for beaconing Wi-Fi networks. This is an expensive operation that can take ~10 seconds, so only do it based on user needs like clicking a \"scan network\" button, not just to poll. If `false`, returns the cached Wi-Fi networks, letting the system decide when to do a rescan."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WifiNetworks"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/configure": {
      "post": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Configure the robot's Wi-Fi",
        "description": "Configures the wireless network interface to connect to a network",
        "operationId": "post_wifi_configure_wifi_configure_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WifiConfiguration"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WifiConfigurationResponse"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Bad Request"
          },
          "401": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unauthorized"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/keys": {
      "get": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Get Wi-Fi keys",
        "description": "Get a list of key files known to the system",
        "operationId": "get_wifi_keys_wifi_keys_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WifiKeyFiles"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "post": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Add a Wi-Fi key",
        "description": "Send a new key file to the robot",
        "operationId": "post_wifi_key_wifi_keys_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_post_wifi_key_wifi_keys_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWifiKeyFileResponse"
                }
              }
            },
            "description": "OK"
          },
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddWifiKeyFileResponse"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/keys/{key_uuid}": {
      "delete": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Delete a Wi-Fi key",
        "description": "Delete a key file from the robot",
        "operationId": "delete_wifi_key_wifi_keys__key_uuid__delete",
        "parameters": [
          {
            "name": "key_uuid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of key to delete, as determined by a previous call to GET /wifi/keys",
              "title": "Key Uuid"
            },
            "description": "The ID of key to delete, as determined by a previous call to GET /wifi/keys"
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/eap-options": {
      "get": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Get EAP options",
        "description": "Get the supported EAP variants and their configuration parameters",
        "operationId": "get_eap_options_wifi_eap_options_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EapOptions"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/wifi/disconnect": {
      "post": {
        "tags": [
          "v1",
          "Networking"
        ],
        "summary": "Disconnect the robot from Wi-Fi",
        "description": "Deactivates the Wi-Fi connection and removes it from known connections",
        "operationId": "post_wifi_disconnect_wifi_disconnect_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WifiNetwork"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            },
            "description": "OK"
          },
          "207": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/identify": {
      "post": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Blink the lights",
        "description": "Blink the gantry lights so you can pick it out of a crowd",
        "operationId": "post_identify_identify_post",
        "parameters": [
          {
            "name": "seconds",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "Time to blink the lights for",
              "title": "Seconds"
            },
            "description": "Time to blink the lights for"
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/robot/positions": {
      "get": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Get robot positions",
        "description": "Get a list of useful positions.\n\n**Deprecated:** This data only makes sense for OT-2 robots, not Flex robots. There is currently no public way to get these positions for Flex robots.",
        "operationId": "get_robot_positions_robot_positions_get",
        "deprecated": true,
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RobotPositionsResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/robot/move": {
      "post": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Move the robot",
        "description": "Move the robot's gantry to a position (usually to a position retrieved from `GET /robot/positions`).\n\n**Deprecated:** Run a `moveToCoordinates` command in a maintenance run instead. See the `/maintenance_runs` endpoints.",
        "operationId": "post_move_robot_robot_move_post",
        "deprecated": true,
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RobotMoveTarget"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/robot/home": {
      "post": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Home the robot",
        "description": "Home the robot.",
        "operationId": "post_home_robot_robot_home_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RobotHomeTarget"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/robot/lights": {
      "get": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Get whether the lights are on",
        "description": "Get the current status of the robot's rail lights",
        "operationId": "get_robot_light_state_robot_lights_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RobotLightState"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "post": {
        "tags": [
          "v1",
          "Control"
        ],
        "summary": "Turn the lights on or off",
        "description": "Turn the rail lights on or off",
        "operationId": "post_robot_light_state_robot_lights_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RobotLightState"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RobotLightState"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings": {
      "post": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Change a setting",
        "description": "Change an advanced setting (feature flag)",
        "operationId": "post_settings_settings_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdvancedSettingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdvancedSettingsResponse"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Bad Request"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      },
      "get": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Get settings",
        "description": "Get a list of available advanced settings (feature flags) and their values",
        "operationId": "get_settings_settings_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdvancedSettingsResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/log_level/local": {
      "post": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Set the local log level",
        "description": "Set the minimum level of logs saved locally",
        "operationId": "post_log_level_local_settings_log_level_local_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogLevel"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/log_level/upstream": {
      "post": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Set the upstream log level",
        "description": "Set the minimum level of logs sent upstream via syslog-ng to Opentrons. Removed in robot software v7.2.0.",
        "operationId": "post_log_level_upstream_settings_log_level_upstream_post",
        "deprecated": true,
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogLevel"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/reset/options": {
      "get": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Get the things that can be reset",
        "description": "Get the robot settings and data that can be reset through `POST /settings/reset`.",
        "operationId": "get_settings_reset_options_settings_reset_options_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FactoryResetOptions"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/reset": {
      "post": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Reset specific settings or data",
        "description": "Perform a reset of the requested robot settings or data.\n\nThe valid properties are given by `GET /settings/reset/options`.\n\nYou should always restart the robot after using this endpoint to reset something.",
        "operationId": "post_settings_reset_options_settings_reset_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "boolean"
                },
                "title": "Factory Reset Commands"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "503": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Service Unavailable"
          }
        }
      }
    },
    "/settings/robot": {
      "get": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Get Robot Settings",
        "description": "Get the current robot config",
        "operationId": "get_robot_settings_settings_robot_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "title": "Response Get Robot Settings Settings Robot Get"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/pipettes": {
      "get": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Get Pipette Settings",
        "description": "List all settings for all known pipettes by id. Only available on OT-2.",
        "operationId": "get_pipette_settings_settings_pipettes_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/PipetteSettings"
                  },
                  "title": "Response Get Pipette Settings Settings Pipettes Get"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/settings/pipettes/{pipette_id}": {
      "get": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Get Pipette Setting",
        "description": "Get the settings of a specific pipette by ID. Only available on OT-2.",
        "operationId": "get_pipette_setting_settings_pipettes__pipette_id__get",
        "parameters": [
          {
            "name": "pipette_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Pipette Id"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipetteSettings"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "patch": {
        "tags": [
          "v1",
          "Settings"
        ],
        "summary": "Patch Pipette Setting",
        "description": "Change the settings of a specific pipette. Only available on OT-2.",
        "operationId": "patch_pipette_setting_settings_pipettes__pipette_id__patch",
        "parameters": [
          {
            "name": "pipette_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Pipette Id"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PipetteSettingsUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipetteSettings"
                }
              }
            }
          },
          "412": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Precondition Failed"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/calibration/status": {
      "get": {
        "tags": [
          "v1",
          "Deck Calibration"
        ],
        "summary": "Get Calibration Status",
        "description": "Get the calibration status",
        "operationId": "get_calibration_status_calibration_status_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__service__legacy__models__deck_calibration__CalibrationStatus"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/modules/{serial}": {
      "post": {
        "tags": [
          "v1",
          "Modules"
        ],
        "summary": "Execute a command on a specific module",
        "description": "Command a module to take an action. Valid actions depend on the specific module attached, which is the model value from `GET /modules/{serial}/data` or `GET /modules`.\n\n**Deprecated:** Removed with `Opentrons-Version: 3`. Use `POST /commands` instead.",
        "operationId": "post_serial_command_modules__serial__post",
        "deprecated": true,
        "parameters": [
          {
            "name": "serial",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Serial number of the module",
              "title": "Serial"
            },
            "description": "Serial number of the module"
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SerialCommand"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SerialCommandResponse"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Bad Request"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/modules/{serial}/update": {
      "post": {
        "tags": [
          "v1",
          "Modules"
        ],
        "summary": "Initiate a firmware update on a specific module",
        "description": "Command robot to flash its bundled firmware file for this module's type to this specific module",
        "operationId": "post_serial_update_modules__serial__update_post",
        "parameters": [
          {
            "name": "serial",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Serial number of the module",
              "title": "Serial"
            },
            "description": "Serial number of the module"
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/pipettes": {
      "get": {
        "tags": [
          "v1",
          "Pipettes"
        ],
        "summary": "Get the pipettes currently attached",
        "description": "This endpoint lists properties of the pipettes currently attached to the robot like name, model, and mount.\n\nIf you're controlling a Flex, and not an OT-2, you might prefer the `GET /instruments` endpoint instead.",
        "operationId": "get_pipettes_pipettes_get",
        "parameters": [
          {
            "name": "refresh",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If `false`, query a cached value. If `true`, actively scan for attached pipettes.\n\n**Warning:** Actively scanning disables the pipette motors and should only be done when no protocol is running and you know it won't cause a problem.\n\n**Warning:** Actively scanning is only valid on OT-2s. On Flex robots, it's unnecessary, and the behavior is currently undefined.",
              "default": false,
              "title": "Refresh"
            },
            "description": "If `false`, query a cached value. If `true`, actively scan for attached pipettes.\n\n**Warning:** Actively scanning disables the pipette motors and should only be done when no protocol is running and you know it won't cause a problem.\n\n**Warning:** Actively scanning is only valid on OT-2s. On Flex robots, it's unnecessary, and the behavior is currently undefined."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipettesByMount"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/motors/engaged": {
      "get": {
        "tags": [
          "v1",
          "Motors"
        ],
        "summary": "Get Engaged Motors",
        "description": "Query which motors are engaged and holding",
        "operationId": "get_engaged_motors_motors_engaged_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EngagedMotors"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/motors/disengage": {
      "post": {
        "tags": [
          "v1",
          "Motors"
        ],
        "summary": "Post Disengage Motors",
        "description": "Disengage a motor or set of motors",
        "operationId": "post_disengage_motors_motors_disengage_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Axes"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/camera/picture": {
      "post": {
        "tags": [
          "v1",
          "Camera"
        ],
        "summary": "Post Picture Capture",
        "description": "Capture an image from the OT-2's on-board camera and return it",
        "operationId": "post_picture_capture_camera_picture_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "The image",
            "content": {
              "application/json": {
                "schema": {}
              },
              "image/jpg": {}
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/logs/{log_identifier}": {
      "get": {
        "tags": [
          "v1",
          "Logs"
        ],
        "summary": "Get troubleshooting logs",
        "description": "Get the robot's troubleshooting logs.\n\nIf you want the list of steps executed in a protocol, like \"aspirated 5 L from well A1...\", you probably want the *protocol analysis commands* (`GET /protocols/{id}/analyses/{id}`) or *run commands* (`GET /runs/{id}/commands`) instead.",
        "operationId": "get_logs_logs__log_identifier__get",
        "parameters": [
          {
            "name": "log_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/LogIdentifier"
            }
          },
          {
            "name": "format",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/LogFormat",
              "title": "Log format type",
              "default": "text"
            }
          },
          {
            "name": "records",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100000,
              "exclusiveMinimum": 0,
              "title": "Number of records to retrieve",
              "default": 50000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Health",
          "v1"
        ],
        "summary": "Get server health",
        "description": "Get information about the health of the robot server.\n\nUse the health endpoint to check that the robot server is running\nand ready to operate. A 200 OK response means the server is running.\nThe response includes information about the software and system.",
        "operationId": "get_health_health_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Health"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LegacyErrorResponse"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "503": {
            "description": "Robot motor controller is not ready",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V1BasicResponse"
                }
              }
            }
          }
        }
      }
    },
    "/clientData/{key}": {
      "put": {
        "tags": [
          "Client Data"
        ],
        "summary": "Store client-defined data",
        "description": "Store a small amount of arbitrary client-defined data.\n\nThis endpoint is experimental and may be changed or removed without warning.\n\nThis is intended to help coordinate between multiple clients accessing the same\nrobot, and to help clients pick up from where they left off if they're closed\nand reopened. For example, suppose your client shows a user interface for\nphysically setting up the deck with labware, step by step. You could use this\nto store which step the user is currently on.\n\nThe data is cleared when the robot reboots.",
        "operationId": "put_client_data_clientData__key__put",
        "parameters": [
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-_]*$",
              "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics.",
              "examples": [
                "exampleOrganization-userNotes-v2"
              ],
              "title": "Key"
            },
            "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_dict_str__object__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_dict_str__object__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Client Data"
        ],
        "summary": "Get client-defined data",
        "description": "Return the currently-stored client data at the given key. See `PUT /clientData` for background.",
        "operationId": "get_client_data_clientData__key__get",
        "parameters": [
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-_]*$",
              "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics.",
              "examples": [
                "exampleOrganization-userNotes-v2"
              ],
              "title": "Key"
            },
            "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_dict_str__object__"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ClientDataKeyDoesNotExist_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Client Data"
        ],
        "summary": "Delete client-defined data",
        "description": "Delete the client-defined data at the given key. See `PUT /clientData` for background.",
        "operationId": "delete_client_data_clientData__key__delete",
        "parameters": [
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-_]*$",
              "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics.",
              "examples": [
                "exampleOrganization-userNotes-v2"
              ],
              "title": "Key"
            },
            "description": "A key for storing and retrieving the piece of data. This should be chosen to avoid colliding with other clients, and to unambiguously identify the data stored inside. The allowed characters are restricted to avoid any that are special in URLs or MQTT topics."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_dict_str__object__"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ClientDataKeyDoesNotExist_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/clientData": {
      "delete": {
        "tags": [
          "Client Data"
        ],
        "summary": "Delete all client-defined data",
        "description": "Delete all client-defined data. See `PUT /clientData` for background.",
        "operationId": "delete_all_client_data_clientData_delete",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/labwareOffsets": {
      "post": {
        "tags": [
          "Labware Offset Management"
        ],
        "summary": "Store labware offsets",
        "description": "Store labware offsets for later retrieval through `GET /labwareOffsets`.\n\nOn its own, this does not affect robot motion.\nTo do that, you must add the offsets to a run, through the `/runs` endpoints.\n\nThe response body's `data` will either be a single offset or a list of offsets,\ndepending on whether you provided a single offset or a list in the request body's `data`.",
        "operationId": "post_labware_offsets_labwareOffsets_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Union_StoredLabwareOffsetCreate__list_StoredLabwareOffsetCreate___"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Union_StoredLabwareOffset__list_StoredLabwareOffset___"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Labware Offset Management"
        ],
        "summary": "Get all labware offsets",
        "description": "Get all the labware offsets currently stored on the robot. Results are returned in order from oldest to newest.",
        "operationId": "get_labware_offsets_labwareOffsets_get",
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The first index to return out of the overall filtered result list. If unspecified, defaults to returning `pageLength` elements from the end of the list.",
              "title": "Cursor"
            },
            "description": "The first index to return out of the overall filtered result list. If unspecified, defaults to returning `pageLength` elements from the end of the list."
          },
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "enum": [
                    "unlimited"
                  ],
                  "const": "unlimited",
                  "type": "string"
                }
              ],
              "description": "The maximum number of entries to return.",
              "default": "unlimited",
              "title": "Pagelength"
            },
            "description": "The maximum number of entries to return."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_StoredLabwareOffset_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Labware Offset Management"
        ],
        "summary": "Delete all labware offsets",
        "operationId": "delete_all_labware_offsets_labwareOffsets_delete",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/labwareOffsets/searches": {
      "post": {
        "tags": [
          "Labware Offset Management"
        ],
        "summary": "Search for labware offsets",
        "description": "Search for labware offsets matching some given criteria.\n\nNothing is modified. The HTTP method here is `POST` only to allow putting the\nsearch query, which is potentially large and complicated, in the request body\ninstead of in a query parameter.",
        "operationId": "search_labware_offsets_labwareOffsets_searches_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_SearchCreate_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_StoredLabwareOffset_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/labwareOffsets/{id}": {
      "delete": {
        "tags": [
          "Labware Offset Management"
        ],
        "summary": "Delete a single labware offset",
        "description": "Delete a single labware offset. The deleted offset is returned.",
        "operationId": "delete_labware_offset_labwareOffsets__id__delete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The `id` field of the offset to delete.",
              "title": "Id"
            },
            "description": "The `id` field of the offset to delete."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_StoredLabwareOffset_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs": {
      "post": {
        "tags": [
          "Run Management"
        ],
        "summary": "Create a run",
        "description": "Create a new run to track robot interaction.\n\nWhen too many runs already exist, old ones will be automatically deleted\nto make room for the new one.",
        "operationId": "create_run_runs_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/RequestModel_RunCreate_"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request Body"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Run_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunAlreadyActive_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FileIdNotFound_"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get all runs",
        "description": "Get a list of all active and inactive runs, in order from oldest to newest.",
        "operationId": "get_runs_runs_get",
        "parameters": [
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The maximum number of runs to return. If this is less than the total number of runs, the most-recently created runs will be returned. If this is omitted or `null`, all runs will be returned.",
              "title": "Pagelength"
            },
            "description": "The maximum number of runs to return. If this is less than the total number of runs, the most-recently created runs will be returned. If this is omitted or `null`, all runs will be returned."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiBody_Union_Run__BadRun__AllRunsLinks_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get a run",
        "description": "Get a specific run by its unique identifier.",
        "operationId": "get_run_runs__runId__get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Union_Run__BadRun__"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Run Management"
        ],
        "summary": "Delete a run",
        "description": "Delete a specific run by its unique identifier.",
        "operationId": "remove_run_runs__runId__delete",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Run Management"
        ],
        "summary": "Update a run",
        "description": "Update a specific run, returning the updated resource.",
        "operationId": "update_run_runs__runId__patch",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_RunUpdate_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Run_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_RunStopped__RunNotIdle__"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/commandErrors": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get a list of all command errors in the run",
        "description": "Get a list of all command errors in the run. \n\nThe errors are returned in order from oldest to newest.\n\nThis endpoint returns the command error. Use `GET /runs/{runId}/commands/{commandId}` to get all information available for a given command.",
        "operationId": "get_run_commands_error_runs__runId__commandErrors_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The maximum number of command errors in the list to return.",
              "default": 20,
              "title": "Pagelength"
            },
            "description": "The maximum number of command errors in the list to return."
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The starting index of the desired first command error in the list. If unspecified, a cursor will be selected automatically based on the last error added.",
              "title": "Cursor"
            },
            "description": "The starting index of the desired first command error in the list. If unspecified, a cursor will be selected automatically based on the last error added."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_ErrorOccurrence_"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunStopped_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/currentState": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get a run's current state.",
        "description": "Get current state associated with a run if the run is current.\n        \"\n\n\"\n        Note that this endpoint is experimental and subject to change.",
        "operationId": "get_current_state_runs__runId__currentState_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Body_RunCurrentState_CurrentStateLinks_"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunStopped_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/commands": {
      "post": {
        "tags": [
          "Run Management"
        ],
        "summary": "Enqueue a command",
        "description": "Add a single command to the run. You can add commands to a run\nfor three reasons:\n\n- Setup commands (`data.source == \"setup\"`)\n- Protocol commands (`data.source == \"protocol\"`)\n- Fixit commands (`data.source == \"fixit\"`)\n\nSetup commands may be enqueued before the run has been started.\nYou could use setup commands to prepare a module or\nrun labware calibration procedures.\n\nProtocol commands may be enqueued anytime using this endpoint.\nYou can create a protocol purely over HTTP using protocol commands.\nIf you are running a protocol from a file(s), then you will likely\nnot need to enqueue protocol commands using this endpoint.\n\nFixit commands may be enqueued while the run is `awaiting-recovery` state.\nThese commands are intended to fix a failed command.\nThey will be executed right after the failed command\nand only if the run is in a `awaiting-recovery` state.\n\nOnce enqueued, setup commands will execute immediately with priority,\nwhile protocol commands will wait until a `play` action is issued.\nA play action may be issued while setup commands are still queued,\nin which case all setup commands will finish executing before\nthe run moves on to protocol commands.\n\nIf you are running a protocol file(s), use caution with this endpoint,\nas added commands may interfere with commands added by the protocol",
        "operationId": "create_run_command_runs__runId__commands_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "waitUntilComplete",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter.",
              "default": false,
              "title": "Waituntilcomplete"
            },
            "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter."
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "null"
                }
              ],
              "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite.",
              "title": "Timeout"
            },
            "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite."
          },
          {
            "name": "failedCommandId",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "FIXIT command use only. Reference of the failed command id we are trying to fix.",
              "title": "Failedcommandid"
            },
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Annotated_Union_AirGapInPlaceCreate__AspirateCreate__AspirateWhileTrackingCreate__AspirateInPlaceCreate__CommentCreate__ConfigureForVolumeCreate__ConfigureNozzleLayoutCreate__CustomCreate__DispenseCreate__DispenseInPlaceCreate__DispenseWhileTrackingCreate__BlowOutCreate__BlowOutInPlaceCreate__DropTipCreate__DropTipInPlaceCreate__HomeCreate__RetractAxisCreate__LoadLabwareCreate__ReloadLabwareCreate__LoadLiquidCreate__LoadLiquidClassCreate__LoadModuleCreate__LoadPipetteCreate__LoadLidStackCreate__LoadLidCreate__MoveLabwareCreate__MoveRelativeCreate__MoveToCoordinatesCreate__MoveToWellCreate__MoveToAddressableAreaCreate__MoveToAddressableAreaForDropTipCreate__PrepareToAspirateCreate__WaitForResumeCreate__WaitForDurationCreate__PickUpTipCreate__SavePositionCreate__SetRailLightsCreate__TouchTipCreate__SetStatusBarCreate__VerifyTipPresenceCreate__GetTipPresenceCreate__GetNextTipCreate__LiquidProbeCreate__TryLiquidProbeCreate__EvotipSealPipetteCreate__EvotipDispenseCreate__EvotipUnsealPipetteCreate__WaitForTemperatureCreate__SetTargetTemperatureCreate__DeactivateHeaterCreate__SetAndWaitForShakeSpeedCreate__DeactivateShakerCreate__OpenLabwareLatchCreate__CloseLabwareLatchCreate__DisengageCreate__EngageCreate__SetTargetTemperatureCreate__WaitForTemperatureCreate__DeactivateTemperatureCreate__SetTargetBlockTemperatureCreate__WaitForBlockTemperatureCreate__SetTargetLidTemperatureCreate__WaitForLidTemperatureCreate__DeactivateBlockCreate__DeactivateLidCreate__OpenLidCreate__CloseLidCreate__RunProfileCreate__RunExtendedProfileCreate__CloseLidCreate__OpenLidCreate__InitializeCreate__ReadAbsorbanceCreate__RetrieveCreate__StoreCreate__SetStoredLabwareCreate__FillCreate__EmptyCreate__CalibrateGripperCreate__CalibratePipetteCreate__CalibrateModuleCreate__MoveToMaintenancePositionCreate__UnsafeBlowOutInPlaceCreate__UnsafeDropTipInPlaceCreate__UpdatePositionEstimatorsCreate__UnsafeEngageAxesCreate__UnsafeUngripLabwareCreate__UnsafePlaceLabwareCreate__MoveAxesRelativeCreate__MoveAxesToCreate__MoveToCreate__openGripperJawCreate__closeGripperJawCreate___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_AirGapInPlace__Aspirate__AspirateInPlace__AspirateWhileTracking__Comment__Custom__Dispense__DispenseInPlace__DispenseWhileTracking__BlowOut__BlowOutInPlace__ConfigureForVolume__ConfigureNozzleLayout__DropTip__DropTipInPlace__Home__RetractAxis__LoadLabware__ReloadLabware__LoadLiquid__LoadLiquidClass__LoadModule__LoadPipette__LoadLidStack__LoadLid__MoveLabware__MoveRelative__MoveToCoordinates__MoveToWell__MoveToAddressableArea__MoveToAddressableAreaForDropTip__PrepareToAspirate__WaitForResume__WaitForDuration__PickUpTip__SavePosition__SetRailLights__TouchTip__SetStatusBar__VerifyTipPresence__GetTipPresence__GetNextTip__LiquidProbe__TryLiquidProbe__EvotipSealPipette__EvotipDispense__EvotipUnsealPipette__WaitForTemperature__SetTargetTemperature__DeactivateHeater__SetAndWaitForShakeSpeed__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch__Disengage__Engage__SetTargetTemperature__WaitForTemperature__DeactivateTemperature__SetTargetBlockTemperature__WaitForBlockTemperature__SetTargetLidTemperature__WaitForLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__RunProfile__RunExtendedProfile__CloseLid__OpenLid__Initialize__ReadAbsorbance__Retrieve__Store__SetStoredLabware__Fill__Empty__CalibrateGripper__CalibratePipette__CalibrateModule__MoveToMaintenancePosition__UnsafeBlowOutInPlace__UnsafeDropTipInPlace__UpdatePositionEstimators__UnsafeEngageAxes__UnsafeUngripLabware__UnsafePlaceLabware__MoveTo__MoveAxesRelative__MoveAxesTo__openGripperJaw__closeGripperJaw___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_CommandNotAllowed___1"
                }
              }
            },
            "description": "Bad Request"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_RunStopped__SetupCommandNotAllowed__"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get a list of all protocol commands in the run",
        "description": "Get a list of all commands in the run and their statuses. \n\nThe commands are returned in order from oldest to newest.\n\nThis endpoint returns command summaries. Use `GET /runs/{runId}/commands/{commandId}` to get all information available for a given command.",
        "operationId": "get_run_commands_runs__runId__commands_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command.",
              "title": "Cursor"
            },
            "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command."
          },
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The maximum number of commands in the list to return.",
              "default": 20,
              "title": "Pagelength"
            },
            "description": "The maximum number of commands in the list to return."
          },
          {
            "name": "includeFixitCommands",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If `true`, return all commands (protocol, setup, fixit). If `false`, only return safe commands (protocol, setup).",
              "default": true,
              "title": "Includefixitcommands"
            },
            "description": "If `true`, return all commands (protocol, setup, fixit). If `false`, only return safe commands (protocol, setup)."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiBody_RunCommandSummary_CommandCollectionLinks_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/commandsAsPreSerializedList": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get all commands of a completed run as a list of pre-serialized commands",
        "description": "Get all commands of a completed run as a list of pre-serialized commands.**Warning:** This endpoint is experimental. We may change or remove it without warning.\n\nThe commands list will only be available after a run has completed (whether successful, failed or stopped) and its data has been committed to the database. If a request is received before the run is completed, it will return a 503 Unavailable error. This is a faster alternative to fetching the full commands list using `GET /runs/{runId}/commands`. For large protocols (10k+ commands), the above endpoint can take minutes to respond, whereas this one should only take a few seconds.",
        "operationId": "get_run_commands_as_pre_serialized_list_runs__runId__commandsAsPreSerializedList_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "includeFixitCommands",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If `true`, return all commands (protocol, setup, fixit). If `false`, only return safe commands (protocol, setup).",
              "default": true,
              "title": "Includefixitcommands"
            },
            "description": "If `true`, return all commands (protocol, setup, fixit). If `false`, only return safe commands (protocol, setup)."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_str_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "503": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_PreSerializedCommandsNotAvailable_"
                }
              }
            },
            "description": "Service Unavailable"
          }
        }
      }
    },
    "/runs/{runId}/commands/{commandId}": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get full details about a specific command in the run",
        "description": "Get a command along with any associated payload, result, and execution information.",
        "operationId": "get_run_command_runs__runId__commands__commandId__get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "commandId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Commandid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_AirGapInPlace__Aspirate__AspirateInPlace__AspirateWhileTracking__Comment__Custom__Dispense__DispenseInPlace__DispenseWhileTracking__BlowOut__BlowOutInPlace__ConfigureForVolume__ConfigureNozzleLayout__DropTip__DropTipInPlace__Home__RetractAxis__LoadLabware__ReloadLabware__LoadLiquid__LoadLiquidClass__LoadModule__LoadPipette__LoadLidStack__LoadLid__MoveLabware__MoveRelative__MoveToCoordinates__MoveToWell__MoveToAddressableArea__MoveToAddressableAreaForDropTip__PrepareToAspirate__WaitForResume__WaitForDuration__PickUpTip__SavePosition__SetRailLights__TouchTip__SetStatusBar__VerifyTipPresence__GetTipPresence__GetNextTip__LiquidProbe__TryLiquidProbe__EvotipSealPipette__EvotipDispense__EvotipUnsealPipette__WaitForTemperature__SetTargetTemperature__DeactivateHeater__SetAndWaitForShakeSpeed__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch__Disengage__Engage__SetTargetTemperature__WaitForTemperature__DeactivateTemperature__SetTargetBlockTemperature__WaitForBlockTemperature__SetTargetLidTemperature__WaitForLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__RunProfile__RunExtendedProfile__CloseLid__OpenLid__Initialize__ReadAbsorbance__Retrieve__Store__SetStoredLabware__Fill__Empty__CalibrateGripper__CalibratePipette__CalibrateModule__MoveToMaintenancePosition__UnsafeBlowOutInPlace__UnsafeDropTipInPlace__UpdatePositionEstimators__UnsafeEngageAxes__UnsafeUngripLabware__UnsafePlaceLabware__MoveTo__MoveAxesRelative__MoveAxesTo__openGripperJaw__closeGripperJaw___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                    },
                    {
                      "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_CommandNotFound___1"
                    }
                  ],
                  "title": "Response 404 Get Run Command Runs  Runid  Commands  Commandid  Get"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/actions": {
      "post": {
        "tags": [
          "Run Management"
        ],
        "summary": "Issue a control action to the run",
        "description": "Provide an action in order to control execution of the run.",
        "operationId": "create_run_action_runs__runId__actions_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_RunActionCreate_"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_RunAction_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_RunActionNotAllowed__RunStopped__"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/labware_offsets": {
      "post": {
        "tags": [
          "Run Management"
        ],
        "summary": "Add labware offsets to a run",
        "description": "Add labware offsets to an existing run, returning the created offsets.\n\nThere is no matching `GET /runs/{runId}/labware_offsets` endpoint. To read the list of labware offsets currently on the run, see the run's `labwareOffsets` field.\n\nThe response body's `data` will either be a single offset or a list of offsets, depending on whether you provided a single offset or a list in the request body's `data`.",
        "operationId": "add_labware_offset_runs__runId__labware_offsets_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate__list_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate____"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Union_LabwareOffset__list_LabwareOffset___"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_RunStopped__RunNotIdle__"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/labware_definitions": {
      "post": {
        "tags": [
          "Run Management"
        ],
        "summary": "Add a labware definition to a run",
        "description": "Add a labware definition to a run, returning the added definition's URI.",
        "operationId": "add_labware_definition_runs__runId__labware_definitions_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Annotated_Union_LabwareDefinition2__LabwareDefinition3___Discriminator__"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_LabwareDefinitionSummary_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___1"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_RunStopped__RunNotIdle__"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/loaded_labware_definitions": {
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get the definitions of a run's loaded labware",
        "description": "Get the definitions of all the labware that the given run has loaded so far.\n\nWhen the run is first created, this list will be empty. As it executes and goes through `loadLabware` commands, those commands' `result.definition`s will be added to this list. Repeated definitions will be deduplicated.",
        "operationId": "get_run_loaded_labware_definitions_runs__runId__loaded_labware_definitions_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_list_Annotated_Union_LabwareDefinition2__LabwareDefinition3___Discriminator___"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunStopped_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/runs/{runId}/errorRecoveryPolicy": {
      "put": {
        "tags": [
          "Run Management"
        ],
        "summary": "Set a run's error recovery policy",
        "description": "Update how to handle different kinds of command failures.\n\nFor this to have any effect, error recovery must also be enabled globally.\nSee `PATCH /errorRecovery/settings`.",
        "operationId": "put_error_recovery_policy_runs__runId__errorRecoveryPolicy_put",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_ErrorRecoveryPolicy_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunStopped_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Run Management"
        ],
        "summary": "Get a run's current error recovery policy",
        "description": "See `PUT /runs/{runId}/errorRecoveryPolicy`.",
        "operationId": "get_error_recovery_policy_runs__runId__errorRecoveryPolicy_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_ErrorRecoveryPolicy_"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunStopped_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs": {
      "post": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Create a maintenance run",
        "description": "Create a new maintenance run to track robot interaction.\n\nIf a maintenance run already exists, it will be cleared\nand a new one will be created.\n\nWill raise an error if a *protocol* run exists and is not idle.",
        "operationId": "create_run_maintenance_runs_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/RequestModel_MaintenanceRunCreate_"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request Body"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_MaintenanceRun_"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolRunIsActive_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/current_run": {
      "get": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Get the current maintenance run",
        "description": "Get the currently active maintenance run, if any",
        "operationId": "get_current_run_maintenance_runs_current_run_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Body_MaintenanceRun_AllRunsLinks_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NoCurrentRunFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/{runId}": {
      "get": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Get a maintenance run",
        "description": "Get a specific run by its unique identifier.",
        "operationId": "get_run_maintenance_runs__runId__get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_MaintenanceRun_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Delete a run",
        "description": "Delete a specific run by its unique identifier.",
        "operationId": "remove_run_maintenance_runs__runId__delete",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/{runId}/commands": {
      "post": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Enqueue a command",
        "description": "Add a single command to the maintenance run.\n\nThese commands will execute immediately and in the order they are\nenqueued. The execution of these commands cannot be paused,\nbut a maintenance run can be deleted at any point, as long as there\nare no commands running.",
        "operationId": "create_run_command_maintenance_runs__runId__commands_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "waitUntilComplete",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter.",
              "default": false,
              "title": "Waituntilcomplete"
            },
            "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter."
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "null"
                }
              ],
              "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite.",
              "title": "Timeout"
            },
            "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Annotated_Union_AirGapInPlaceCreate__AspirateCreate__AspirateWhileTrackingCreate__AspirateInPlaceCreate__CommentCreate__ConfigureForVolumeCreate__ConfigureNozzleLayoutCreate__CustomCreate__DispenseCreate__DispenseInPlaceCreate__DispenseWhileTrackingCreate__BlowOutCreate__BlowOutInPlaceCreate__DropTipCreate__DropTipInPlaceCreate__HomeCreate__RetractAxisCreate__LoadLabwareCreate__ReloadLabwareCreate__LoadLiquidCreate__LoadLiquidClassCreate__LoadModuleCreate__LoadPipetteCreate__LoadLidStackCreate__LoadLidCreate__MoveLabwareCreate__MoveRelativeCreate__MoveToCoordinatesCreate__MoveToWellCreate__MoveToAddressableAreaCreate__MoveToAddressableAreaForDropTipCreate__PrepareToAspirateCreate__WaitForResumeCreate__WaitForDurationCreate__PickUpTipCreate__SavePositionCreate__SetRailLightsCreate__TouchTipCreate__SetStatusBarCreate__VerifyTipPresenceCreate__GetTipPresenceCreate__GetNextTipCreate__LiquidProbeCreate__TryLiquidProbeCreate__EvotipSealPipetteCreate__EvotipDispenseCreate__EvotipUnsealPipetteCreate__WaitForTemperatureCreate__SetTargetTemperatureCreate__DeactivateHeaterCreate__SetAndWaitForShakeSpeedCreate__DeactivateShakerCreate__OpenLabwareLatchCreate__CloseLabwareLatchCreate__DisengageCreate__EngageCreate__SetTargetTemperatureCreate__WaitForTemperatureCreate__DeactivateTemperatureCreate__SetTargetBlockTemperatureCreate__WaitForBlockTemperatureCreate__SetTargetLidTemperatureCreate__WaitForLidTemperatureCreate__DeactivateBlockCreate__DeactivateLidCreate__OpenLidCreate__CloseLidCreate__RunProfileCreate__RunExtendedProfileCreate__CloseLidCreate__OpenLidCreate__InitializeCreate__ReadAbsorbanceCreate__RetrieveCreate__StoreCreate__SetStoredLabwareCreate__FillCreate__EmptyCreate__CalibrateGripperCreate__CalibratePipetteCreate__CalibrateModuleCreate__MoveToMaintenancePositionCreate__UnsafeBlowOutInPlaceCreate__UnsafeDropTipInPlaceCreate__UpdatePositionEstimatorsCreate__UnsafeEngageAxesCreate__UnsafeUngripLabwareCreate__UnsafePlaceLabwareCreate__MoveAxesRelativeCreate__MoveAxesToCreate__MoveToCreate__openGripperJawCreate__closeGripperJawCreate___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_AirGapInPlace__Aspirate__AspirateInPlace__AspirateWhileTracking__Comment__Custom__Dispense__DispenseInPlace__DispenseWhileTracking__BlowOut__BlowOutInPlace__ConfigureForVolume__ConfigureNozzleLayout__DropTip__DropTipInPlace__Home__RetractAxis__LoadLabware__ReloadLabware__LoadLiquid__LoadLiquidClass__LoadModule__LoadPipette__LoadLidStack__LoadLid__MoveLabware__MoveRelative__MoveToCoordinates__MoveToWell__MoveToAddressableArea__MoveToAddressableAreaForDropTip__PrepareToAspirate__WaitForResume__WaitForDuration__PickUpTip__SavePosition__SetRailLights__TouchTip__SetStatusBar__VerifyTipPresence__GetTipPresence__GetNextTip__LiquidProbe__TryLiquidProbe__EvotipSealPipette__EvotipDispense__EvotipUnsealPipette__WaitForTemperature__SetTargetTemperature__DeactivateHeater__SetAndWaitForShakeSpeed__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch__Disengage__Engage__SetTargetTemperature__WaitForTemperature__DeactivateTemperature__SetTargetBlockTemperature__WaitForBlockTemperature__SetTargetLidTemperature__WaitForLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__RunProfile__RunExtendedProfile__CloseLid__OpenLid__Initialize__ReadAbsorbance__Retrieve__Store__SetStoredLabware__Fill__Empty__CalibrateGripper__CalibratePipette__CalibrateModule__MoveToMaintenancePosition__UnsafeBlowOutInPlace__UnsafeDropTipInPlace__UpdatePositionEstimators__UnsafeEngageAxes__UnsafeUngripLabware__UnsafePlaceLabware__MoveTo__MoveAxesRelative__MoveAxesTo__openGripperJaw__closeGripperJaw___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_CommandNotAllowed___2"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Get a list of all commands in the run",
        "description": "Get a list of all commands in the run and their statuses. This endpoint returns command summaries. Use `GET /maintenance_runs/{runId}/commands/{commandId}` to get all information available for a given command.",
        "operationId": "get_run_commands_maintenance_runs__runId__commands_get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command.",
              "title": "Cursor"
            },
            "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command."
          },
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The maximum number of commands in the list to return.",
              "default": 20,
              "title": "Pagelength"
            },
            "description": "The maximum number of commands in the list to return."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MultiBody_RunCommandSummary_CommandCollectionLinks_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/{runId}/commands/{commandId}": {
      "get": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Get full details about a specific command in the run",
        "description": "Get a command along with any associated payload, result, and execution information.",
        "operationId": "get_run_command_maintenance_runs__runId__commands__commandId__get",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "commandId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Commandid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_AirGapInPlace__Aspirate__AspirateInPlace__AspirateWhileTracking__Comment__Custom__Dispense__DispenseInPlace__DispenseWhileTracking__BlowOut__BlowOutInPlace__ConfigureForVolume__ConfigureNozzleLayout__DropTip__DropTipInPlace__Home__RetractAxis__LoadLabware__ReloadLabware__LoadLiquid__LoadLiquidClass__LoadModule__LoadPipette__LoadLidStack__LoadLid__MoveLabware__MoveRelative__MoveToCoordinates__MoveToWell__MoveToAddressableArea__MoveToAddressableAreaForDropTip__PrepareToAspirate__WaitForResume__WaitForDuration__PickUpTip__SavePosition__SetRailLights__TouchTip__SetStatusBar__VerifyTipPresence__GetTipPresence__GetNextTip__LiquidProbe__TryLiquidProbe__EvotipSealPipette__EvotipDispense__EvotipUnsealPipette__WaitForTemperature__SetTargetTemperature__DeactivateHeater__SetAndWaitForShakeSpeed__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch__Disengage__Engage__SetTargetTemperature__WaitForTemperature__DeactivateTemperature__SetTargetBlockTemperature__WaitForBlockTemperature__SetTargetLidTemperature__WaitForLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__RunProfile__RunExtendedProfile__CloseLid__OpenLid__Initialize__ReadAbsorbance__Retrieve__Store__SetStoredLabware__Fill__Empty__CalibrateGripper__CalibratePipette__CalibrateModule__MoveToMaintenancePosition__UnsafeBlowOutInPlace__UnsafeDropTipInPlace__UpdatePositionEstimators__UnsafeEngageAxes__UnsafeUngripLabware__UnsafePlaceLabware__MoveTo__MoveAxesRelative__MoveAxesTo__openGripperJaw__closeGripperJaw___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                    },
                    {
                      "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_CommandNotFound___2"
                    }
                  ],
                  "title": "Response 404 Get Run Command Maintenance Runs  Runid  Commands  Commandid  Get"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/{runId}/labware_offsets": {
      "post": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Add a labware offset to a maintenance run",
        "description": "Add a labware offset to an existing run, returning the created offset.\n\nThere is no matching `GET /maintenance_runs/{runId}/labware_offsets` endpoint. To read the list of labware offsets currently on the run, see the run's `labwareOffsets` field.\n\nThe response body's `data` will either be a single offset or a list of offsets, depending on whether you provided a single offset or a list in the request body's `data`.",
        "operationId": "add_labware_offset_maintenance_runs__runId__labware_offsets_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate__list_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate____"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Union_LabwareOffset__list_LabwareOffset___"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunNotIdle_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/maintenance_runs/{runId}/labware_definitions": {
      "post": {
        "tags": [
          "Maintenance Run Management"
        ],
        "summary": "Add a labware definition to a maintenance run",
        "description": "Add a labware definition to a run, returning the added definition's URI.",
        "operationId": "add_labware_definition_maintenance_runs__runId__labware_definitions_post",
        "parameters": [
          {
            "name": "runId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Runid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Annotated_Union_LabwareDefinition2__LabwareDefinition3___Discriminator__"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_MaintenanceRun_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_RunNotFound___2"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunNotIdle_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols": {
      "post": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Upload a protocol",
        "description": "Upload a protocol to your device. You may include the following files:\n\n- A single Python protocol file and 0 or more custom labware JSON files\n- A single JSON protocol file (any additional labware files will be ignored)\n\nWhen too many protocols already exist, old ones will be automatically deleted\nto make room for the new one.\nA protocol will never be automatically deleted if there's a run\nreferring to it, though. (See the `/runs/` endpoints.)\n\nIf you upload the exact same set of files multiple times, the first protocol\nresource will be returned instead of creating duplicate ones.\n\nWhen a new protocol resource is created, an analysis is started for it.\nA new analysis is also started if the same protocol file is uploaded but with\na different set of run-time parameter values than the most recent request.\nSee the `/protocols/{id}/analyses/` endpoints for more details.\n\nYou can provide the kind of protocol with the `protocol_kind` form data\nThe protocol kind can be:\n\n- `quick-transfer` for Quick Transfer protocols\n- `standard`       for non Quick transfer protocols\n\nif the `protocol_kind` is None it will be defaulted to `standard`.\n\nQuick transfer protocols:\n- Do not store any run history\n- Do not get auto deleted, instead they have a fixed max count.",
        "operationId": "create_protocol_protocols_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_protocol_protocols_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Protocol_"
                }
              }
            },
            "description": "OK"
          },
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Protocol_"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_ProtocolFilesInvalid__ProtocolRobotTypeMismatch__FileIdNotFound__"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "503": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_LastAnalysisPending_"
                }
              }
            },
            "description": "Service Unavailable"
          }
        }
      },
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Get uploaded protocols",
        "description": "Return all stored protocols by default, in order from first-uploaded to last-uploaded.\n    You can provide the kind of protocol with the `protocolKind` query arg",
        "operationId": "get_protocols_protocols_get",
        "parameters": [
          {
            "name": "protocolKind",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ProtocolKind"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Specify the kind of protocols you want to return. protocol kind can be `quick-transfer` or `standard`  If this is omitted or `null`, all protocols will be returned.",
              "title": "Protocolkind"
            },
            "description": "Specify the kind of protocols you want to return. protocol kind can be `quick-transfer` or `standard`  If this is omitted or `null`, all protocols will be returned."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_Protocol_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/ids": {
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "[Internal] Get uploaded protocol IDs",
        "description": "Get the IDs of all protocols stored on the server.\n\n**Warning:** This is an experimental endpoint and is only meant for internal use by Opentrons. We might remove it or change its behavior without warning.",
        "operationId": "get_protocol_ids_protocols_ids_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_str_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/{protocolId}": {
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Get an uploaded protocol",
        "description": "Get an uploaded protocol by ID.\n\nArgs:\n    protocolId: Protocol identifier to fetch, pulled from URL.\n    protocol_store: In-memory database of protocol resources.\n    analysis_store: In-memory database of protocol analyses.",
        "operationId": "get_protocol_by_id_protocols__protocolId__get",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Body_Protocol_ProtocolLinks_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Delete an uploaded protocol",
        "description": "Delete an uploaded protocol by ID.\n\nArguments:\n    protocolId: Protocol identifier to delete, pulled from URL.\n    protocol_store: In-memory database of protocol resources.",
        "operationId": "delete_protocol_by_id_protocols__protocolId__delete",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolUsedByRun_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/{protocolId}/analyses": {
      "post": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Analyze the protocol",
        "description": "Generate an analysis for the protocol, based on last analysis and current request data.",
        "operationId": "create_protocol_analysis_protocols__protocolId__analyses_post",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/RequestModel_AnalysisRequest_"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request Body"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_AnalysisSummary_"
                }
              }
            },
            "description": "OK"
          },
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_AnalysisSummary_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FileIdNotFound_"
                }
              }
            },
            "description": "Unprocessable Entity"
          },
          "503": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_LastAnalysisPending_"
                }
              }
            },
            "description": "Service Unavailable"
          }
        }
      },
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Get a protocol's analyses",
        "description": "Get a protocol's full analyses list.\n\nAnalyses are returned in order from least-recently started to most-recently started.\n\nArguments:\n    protocolId: Protocol identifier to delete, pulled from URL.\n    protocol_store: Database of protocol resources.\n    analysis_store: Database of analysis resources.",
        "operationId": "get_protocol_analyses_protocols__protocolId__analyses_get",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_Union_PendingAnalysis__CompletedAnalysis__"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/{protocolId}/analyses/{analysisId}": {
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Get one of a protocol's analyses",
        "description": "Get a protocol analysis by analysis ID.\n\nArguments:\n    protocolId: The ID of the protocol, pulled from the URL.\n    analysisId: The ID of the analysis, pulled from the URL.\n    protocol_store: Protocol resource storage.\n    analysis_store: Analysis resource storage.",
        "operationId": "get_protocol_analysis_by_id_protocols__protocolId__analyses__analysisId__get",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "analysisId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Analysisid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Union_PendingAnalysis__CompletedAnalysis__"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_ProtocolNotFound__AnalysisNotFound__"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/{protocolId}/analyses/{analysisId}/asDocument": {
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "[Experimental] Get one of a protocol's analyses as a raw document",
        "description": "**Warning:** This endpoint is experimental. We may change or remove it without warning.\n\nThis is a faster alternative to `GET /protocols/{protocolId}/analyses` and `GET /protocols/{protocolId}/analyses/{analysisId}`. For large analyses (10k+ commands), those other endpoints can take minutes to respond, whereas this one should only take a few seconds.\n\nFor a completed analysis, this returns the same JSON data as the `GET /protocols/:id/analyses/:id` endpoint, except that it's not wrapped in a top-level `data` object.\n\nFor a *pending* analysis, this returns a 404 response, unlike those other endpoints, which return a 200 response with `\"status\": \"pending\"`.",
        "operationId": "get_protocol_analysis_as_document_protocols__protocolId__analyses__analysisId__asDocument_get",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "analysisId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Analysisid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_ProtocolNotFound__AnalysisNotFound__"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocols/{protocolId}/dataFiles": {
      "get": {
        "tags": [
          "Protocol Management"
        ],
        "summary": "Get all the data files used with the specified protocol.",
        "description": "Returns a list of all data files used in analyses and runs associated with the specified protocol.",
        "operationId": "get_protocol_data_files_protocols__protocolId__dataFiles_get",
        "parameters": [
          {
            "name": "protocolId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Protocolid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_DataFile_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_ProtocolNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/dataFiles": {
      "post": {
        "tags": [
          "Data files Management"
        ],
        "summary": "Upload a data file",
        "description": "Upload data file(s) to your device.",
        "operationId": "upload_data_file_dataFiles_post",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_upload_data_file_dataFiles_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_DataFile_"
                }
              }
            },
            "description": "OK"
          },
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_DataFile_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FileNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_MultipleDataFileSources__NoDataFileSourceProvided__UnexpectedFileFormat__"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "get": {
        "tags": [
          "Data files Management"
        ],
        "summary": "Get a list of all data files stored on the robot server",
        "description": "Get a list of all data files stored on the robot server.\n\nArgs:\n    data_files_store: In-memory database of data file resources.",
        "operationId": "get_all_data_files_dataFiles_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_str_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/dataFiles/{dataFileId}": {
      "get": {
        "tags": [
          "Data files Management"
        ],
        "summary": "Get information about an uploaded data file",
        "description": "Get data file info by ID.\n\nArgs:\n    dataFileId: Data file identifier to fetch.\n    data_files_store: In-memory database of data file resources.",
        "operationId": "get_data_file_info_by_id_dataFiles__dataFileId__get",
        "parameters": [
          {
            "name": "dataFileId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Datafileid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_DataFile_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FileIdNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Data files Management"
        ],
        "summary": "Delete a data file from persistent storage",
        "description": "Delete an uploaded or generated data file by ID.\n\nArguments:\n    dataFileId: ID of the data file to delete, pulled from URL.\n    data_files_store: Store for data files database access.",
        "operationId": "delete_file_by_id_dataFiles__dataFileId__delete",
        "parameters": [
          {
            "name": "dataFileId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Datafileid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleEmptyBody"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FileIdNotFound_"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_DataFileInUse_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/dataFiles/{dataFileId}/download": {
      "get": {
        "tags": [
          "Data files Management"
        ],
        "summary": "Get an uploaded data file",
        "description": "Get the requested data file by id.",
        "operationId": "get_data_file_dataFiles__dataFileId__download_get",
        "parameters": [
          {
            "name": "dataFileId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Datafileid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_Union_FileIdNotFound__FileNotFound__"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/commands": {
      "post": {
        "tags": [
          "Simple Commands"
        ],
        "summary": "Add a command to be executed",
        "description": "Run a single command on the robot. This endpoint is meant for simple, stateless control of the robot. For complex control, create a run with ``POST /runs`` and issue commands on that run.",
        "operationId": "create_command_commands_post",
        "parameters": [
          {
            "name": "waitUntilComplete",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter.",
              "default": false,
              "title": "Waituntilcomplete"
            },
            "description": "If `false`, return immediately, while the new command is still queued. If `true`, only return once the new command succeeds or fails, or when the timeout is reached. See the `timeout` query parameter."
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer",
                  "exclusiveMinimum": 0
                },
                {
                  "type": "null"
                }
              ],
              "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite.",
              "title": "Timeout"
            },
            "description": "If `waitUntilComplete` is `true`, the maximum time in milliseconds to wait before returning. The default is infinite.\n\nThe timer starts as soon as you enqueue the new command with this request, *not* when the new command starts running. So if there are other commands in the queue before the new one, they will also count towards the timeout.\n\nIf the timeout elapses before the command succeeds or fails, the command will be returned with its current status.\n\nCompatibility note: on robot software v6.2.0 and older, the default was 30 seconds, not infinite."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Annotated_Union_HomeCreate__SetRailLightsCreate__SetStatusBarCreate__EngageCreate__DisengageCreate__SetTargetTemperatureCreate__DeactivateTemperatureCreate__SetTargetBlockTemperatureCreate__SetTargetLidTemperatureCreate__DeactivateBlockCreate__DeactivateLidCreate__OpenLidCreate__CloseLidCreate__SetTargetTemperatureCreate__SetAndWaitForShakeSpeedCreate__DeactivateHeaterCreate__DeactivateShakerCreate__OpenLabwareLatchCreate__CloseLabwareLatchCreate___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_Home__SetRailLights__SetStatusBar__Engage__Disengage__SetTargetTemperature__DeactivateTemperature__SetTargetBlockTemperature__SetTargetLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__SetTargetTemperature__SetAndWaitForShakeSpeed__DeactivateHeater__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunActive_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Simple Commands"
        ],
        "summary": "Get a list of queued and executed commands",
        "description": "Get a list of commands that have been run on the device since boot. Only returns command run via the `/commands` endpoint.",
        "operationId": "get_commands_list_commands_get",
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command.",
              "title": "Cursor"
            },
            "description": "The starting index of the desired first command in the list. If unspecified, a cursor will be selected automatically based on the currently running or most recently executed command."
          },
          {
            "name": "pageLength",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The maximum number of commands in the list to return.",
              "default": 20,
              "title": "Pagelength"
            },
            "description": "The maximum number of commands in the list to return."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_Annotated_Union_Home__SetRailLights__SetStatusBar__Engage__Disengage__SetTargetTemperature__DeactivateTemperature__SetTargetBlockTemperature__SetTargetLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__SetTargetTemperature__SetAndWaitForShakeSpeed__DeactivateHeater__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunActive_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/commands/{commandId}": {
      "get": {
        "tags": [
          "Simple Commands"
        ],
        "summary": "Get a single stateless command.",
        "description": "Get a single stateless command that has been queued or executed. Only returns command run via the `/commands` endpoint.",
        "operationId": "get_command_commands__commandId__get",
        "parameters": [
          {
            "name": "commandId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Commandid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_Annotated_Union_Home__SetRailLights__SetStatusBar__Engage__Disengage__SetTargetTemperature__DeactivateTemperature__SetTargetBlockTemperature__SetTargetLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__SetTargetTemperature__SetAndWaitForShakeSpeed__DeactivateHeater__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorBody_CommandNotFound___3"
                }
              }
            },
            "description": "Not Found"
          },
          "409": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_RunActive_"
                }
              }
            },
            "description": "Conflict"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/deck_configuration": {
      "put": {
        "tags": [
          "Flex Deck Configuration"
        ],
        "summary": "Set the Flex deck configuration",
        "description": "Inform the robot how its deck is physically set up.\n\nWhen you use the `/runs` and `/maintenance_runs` endpoints to command the robot to move, the robot will automatically dodge the obstacles that you declare here.\n\nIf a run command tries to do something that inherently conflicts with this deck configuration, such as loading a labware into a staging area slot that this deck configuration doesn't provide, the run command will fail with an error.\n\nAfter you set the deck configuration, it will persist, even across reboots, until you set it to something else.\n\n**Warning:** Currently, you can call this endpoint at any time, even while there is an active run. However, the robot can't adapt to deck configuration changes in the middle of a run. The robot will effectively take a snapshot of the deck configuration when the run is first played. In the future, this endpoint may error if you try to call it in the middle of an active run, so don't rely on being able to do that.\n\n**Warning:** Only use this on Flex robots, never OT-2 robots. The behavior on OT-2 robots is currently undefined and it may interfere with protocol execution.",
        "operationId": "put_deck_configuration_deck_configuration_put",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_DeckConfigurationRequest_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/SimpleBody_DeckConfigurationResponse_"
                    },
                    {
                      "$ref": "#/components/schemas/ErrorBody_InvalidDeckConfiguration_"
                    }
                  ],
                  "title": "Response Put Deck Configuration Deck Configuration Put",
                  "$ref": "#/components/schemas/SimpleBody_DeckConfigurationResponse_"
                }
              }
            }
          },
          "422": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_InvalidDeckConfiguration_"
                }
              }
            },
            "description": "Unprocessable Entity"
          }
        }
      },
      "get": {
        "tags": [
          "Flex Deck Configuration"
        ],
        "summary": "Get the Flex deck configuration",
        "description": "Get the robot's current deck configuration. See `PUT /deck_configuration` for background information.\n\n**Warning:** The behavior of this endpoint is currently only defined for Flex robots, not OT-2 robots.",
        "operationId": "get_deck_configuration_deck_configuration_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_DeckConfigurationResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/errorRecovery/settings": {
      "get": {
        "tags": [
          "Error Recovery Settings"
        ],
        "summary": "Get current error recovery settings",
        "operationId": "get_error_recovery_settings_errorRecovery_settings_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_ResponseData_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Error Recovery Settings"
        ],
        "summary": "Set error recovery settings",
        "operationId": "patch_error_recovery_settings_errorRecovery_settings_patch",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_RequestData_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_ResponseData_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Error Recovery Settings"
        ],
        "summary": "Reset error recovery settings to defaults",
        "operationId": "delete_error_recovery_settings_errorRecovery_settings_delete",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_ResponseData_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/modules": {
      "get": {
        "tags": [
          "Attached Modules"
        ],
        "summary": "Get attached modules.",
        "description": "Get a list of all modules currently attached to the robot.",
        "operationId": "get_attached_modules_modules_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_Union_TemperatureModule__MagneticModule__ThermocyclerModule__HeaterShakerModule__AbsorbanceReaderModule__FlexStackerModule__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/instruments": {
      "get": {
        "tags": [
          "Attached Instruments"
        ],
        "summary": "Get attached instruments",
        "description": "Get a list of all instruments (pipettes & gripper) currently attached to the robot.\n\n**Warning:** The behavior of this endpoint is currently only defined for Flex robots. For OT-2 robots, use `/pipettes` instead.",
        "operationId": "get_attached_instruments_instruments_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_Union_Pipette__Gripper__BadPipette__BadGripper__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/sessions": {
      "post": {
        "tags": [
          "OT-2 Calibration Sessions"
        ],
        "summary": "Create an OT-2 calibration session",
        "description": "Create a session to perform a calibration procedure on an OT-2.\n\n**Warning:** These `/sessions/` endpoints are tightly coupled to the Opentrons App and are not intended for general public use.",
        "operationId": "create_session_handler_sessions_post",
        "deprecated": true,
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Union_CalibrationCheckCreateAttributes__TipLengthCalibrationCreateAttributes__DeckCalibrationCreateAttributes__PipetteOffsetCalibrationCreateAttributes__"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "OT-2 Calibration Sessions"
        ],
        "summary": "Get all OT-2 calibration sessions",
        "description": "**Warning:** These `/sessions/` endpoints are tightly coupled to the Opentrons App and are not intended for general public use.",
        "operationId": "get_sessions_handler_sessions_get",
        "deprecated": true,
        "parameters": [
          {
            "name": "session_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/SessionType"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Will limit the results to only this session type",
              "title": "Session Type"
            },
            "description": "Will limit the results to only this session type"
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedMultiResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/sessions/{sessionId}": {
      "delete": {
        "tags": [
          "OT-2 Calibration Sessions"
        ],
        "summary": "Delete an OT-2 calibration session",
        "description": "**Warning:** These `/sessions/` endpoints are tightly coupled to the Opentrons App and are not intended for general public use.",
        "operationId": "delete_session_handler_sessions__sessionId__delete",
        "deprecated": true,
        "parameters": [
          {
            "name": "sessionId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sessionid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "OT-2 Calibration Sessions"
        ],
        "summary": "Get an OT-2 calibration session",
        "description": "**Warning:** These `/sessions/` endpoints are tightly coupled to the Opentrons App and are not intended for general public use.",
        "operationId": "get_session_handler_sessions__sessionId__get",
        "deprecated": true,
        "parameters": [
          {
            "name": "sessionId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sessionid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/sessions/{sessionId}/commands/execute": {
      "post": {
        "tags": [
          "OT-2 Calibration Sessions"
        ],
        "summary": "Execute an OT-2 calibration command",
        "description": "**Warning:** These `/sessions/` endpoints are tightly coupled to the Opentrons App and are not intended for general public use.",
        "operationId": "session_command_execute_handler_sessions__sessionId__commands_execute_post",
        "deprecated": true,
        "parameters": [
          {
            "name": "sessionId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sessionid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_Union_SessionCommandRequest_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition___EmptyModel__EmptyModel___SessionCommandRequest_Literal_load_labware___LoadLabwareCreate__LoadLabwareResult___SessionCommandRequest_Literal_load_pipette___LoadPipetteCreate__LoadPipetteResult___SessionCommandRequest_Literal_aspirate___AspirateCreate__AspirateResult___SessionCommandRequest_Literal_dispense___DispenseCreate__DispenseResult___SessionCommandRequest_Literal_pick_up_tip___PickUpTipCreate__PickUpTipResult___SessionCommandRequest_Literal_drop_tip___DropTipCreate__DropTipResult___SessionCommandRequest_Literal_jog___JogPosition__EmptyModel___SessionCommandRequest_Literal_set_has_calibration_block___SetHasCalibrationBlockRequestData__EmptyModel___SessionCommandRequest_Literal_load_labware___LoadLabwareByDefinitionRequestData__EmptyModel___"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_Union_SessionCommandResponse_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition___EmptyModel__EmptyModel___SessionCommandResponse_Literal_load_labware___LoadLabwareCreate__LoadLabwareResult___SessionCommandResponse_Literal_load_pipette___LoadPipetteCreate__LoadPipetteResult___SessionCommandResponse_Literal_aspirate___AspirateCreate__AspirateResult___SessionCommandResponse_Literal_dispense___DispenseCreate__DispenseResult___SessionCommandResponse_Literal_pick_up_tip___PickUpTipCreate__PickUpTipResult___SessionCommandResponse_Literal_drop_tip___DropTipCreate__DropTipResult___SessionCommandResponse_Literal_jog___JogPosition__EmptyModel___SessionCommandResponse_Literal_set_has_calibration_block___SetHasCalibrationBlockRequestData__EmptyModel___SessionCommandResponse_Literal_load_labware___LoadLabwareByDefinitionRequestData__EmptyModel___"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/labware/calibrations": {
      "get": {
        "tags": [
          "Labware Calibration Management"
        ],
        "summary": "Fetch all saved labware calibrations from the robot",
        "description": "This endpoint has been removed. Use the `/runs` endpoints to manage labware offsets.",
        "operationId": "get_all_labware_calibrations_labware_calibrations_get",
        "deprecated": true,
        "parameters": [
          {
            "name": "loadName",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Loadname"
            }
          },
          {
            "name": "namespace",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Namespace"
            }
          },
          {
            "name": "version",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Version"
            }
          },
          {
            "name": "parent",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Parent"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedMultiResponseModel_LabwareCalibration_"
                }
              }
            }
          },
          "410": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_LabwareCalibrationEndpointsRemoved_"
                }
              }
            },
            "description": "Gone"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/labware/calibrations/{calibrationId}": {
      "get": {
        "tags": [
          "Labware Calibration Management"
        ],
        "summary": "Get a saved labware calibration by ID",
        "description": "This endpoint has been removed. Use the `/runs` endpoints to manage labware offsets.",
        "operationId": "get_specific_labware_calibration_labware_calibrations__calibrationId__get",
        "deprecated": true,
        "parameters": [
          {
            "name": "calibrationId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Calibrationid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody"
                }
              }
            },
            "description": "Not Found"
          },
          "410": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_LabwareCalibrationEndpointsRemoved_"
                }
              }
            },
            "description": "Gone"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Labware Calibration Management"
        ],
        "summary": "Remove a saved labware calibration by ID",
        "description": "This endpoint has been removed. Use the `/runs` endpoints to manage labware offsets.",
        "operationId": "delete_specific_labware_calibration_labware_calibrations__calibrationId__delete",
        "deprecated": true,
        "parameters": [
          {
            "name": "calibrationId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Calibrationid"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody"
                }
              }
            },
            "description": "Not Found"
          },
          "410": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_LabwareCalibrationEndpointsRemoved_"
                }
              }
            },
            "description": "Gone"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/calibration/pipette_offset": {
      "get": {
        "tags": [
          "Pipette Offset Calibration Management"
        ],
        "summary": "Get all pipette offset calibrations",
        "description": "Fetch all saved pipette offset calibrations from the robot",
        "operationId": "get_all_pipette_offset_calibrations_calibration_pipette_offset_get",
        "parameters": [
          {
            "name": "pipette_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Pipette Id"
            }
          },
          {
            "name": "mount",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/robot_server__service__pipette_offset__models__MountType"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mount"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedMultiResponseModel_PipetteOffsetCalibration_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Pipette Offset Calibration Management"
        ],
        "summary": "Delete a pipette offset calibration",
        "description": "Delete one specific pipette calibration by pipette serial and mount.",
        "operationId": "delete_specific_pipette_offset_calibration_calibration_pipette_offset_delete",
        "parameters": [
          {
            "name": "pipette_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Pipette Id"
            }
          },
          {
            "name": "mount",
            "in": "query",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/robot_server__service__pipette_offset__models__MountType"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/calibration/tip_length": {
      "get": {
        "tags": [
          "Tip Length Calibration Management"
        ],
        "summary": "Search the robot for any saved tip length calibration",
        "description": "Fetch all saved tip length calibrations from the robot",
        "operationId": "get_all_tip_length_calibrations_calibration_tip_length_get",
        "parameters": [
          {
            "name": "tiprack_hash",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter results by their `tiprack` field. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprack_uri` instead.",
              "title": "Tiprack Hash"
            },
            "description": "Filter results by their `tiprack` field. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprack_uri` instead.",
            "deprecated": true
          },
          {
            "name": "pipette_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter results by their `pipette` field.",
              "title": "Pipette Id"
            },
            "description": "Filter results by their `pipette` field."
          },
          {
            "name": "tiprack_uri",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter results by their `uri` field.",
              "title": "Tiprack Uri"
            },
            "description": "Filter results by their `uri` field."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedMultiResponseModel_TipLengthCalibration_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tip Length Calibration Management"
        ],
        "summary": "Delete Specific Tip Length Calibration",
        "description": "Delete one specific tip length calibration by pipette serial and tiprack uri",
        "operationId": "delete_specific_tip_length_calibration_calibration_tip_length_delete",
        "parameters": [
          {
            "name": "pipette_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The `pipette` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)",
              "title": "Pipette Id"
            },
            "description": "The `pipette` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)"
          },
          {
            "name": "tiprack_hash",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `tiprack` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)\n\n This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprack_uri` instead.\n\nYou must supply either this or `tiprack_uri`.",
              "title": "Tiprack Hash"
            },
            "description": "The `tiprack` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)\n\n This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprack_uri` instead.\n\nYou must supply either this or `tiprack_uri`.",
            "deprecated": true
          },
          {
            "name": "tiprack_uri",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `uri` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)\n\n You must supply either this or `tiprack_hash`.",
              "title": "Tiprack Uri"
            },
            "description": "The `uri` field value of the calibration you want to delete. (See `GET /calibration/tip_length`.)\n\n You must supply either this or `tiprack_hash`."
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/system/time": {
      "get": {
        "tags": [
          "System Control"
        ],
        "summary": "Fetch system time & date",
        "description": "Get robot's time status, which includes- current UTC date & time, local timezone, whether robot time is synced with an NTP server &/or it has an active RTC.",
        "operationId": "get_time_system_time_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_SystemTimeResponseAttributes_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "System Control"
        ],
        "summary": "Set robot time",
        "description": "Update system time",
        "operationId": "set_time_system_time_put",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestModel_SystemTimeAttributes_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeprecatedResponseModel_SystemTimeResponseAttributes_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/status": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get all attached subsystems",
        "description": "Get the details of all hardware subsystems attached to the robot.",
        "operationId": "get_attached_subsystems_subsystems_status_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_PresentSubsystem_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NotSupportedOnOT2_"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/status/{subsystem}": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get a specific attached subsystem",
        "description": "Get the details of a single hardware subsystem attached to the robot.",
        "operationId": "get_attached_subsystem_subsystems_status__subsystem__get",
        "parameters": [
          {
            "name": "subsystem",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/SubSystem"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_PresentSubsystem_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NotSupportedOnOT2_"
                }
              }
            },
            "description": "Forbidden"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_SubsystemNotPresent_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/updates/current": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get all ongoing subsystem updates",
        "description": "Get a list of currently-running subsystem firmware updates. This is a good snapshot of what, if anything, is currently being updated and may block other robot work. To guarantee data about an update you were previously interested in, get its `id` using `/subsystems/updates/all`.",
        "operationId": "get_subsystem_updates_subsystems_updates_current_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_UpdateProgressSummary_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/updates/current/{subsystem}": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get the ongoing update for a specific subsystem",
        "description": "As `/subsystems/updates/current`, but filtered by the route parameter.",
        "operationId": "get_subsystem_update_subsystems_updates_current__subsystem__get",
        "parameters": [
          {
            "name": "subsystem",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/SubSystem"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_UpdateProgressData_"
                }
              }
            }
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NoOngoingUpdate_"
                }
              }
            },
            "description": "Not Found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/updates/all": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get all subsystem updates",
        "description": "Get a list of all updates, including both ongoing updates and updates that started since the last boot but are now complete.\n\n While an update might complete and therefore disappear from`/subsystems/updates/current`, you can always find that update in the response to this endpoint by its `id`.",
        "operationId": "get_update_processes_subsystems_updates_all_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleMultiBody_UpdateProgressData_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/updates/all/{id}": {
      "get": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Get a specific subsystem update",
        "description": "As `/subsystems/updates/all`, but returning only one resource: the one with the `id` matching the route parameter (if it exists).",
        "operationId": "get_update_process_subsystems_updates_all__id__get",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_UpdateProgressData_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/subsystems/updates/{subsystem}": {
      "post": {
        "tags": [
          "Flex Subsystem Management"
        ],
        "summary": "Start an update for a subsystem",
        "description": "Begin a firmware update for a given subsystem.",
        "operationId": "begin_subsystem_update_subsystems_updates__subsystem__post",
        "parameters": [
          {
            "name": "subsystem",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/SubSystem"
            }
          },
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_UpdateProgressData_"
                }
              }
            }
          },
          "201": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_UpdateProgressData_"
                }
              }
            },
            "description": "Created"
          },
          "303": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_UpdateProgressData_"
                }
              }
            },
            "description": "See Other"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_SubsystemNotPresent_"
                }
              }
            },
            "description": "Not Found"
          },
          "412": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NoUpdateAvailable_"
                }
              }
            },
            "description": "Precondition Failed"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_FirmwareUpdateFailed_"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/robot/control/estopStatus": {
      "get": {
        "tags": [
          "Robot"
        ],
        "summary": "Get connected estop status.",
        "description": "Get the current estop status of the robot, as well as a list of connected estops.",
        "operationId": "get_estop_status_robot_control_estopStatus_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_EstopStatusModel_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NotSupportedOnOT2_"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/robot/control/acknowledgeEstopDisengage": {
      "put": {
        "tags": [
          "Robot"
        ],
        "summary": "Acknowledge and clear an Estop event.",
        "description": "If the estop is currently logically engaged (the estop was previously pressed but is now released), this endpoint will reset the state to reflect the current physical status.",
        "operationId": "put_acknowledge_estop_disengage_robot_control_acknowledgeEstopDisengage_put",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_EstopStatusModel_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBody_NotSupportedOnOT2_"
                }
              }
            },
            "description": "Forbidden"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/robot/door/status": {
      "get": {
        "tags": [
          "Robot"
        ],
        "summary": "Get the status of the robot door.",
        "description": "Get whether the robot door is open or closed.",
        "operationId": "get_door_status_robot_door_status_get",
        "parameters": [
          {
            "name": "opentrons-version",
            "in": "header",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "enum": [
                    "*"
                  ],
                  "const": "*",
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`.",
              "title": "Opentrons-Version"
            },
            "description": "The HTTP API version to use for this request. Must be `2` or higher. To use the latest version unconditionally, specify `*`."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimpleBody_DoorStatusModel_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AbsorbanceReaderLidStatus": {
        "type": "string",
        "enum": [
          "unknown",
          "on",
          "off"
        ],
        "title": "AbsorbanceReaderLidStatus",
        "description": "Absorbance reader lid status."
      },
      "AbsorbanceReaderModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "absorbanceReaderType"
            ],
            "const": "absorbanceReaderType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "absorbanceReaderV1"
            ],
            "const": "absorbanceReaderV1",
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/AbsorbanceReaderModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "AbsorbanceReaderModule",
        "description": "An attached Absorbance Reader Module."
      },
      "AbsorbanceReaderModuleData": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/AbsorbanceReaderStatus",
            "description": "Overall status of the module."
          },
          "lidStatus": {
            "$ref": "#/components/schemas/AbsorbanceReaderLidStatus",
            "description": "Lid status."
          },
          "platePresence": {
            "$ref": "#/components/schemas/AbsorbanceReaderPlatePresence",
            "description": "Plate presence status."
          },
          "measureMode": {
            "type": "string",
            "title": "Measuremode",
            "description": "The measirement mode (single or multi) the device is configured for."
          },
          "sampleWavelengths": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Samplewavelengths",
            "description": "The current list of sample wavelengths, in nanometers."
          },
          "referenceWavelength": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Referencewavelength",
            "description": "The reference wavelength used for single measurement mode."
          }
        },
        "type": "object",
        "required": [
          "status",
          "lidStatus",
          "platePresence",
          "measureMode",
          "sampleWavelengths",
          "referenceWavelength"
        ],
        "title": "AbsorbanceReaderModuleData",
        "description": "Live data from an Absorbance Reader module."
      },
      "AbsorbanceReaderPlatePresence": {
        "type": "string",
        "enum": [
          "unknown",
          "present",
          "absent"
        ],
        "title": "AbsorbanceReaderPlatePresence",
        "description": "Absorbance reader plate presence."
      },
      "AbsorbanceReaderStatus": {
        "type": "string",
        "enum": [
          "idle",
          "measuring",
          "error"
        ],
        "title": "AbsorbanceReaderStatus"
      },
      "ActiveNozzleLayout": {
        "properties": {
          "startingNozzle": {
            "type": "string",
            "title": "Startingnozzle",
            "description": "The nozzle used when issuing pipette commands."
          },
          "activeNozzles": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Activenozzles",
            "description": "A map of all the pipette nozzles active in the current configuration."
          },
          "config": {
            "$ref": "#/components/schemas/NozzleLayoutConfig",
            "description": "The active nozzle configuration."
          }
        },
        "type": "object",
        "required": [
          "startingNozzle",
          "activeNozzles",
          "config"
        ],
        "title": "ActiveNozzleLayout",
        "description": "Details about the active nozzle layout for a pipette used in the current run."
      },
      "AddWifiKeyFileResponse": {
        "properties": {
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "A URI for the key (mostly for use with DELETE /wifi/keys/{key_id})"
          },
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A contents hash of the key used to specify the key in POST /wifi/configure (and also to determine the key URI)"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The original filename of the key"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message"
          }
        },
        "type": "object",
        "required": [
          "uri",
          "id",
          "name"
        ],
        "title": "AddWifiKeyFileResponse",
        "description": "Response to add wifi key file"
      },
      "AddressableAreaLocation": {
        "properties": {
          "addressableAreaName": {
            "type": "string",
            "title": "Addressableareaname",
            "description": "The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          }
        },
        "type": "object",
        "required": [
          "addressableAreaName"
        ],
        "title": "AddressableAreaLocation",
        "description": "The location of something place in an addressable area. This is a superset of deck slots."
      },
      "AddressableOffsetVector": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "AddressableOffsetVector",
        "description": "Offset, in deck coordinates, from nominal to actual position of an addressable area."
      },
      "AdvancedSetting": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The machine-readable property ID"
          },
          "old_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Old Id",
            "description": "The ID by which the property used to be known; not useful now and may contain spaces or hyphens",
            "deprecated": true
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A human-readable short string suitable for display as the title of the setting"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A human-readable long string suitable for display as a paragraph or two explaining the setting"
          },
          "restart_required": {
            "type": "boolean",
            "title": "Restart Required",
            "description": "Whether a robot restart is required to make this change take effect"
          },
          "value": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Value",
            "description": "Whether the setting is off by previous user choice (false), true by user choice (true), or off and has never been altered (null)"
          }
        },
        "type": "object",
        "required": [
          "id",
          "old_id",
          "title",
          "description",
          "restart_required",
          "value"
        ],
        "title": "AdvancedSetting",
        "description": "An advanced setting (Feature Flag)"
      },
      "AdvancedSettingRequest": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The ID of the setting to change (something returned by GET /settings)"
          },
          "value": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Value",
            "description": "The new value to set. If null, reset to default"
          }
        },
        "type": "object",
        "required": [
          "id"
        ],
        "title": "AdvancedSettingRequest",
        "description": "Configure the setting to change and the new value"
      },
      "AdvancedSettingsResponse": {
        "properties": {
          "settings": {
            "items": {
              "$ref": "#/components/schemas/AdvancedSetting"
            },
            "type": "array",
            "title": "Settings"
          },
          "links": {
            "$ref": "#/components/schemas/Links"
          }
        },
        "type": "object",
        "required": [
          "settings",
          "links"
        ],
        "title": "AdvancedSettingsResponse",
        "description": "A dump of advanced settings and suitable links for next action"
      },
      "AirGapInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "airGapInPlace"
            ],
            "const": "airGapInPlace",
            "title": "Commandtype",
            "default": "airGapInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/AirGapInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AirGapInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "AirGapInPlace",
        "description": "AirGapInPlace command model."
      },
      "AirGapInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "airGapInPlace"
            ],
            "const": "airGapInPlace",
            "title": "Commandtype",
            "default": "airGapInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/AirGapInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "AirGapInPlaceCreate",
        "description": "AirGapInPlace command request model."
      },
      "AirGapInPlaceParams": {
        "properties": {
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to aspirate, in L. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "AirGapInPlaceParams",
        "description": "Payload required to air gap in place."
      },
      "AirGapInPlaceResult": {
        "properties": {
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "AirGapInPlaceResult",
        "description": "Result data from the execution of a AirGapInPlace command."
      },
      "AllNozzleLayoutConfiguration": {
        "properties": {
          "style": {
            "type": "string",
            "enum": [
              "ALL"
            ],
            "const": "ALL",
            "title": "Style",
            "default": "ALL"
          }
        },
        "type": "object",
        "title": "AllNozzleLayoutConfiguration",
        "description": "All basemodel to represent a reset to the nozzle configuration. Sending no parameters resets to default."
      },
      "AllRunsLinks": {
        "properties": {
          "current": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ResourceLink"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to the currently active run, if a run is active."
          }
        },
        "type": "object",
        "title": "AllRunsLinks",
        "description": "Links returned along with a collection of runs."
      },
      "AnalysisNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "AnalysisNotFound"
            ],
            "const": "AnalysisNotFound",
            "title": "Id",
            "default": "AnalysisNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol Analysis Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "AnalysisNotFound",
        "description": "An error returned when a given protocol analysis cannot be found."
      },
      "AnalysisRequest": {
        "properties": {
          "runTimeParameterValues": {
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                }
              ]
            },
            "type": "object",
            "title": "Runtimeparametervalues",
            "description": "Key-value pairs of primitive run-time parameters defined in a protocol.",
            "default": {}
          },
          "runTimeParameterFiles": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Runtimeparameterfiles",
            "description": "Key-fileId pairs of CSV run-time parameters defined in a protocol.",
            "default": {}
          },
          "forceReAnalyze": {
            "type": "boolean",
            "title": "Forcereanalyze",
            "description": "Whether to force start a new analysis.",
            "default": false
          }
        },
        "type": "object",
        "title": "AnalysisRequest",
        "description": "Model for analysis request body."
      },
      "AnalysisResult": {
        "type": "string",
        "enum": [
          "ok",
          "not-ok",
          "parameter-value-required"
        ],
        "title": "AnalysisResult",
        "description": "Result of a completed protocol analysis.\n\nThe result indicates whether the protocol is expected to run successfully.\n\nProperties:\n    OK: No problems were found during protocol analysis.\n    NOT_OK: Problems were found during protocol analysis. Inspect\n        `analysis.errors` for error occurrences.\n    PARAMETER_VALUE_REQUIRED: A value is required to be set for a parameter\n        in order for the protocol to be analyzed/run. The absence of this does not\n        inherently mean there are no parameters, as there may be defaults for all\n        or unset parameters are not referenced or handled via try/except clauses."
      },
      "AnalysisStatus": {
        "type": "string",
        "enum": [
          "pending",
          "completed"
        ],
        "title": "AnalysisStatus",
        "description": "Status of a protocol analysis."
      },
      "AnalysisSummary": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this analysis resource"
          },
          "status": {
            "$ref": "#/components/schemas/AnalysisStatus",
            "description": "Status of the analysis"
          },
          "runTimeParameters": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/NumberParameter"
                    },
                    {
                      "$ref": "#/components/schemas/EnumParameter"
                    },
                    {
                      "$ref": "#/components/schemas/BooleanParameter"
                    },
                    {
                      "$ref": "#/components/schemas/CSVParameter"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Runtimeparameters",
            "description": "Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request."
          }
        },
        "type": "object",
        "required": [
          "id",
          "status"
        ],
        "title": "AnalysisSummary",
        "description": "Base model for an analysis of a protocol."
      },
      "Aspirate": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "aspirate"
            ],
            "const": "aspirate",
            "title": "Commandtype",
            "default": "aspirate"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AspirateResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Aspirate",
        "description": "Aspirate command model."
      },
      "AspirateCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "aspirate"
            ],
            "const": "aspirate",
            "title": "Commandtype",
            "default": "aspirate"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "AspirateCreate",
        "description": "Create aspirate command request model."
      },
      "AspirateInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "aspirateInPlace"
            ],
            "const": "aspirateInPlace",
            "title": "Commandtype",
            "default": "aspirateInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AspirateInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "AspirateInPlace",
        "description": "AspirateInPlace command model."
      },
      "AspirateInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "aspirateInPlace"
            ],
            "const": "aspirateInPlace",
            "title": "Commandtype",
            "default": "aspirateInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "AspirateInPlaceCreate",
        "description": "AspirateInPlace command request model."
      },
      "AspirateInPlaceParams": {
        "properties": {
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to aspirate, in L. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "AspirateInPlaceParams",
        "description": "Payload required to aspirate in place."
      },
      "AspirateInPlaceResult": {
        "properties": {
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "AspirateInPlaceResult",
        "description": "Result data from the execution of a AspirateInPlace command."
      },
      "AspirateParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/LiquidHandlingWellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to aspirate, in L. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "AspirateParams",
        "description": "Parameters required to aspirate from a specific well."
      },
      "AspirateProperties": {
        "properties": {
          "submerge": {
            "$ref": "#/components/schemas/Submerge",
            "description": "Submerge settings for aspirate."
          },
          "retract": {
            "$ref": "#/components/schemas/RetractAspirate",
            "description": "Pipette retract settings after an aspirate."
          },
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for aspiration."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for aspiration."
          },
          "flowRateByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Flowratebyvolume",
            "description": "Settings for flow rate keyed by target aspiration volume."
          },
          "correctionByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Correctionbyvolume",
            "description": "Settings for volume correction keyed by by target aspiration volume, representing additional volume the plunger should move to accurately hit target volume."
          },
          "preWet": {
            "type": "boolean",
            "title": "Prewet",
            "description": "Whether to perform a pre-wet action."
          },
          "mix": {
            "$ref": "#/components/schemas/MixProperties",
            "description": "Mixing settings for before an aspirate"
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay settings after an aspirate"
          }
        },
        "type": "object",
        "required": [
          "submerge",
          "retract",
          "positionReference",
          "offset",
          "flowRateByVolume",
          "correctionByVolume",
          "preWet",
          "mix",
          "delay"
        ],
        "title": "AspirateProperties",
        "description": "Properties specific to the aspirate function."
      },
      "AspirateResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "AspirateResult",
        "description": "Result data from execution of an Aspirate command."
      },
      "AspirateWhileTracking": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "aspirateWhileTracking"
            ],
            "const": "aspirateWhileTracking",
            "title": "Commandtype",
            "default": "aspirateWhileTracking"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateWhileTrackingParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AspirateWhileTrackingResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "AspirateWhileTracking",
        "description": "AspirateWhileTracking command model."
      },
      "AspirateWhileTrackingCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "aspirateWhileTracking"
            ],
            "const": "aspirateWhileTracking",
            "title": "Commandtype",
            "default": "aspirateWhileTracking"
          },
          "params": {
            "$ref": "#/components/schemas/AspirateWhileTrackingParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "AspirateWhileTrackingCreate",
        "description": "Create aspirateWhileTracking command request model."
      },
      "AspirateWhileTrackingParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/LiquidHandlingWellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to aspirate, in L. Must not be greater than the remaining available amount, which depends on the pipette (see `loadPipette`), its configuration (see `configureForVolume`), the tip (see `pickUpTip`), and the amount you've aspirated so far. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "AspirateWhileTrackingParams",
        "description": "Parameters required to aspirate from a specific well."
      },
      "AspirateWhileTrackingResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "AspirateWhileTrackingResult",
        "description": "Result data from execution of an Aspirate command."
      },
      "AttachTip": {
        "properties": {
          "target": {
            "$ref": "#/components/schemas/MotionTarget"
          },
          "point": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Point",
            "description": "A point in deck coordinates (x, y, z)"
          }
        },
        "type": "object",
        "required": [
          "target",
          "point"
        ],
        "title": "AttachTip"
      },
      "Axes": {
        "properties": {
          "axes": {
            "items": {
              "$ref": "#/components/schemas/MotorName"
            },
            "type": "array",
            "title": "Axes"
          }
        },
        "type": "object",
        "required": [
          "axes"
        ],
        "title": "Axes",
        "description": "A list of motor axes to disengage"
      },
      "BadGripper": {
        "properties": {
          "subsystem": {
            "$ref": "#/components/schemas/SubSystem",
            "description": "The hardware subsystem for this instrument"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "A route on this server to more information about the status of the hardware"
          },
          "update": {
            "type": "string",
            "title": "Update",
            "description": "A route on this server to begin an update of the instrument"
          },
          "ok": {
            "type": "boolean",
            "enum": [
              false
            ],
            "const": false,
            "title": "Ok",
            "description": "If the instrument is not OK, a previous update was interrupted. It must be updated again."
          },
          "instrumentType": {
            "type": "string",
            "enum": [
              "gripper"
            ],
            "const": "gripper",
            "title": "Instrumenttype",
            "default": "gripper"
          }
        },
        "type": "object",
        "required": [
          "subsystem",
          "status",
          "update",
          "ok"
        ],
        "title": "BadGripper",
        "description": "Represents a gripper that is physically connected but not ready to operate."
      },
      "BadPipette": {
        "properties": {
          "subsystem": {
            "$ref": "#/components/schemas/SubSystem",
            "description": "The hardware subsystem for this instrument"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "A route on this server to more information about the status of the hardware"
          },
          "update": {
            "type": "string",
            "title": "Update",
            "description": "A route on this server to begin an update of the instrument"
          },
          "ok": {
            "type": "boolean",
            "enum": [
              false
            ],
            "const": false,
            "title": "Ok",
            "description": "If the instrument is not OK, a previous update was interrupted. It must be updated again."
          },
          "instrumentType": {
            "type": "string",
            "enum": [
              "pipette"
            ],
            "const": "pipette",
            "title": "Instrumenttype",
            "default": "pipette"
          }
        },
        "type": "object",
        "required": [
          "subsystem",
          "status",
          "update",
          "ok"
        ],
        "title": "BadPipette",
        "description": "Represents a pipette that is physically connected but not ready to operate."
      },
      "BadRun": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique run identifier."
          },
          "ok": {
            "type": "boolean",
            "enum": [
              false
            ],
            "const": false,
            "title": "Ok",
            "default": false
          },
          "dataError": {
            "$ref": "#/components/schemas/RunDataError",
            "description": "Error from loading the data."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the run was created"
          },
          "status": {
            "$ref": "#/components/schemas/EngineStatus",
            "description": "Execution status of the run"
          },
          "current": {
            "type": "boolean",
            "title": "Current",
            "description": "Whether this run is currently controlling the robot. There can be, at most, one current run."
          },
          "actions": {
            "items": {
              "$ref": "#/components/schemas/RunAction"
            },
            "type": "array",
            "title": "Actions",
            "description": "Client-initiated run control actions, ordered oldest to newest. If these could not be loaded for this bad run, this will be null."
          },
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Errors",
            "description": "The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element."
          },
          "hasEverEnteredErrorRecovery": {
            "type": "boolean",
            "title": "Haseverenterederrorrecovery",
            "description": "Whether the run has entered error recovery."
          },
          "pipettes": {
            "items": {
              "$ref": "#/components/schemas/LoadedPipette"
            },
            "type": "array",
            "title": "Pipettes",
            "description": "Pipettes that have been loaded into the run."
          },
          "modules": {
            "items": {
              "$ref": "#/components/schemas/LoadedModule"
            },
            "type": "array",
            "title": "Modules",
            "description": "Modules that have been loaded into the run."
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/LoadedLabware"
            },
            "type": "array",
            "title": "Labware",
            "description": "Labware that has been loaded into the run."
          },
          "liquids": {
            "items": {
              "$ref": "#/components/schemas/Liquid"
            },
            "type": "array",
            "title": "Liquids",
            "description": "Liquids loaded to the run."
          },
          "liquidClasses": {
            "items": {
              "$ref": "#/components/schemas/LiquidClassRecordWithId"
            },
            "type": "array",
            "title": "Liquidclasses",
            "description": "Liquid classes loaded to the run."
          },
          "labwareOffsets": {
            "items": {
              "$ref": "#/components/schemas/LabwareOffset"
            },
            "type": "array",
            "title": "Labwareoffsets",
            "description": "Labware offsets to apply as labware are loaded."
          },
          "runTimeParameters": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/NumberParameter"
                },
                {
                  "$ref": "#/components/schemas/EnumParameter"
                },
                {
                  "$ref": "#/components/schemas/BooleanParameter"
                },
                {
                  "$ref": "#/components/schemas/CSVParameter"
                }
              ]
            },
            "type": "array",
            "title": "Runtimeparameters",
            "description": "Run time parameters used during the run. These are the parameters that are defined in the protocol, with values specified either in the run creation request or default values from the protocol if none are specified in the request."
          },
          "outputFileIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Outputfileids",
            "description": "File IDs of files output during a protocol run."
          },
          "protocolId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Protocolid",
            "description": "Protocol resource being run, if any. If not present, the run may still be used to execute protocol commands over HTTP."
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Run completed at timestamp."
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Run started at timestamp."
          }
        },
        "type": "object",
        "required": [
          "id",
          "dataError",
          "createdAt",
          "status",
          "current",
          "actions",
          "errors",
          "hasEverEnteredErrorRecovery",
          "pipettes",
          "modules",
          "labware",
          "liquids",
          "liquidClasses",
          "labwareOffsets",
          "outputFileIds"
        ],
        "title": "BadRun",
        "description": "Resource model representation for a bad run that could not be loaded."
      },
      "BaseModel": {
        "properties": {},
        "type": "object",
        "title": "BaseModel"
      },
      "BlowOut": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "blowout"
            ],
            "const": "blowout",
            "title": "Commandtype",
            "default": "blowout"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/BlowOutParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BlowOutResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "BlowOut",
        "description": "Blow-out command model."
      },
      "BlowOutCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "blowout"
            ],
            "const": "blowout",
            "title": "Commandtype",
            "default": "blowout"
          },
          "params": {
            "$ref": "#/components/schemas/BlowOutParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "BlowOutCreate",
        "description": "Create blow-out command request model."
      },
      "BlowOutInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "blowOutInPlace"
            ],
            "const": "blowOutInPlace",
            "title": "Commandtype",
            "default": "blowOutInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/BlowOutInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BlowOutInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "BlowOutInPlace",
        "description": "BlowOutInPlace command model."
      },
      "BlowOutInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "blowOutInPlace"
            ],
            "const": "blowOutInPlace",
            "title": "Commandtype",
            "default": "blowOutInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/BlowOutInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "BlowOutInPlaceCreate",
        "description": "BlowOutInPlace command request model."
      },
      "BlowOutInPlaceParams": {
        "properties": {
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "flowRate",
          "pipetteId"
        ],
        "title": "BlowOutInPlaceParams",
        "description": "Payload required to blow-out in place."
      },
      "BlowOutInPlaceResult": {
        "properties": {},
        "type": "object",
        "title": "BlowOutInPlaceResult",
        "description": "Result data from the execution of a BlowOutInPlace command."
      },
      "BlowOutParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/WellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "pipetteId"
        ],
        "title": "BlowOutParams",
        "description": "Payload required to blow-out a specific well."
      },
      "BlowOutResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "BlowOutResult",
        "description": "Result data from the execution of a blow-out command."
      },
      "BlowoutLocation": {
        "type": "string",
        "enum": [
          "source",
          "destination",
          "trash"
        ],
        "title": "BlowoutLocation",
        "description": "Location for blowout during a transfer function."
      },
      "BlowoutParams": {
        "properties": {
          "location": {
            "$ref": "#/components/schemas/BlowoutLocation",
            "description": "Location well or trash entity for blow out."
          },
          "flowRate": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Flowrate",
            "description": "Flow rate for blow out, in microliters per second."
          }
        },
        "type": "object",
        "required": [
          "location",
          "flowRate"
        ],
        "title": "BlowoutParams",
        "description": "Parameters for blowout."
      },
      "BlowoutProperties": {
        "properties": {
          "enable": {
            "type": "boolean",
            "title": "Enable",
            "description": "Whether blow-out is enabled."
          },
          "params": {
            "$ref": "#/components/schemas/BlowoutParams",
            "title": "Params",
            "description": "Parameters for the blowout function."
          }
        },
        "type": "object",
        "required": [
          "enable"
        ],
        "title": "BlowoutProperties",
        "description": "Blowout properties."
      },
      "Body_MaintenanceRun_AllRunsLinks_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/MaintenanceRun",
            "description": "The documents primary data"
          },
          "links": {
            "$ref": "#/components/schemas/AllRunsLinks",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data",
          "links"
        ],
        "title": "Body[MaintenanceRun, AllRunsLinks]"
      },
      "Body_Protocol_ProtocolLinks_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/Protocol",
            "description": "The documents primary data"
          },
          "links": {
            "$ref": "#/components/schemas/ProtocolLinks",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data",
          "links"
        ],
        "title": "Body[Protocol, ProtocolLinks]"
      },
      "Body_RunCurrentState_CurrentStateLinks_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunCurrentState",
            "description": "The documents primary data"
          },
          "links": {
            "$ref": "#/components/schemas/CurrentStateLinks",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data",
          "links"
        ],
        "title": "Body[RunCurrentState, CurrentStateLinks]"
      },
      "Body_create_protocol_protocols_post": {
        "properties": {
          "files": {
            "items": {
              "type": "string",
              "format": "binary"
            },
            "type": "array",
            "title": "Files"
          },
          "key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key",
            "description": "An arbitrary client-defined string to attach to the new protocol resource. This should be no longer than ~100 characters or so. It's intended to store something like a UUID, to help clients that store protocols locally keep track of which local files correspond to which protocol resources on the robot."
          },
          "run_time_parameter_values": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Run Time Parameter Values",
            "description": "Key-value pairs of run-time parameters defined in a protocol. Note that this is expected to be a string holding a JSON object. Also, if this data is included in the request, the server will always trigger an analysis (for now)."
          },
          "protocol_kind": {
            "$ref": "#/components/schemas/ProtocolKind",
            "description": "Whether this is a `standard` protocol or a `quick-transfer` protocol.if omitted, the protocol will be `standard` by default.",
            "default": "standard"
          },
          "run_time_parameter_files": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Run Time Parameter Files",
            "description": "Param-file pairs of CSV run-time parameters defined in the protocol."
          }
        },
        "type": "object",
        "required": [
          "files"
        ],
        "title": "Body_create_protocol_protocols_post"
      },
      "Body_post_wifi_key_wifi_keys_post": {
        "properties": {
          "key": {
            "type": "string",
            "format": "binary",
            "title": "Key"
          }
        },
        "type": "object",
        "required": [
          "key"
        ],
        "title": "Body_post_wifi_key_wifi_keys_post"
      },
      "Body_upload_data_file_dataFiles_post": {
        "properties": {
          "file": {
            "anyOf": [
              {
                "type": "string",
                "format": "binary"
              },
              {
                "type": "null"
              }
            ],
            "title": "File",
            "description": "Data file to upload"
          },
          "file_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Path",
            "description": "Absolute path to a file on the robot."
          }
        },
        "type": "object",
        "title": "Body_upload_data_file_dataFiles_post"
      },
      "BooleanParameter": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display string for the parameter."
          },
          "variableName": {
            "type": "string",
            "title": "Variablename",
            "description": "Python variable name of the parameter."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of the parameter."
          },
          "suffix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Suffix",
            "description": "Units (like mL, mm/sec, etc) or a custom suffix for the parameter."
          },
          "type": {
            "type": "string",
            "enum": [
              "bool"
            ],
            "const": "bool",
            "title": "Type",
            "description": "String specifying the type of this parameter",
            "default": "bool"
          },
          "value": {
            "type": "boolean",
            "title": "Value",
            "description": "The value assigned to the parameter; if not supplied by the client, will be assigned the default value."
          },
          "default": {
            "type": "boolean",
            "title": "Default",
            "description": "Default value of the parameter, to be used when there is no client-specified value."
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "variableName",
          "value",
          "default"
        ],
        "title": "BooleanParameter",
        "description": "A boolean parameter defined in a protocol."
      },
      "BrandData": {
        "properties": {
          "brand": {
            "type": "string",
            "title": "Brand"
          },
          "brandId": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Brandid"
          },
          "links": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links"
          }
        },
        "type": "object",
        "required": [
          "brand"
        ],
        "title": "BrandData"
      },
      "CSVParameter": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display string for the parameter."
          },
          "variableName": {
            "type": "string",
            "title": "Variablename",
            "description": "Python variable name of the parameter."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of the parameter."
          },
          "suffix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Suffix",
            "description": "Units (like mL, mm/sec, etc) or a custom suffix for the parameter."
          },
          "type": {
            "type": "string",
            "enum": [
              "csv_file"
            ],
            "const": "csv_file",
            "title": "Type",
            "description": "String specifying the type of this parameter",
            "default": "csv_file"
          },
          "file": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FileInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "ID of the CSV file stored on the robot; to be used for fetching the CSV file. For local analysis this will most likely be empty."
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "variableName"
        ],
        "title": "CSVParameter",
        "description": "A CSV file parameter defined in a protocol."
      },
      "CalibrateGripper": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibrateGripper"
            ],
            "const": "calibration/calibrateGripper",
            "title": "Commandtype",
            "default": "calibration/calibrateGripper"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CalibrateGripperParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CalibrateGripperResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CalibrateGripper",
        "description": "A `calibrateGripper` command."
      },
      "CalibrateGripperCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibrateGripper"
            ],
            "const": "calibration/calibrateGripper",
            "title": "Commandtype",
            "default": "calibration/calibrateGripper"
          },
          "params": {
            "$ref": "#/components/schemas/CalibrateGripperParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CalibrateGripperCreate",
        "description": "A request to create a `calibrateGripper` command."
      },
      "CalibrateGripperParams": {
        "properties": {
          "jaw": {
            "$ref": "#/components/schemas/CalibrateGripperParamsJaw",
            "description": "Which of the gripper's jaws to use to measure its offset. The robot will assume that a human operator has already attached the capacitive probe to the jaw and none is attached to the other jaw."
          },
          "otherJawOffset": {
            "$ref": "#/components/schemas/Vec3f",
            "title": "Otherjawoffset",
            "description": "If an offset for the other probe is already found, then specifying it here will enable the CalibrateGripper command to complete the calibration process by calculating the total offset and saving it to disk. If this param is not specified then the command will only find and return the offset for the specified probe."
          }
        },
        "type": "object",
        "required": [
          "jaw"
        ],
        "title": "CalibrateGripperParams",
        "description": "Parameters for a `calibrateGripper` command."
      },
      "CalibrateGripperParamsJaw": {
        "type": "string",
        "enum": [
          "front",
          "rear"
        ],
        "title": "CalibrateGripperParamsJaw"
      },
      "CalibrateGripperResult": {
        "properties": {
          "jawOffset": {
            "$ref": "#/components/schemas/Vec3f",
            "description": "The offset from the probe's nominal position to its actual measured position."
          },
          "savedCalibration": {
            "$ref": "#/components/schemas/GripperCalibrationOffset",
            "title": "Savedcalibration",
            "description": "Gripper calibration result data, when `otherJawOffset` is provided."
          }
        },
        "type": "object",
        "required": [
          "jawOffset"
        ],
        "title": "CalibrateGripperResult",
        "description": "The result of a successful `calibrateGripper` command."
      },
      "CalibrateModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibrateModule"
            ],
            "const": "calibration/calibrateModule",
            "title": "Commandtype",
            "default": "calibration/calibrateModule"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CalibrateModuleParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CalibrateModuleResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CalibrateModule",
        "description": "Calibrate-module command model."
      },
      "CalibrateModuleCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibrateModule"
            ],
            "const": "calibration/calibrateModule",
            "title": "Commandtype",
            "default": "calibration/calibrateModule"
          },
          "params": {
            "$ref": "#/components/schemas/CalibrateModuleParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CalibrateModuleCreate",
        "description": "Create calibrate-module command request model."
      },
      "CalibrateModuleParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "The unique id of module to calibrate."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The unique id of module calibration adapter labware."
          },
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "description": "The instrument mount used to calibrate the module."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "labwareId",
          "mount"
        ],
        "title": "CalibrateModuleParams",
        "description": "Payload required to calibrate-module."
      },
      "CalibrateModuleResult": {
        "properties": {
          "moduleOffset": {
            "$ref": "#/components/schemas/ModuleOffsetVector",
            "description": "Offset of calibrated module."
          },
          "location": {
            "$ref": "#/components/schemas/DeckSlotLocation",
            "description": "The deck slot this module was calibrated in."
          }
        },
        "type": "object",
        "required": [
          "moduleOffset",
          "location"
        ],
        "title": "CalibrateModuleResult",
        "description": "Result data from the execution of a calibrate-module command."
      },
      "CalibratePipette": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibratePipette"
            ],
            "const": "calibration/calibratePipette",
            "title": "Commandtype",
            "default": "calibration/calibratePipette"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CalibratePipetteParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CalibratePipetteResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CalibratePipette",
        "description": "Calibrate-pipette command model."
      },
      "CalibratePipetteCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/calibratePipette"
            ],
            "const": "calibration/calibratePipette",
            "title": "Commandtype",
            "default": "calibration/calibratePipette"
          },
          "params": {
            "$ref": "#/components/schemas/CalibratePipetteParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CalibratePipetteCreate",
        "description": "Create calibrate-pipette command request model."
      },
      "CalibratePipetteParams": {
        "properties": {
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "description": "Instrument mount to calibrate."
          }
        },
        "type": "object",
        "required": [
          "mount"
        ],
        "title": "CalibratePipetteParams",
        "description": "Payload required to calibrate-pipette."
      },
      "CalibratePipetteResult": {
        "properties": {
          "pipetteOffset": {
            "$ref": "#/components/schemas/InstrumentOffsetVector",
            "description": "Offset of calibrated pipette."
          }
        },
        "type": "object",
        "required": [
          "pipetteOffset"
        ],
        "title": "CalibratePipetteResult",
        "description": "Result data from the execution of a calibrate-pipette command."
      },
      "CalibrationCheckCreateAttributes": {
        "properties": {
          "sessionType": {
            "type": "string",
            "enum": [
              "calibrationCheck"
            ],
            "const": "calibrationCheck",
            "title": "Sessiontype",
            "default": "calibrationCheck"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__check__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "createParams"
        ],
        "title": "CalibrationCheckCreateAttributes",
        "description": "The calibration check create request."
      },
      "CalibrationCheckResponseAttributes": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Date and time that this session was created"
          },
          "details": {
            "$ref": "#/components/schemas/CalibrationCheckSessionStatus"
          },
          "sessionType": {
            "type": "string",
            "enum": [
              "calibrationCheck"
            ],
            "const": "calibrationCheck",
            "title": "Sessiontype",
            "default": "calibrationCheck"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__check__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "details",
          "createParams"
        ],
        "title": "CalibrationCheckResponseAttributes",
        "description": "Response attributes of cal check session."
      },
      "CalibrationCheckSessionStatus": {
        "properties": {
          "instruments": {
            "items": {
              "$ref": "#/components/schemas/CheckAttachedPipette"
            },
            "type": "array",
            "title": "Instruments"
          },
          "activePipette": {
            "$ref": "#/components/schemas/CheckAttachedPipette"
          },
          "currentStep": {
            "type": "string",
            "title": "Currentstep",
            "description": "Current step of session"
          },
          "comparisonsByPipette": {
            "$ref": "#/components/schemas/ComparisonStatePerPipette"
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/RequiredLabware"
            },
            "type": "array",
            "title": "Labware"
          },
          "activeTipRack": {
            "$ref": "#/components/schemas/RequiredLabware"
          },
          "supportedCommands": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supportedcommands",
            "description": "A list of supported commands for this user flow"
          }
        },
        "type": "object",
        "required": [
          "instruments",
          "activePipette",
          "currentStep",
          "comparisonsByPipette",
          "labware",
          "activeTipRack",
          "supportedCommands"
        ],
        "title": "CalibrationCheckSessionStatus",
        "description": "The current status of a given session.",
        "examples": [
          {
            "comparisonsByPipette": {
              "comparingFirstPipetteHeight": {
                "differenceVector": [
                  1,
                  0,
                  0
                ],
                "exceedsThreshold": false
              }
            },
            "currentStep": "sessionStarted",
            "instruments": [
              {
                "id": "P3HS12123041",
                "model": "p300_single_v1.5",
                "mount": "left",
                "name": "p300_single",
                "tip_length": 51.7
              },
              {
                "mount": "right"
              }
            ]
          }
        ]
      },
      "CalibrationData": {
        "properties": {
          "offset": {
            "$ref": "#/components/schemas/OffsetData",
            "description": "An array of XYZ offset data."
          },
          "tipLength": {
            "$ref": "#/components/schemas/TipData",
            "description": "The tip length of a labware, if relevant."
          }
        },
        "type": "object",
        "required": [
          "offset",
          "tipLength"
        ],
        "title": "CalibrationData",
        "description": "A model for labware calibration data"
      },
      "ChangePipette": {
        "properties": {
          "target": {
            "$ref": "#/components/schemas/MotionTarget"
          },
          "left": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Left",
            "description": "A point in deck coordinates (x, y, z)"
          },
          "right": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Right",
            "description": "A point in deck coordinates (x, y, z)"
          }
        },
        "type": "object",
        "required": [
          "target",
          "left",
          "right"
        ],
        "title": "ChangePipette"
      },
      "CheckAttachedPipette": {
        "properties": {
          "model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model",
            "description": "The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Short name of pipette model withoutgeneration version"
          },
          "tipLength": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiplength",
            "description": "The default tip length for this pipette"
          },
          "mount": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mount",
            "description": "The mount this pipette attached to"
          },
          "serial": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Serial",
            "description": "The serial number of the attached pipette"
          },
          "defaultTipracks": {
            "anyOf": [
              {
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Defaulttipracks",
            "description": "A list of default tipracks for this pipette"
          },
          "rank": {
            "type": "string",
            "enum": [
              "first",
              "second"
            ],
            "title": "Rank",
            "description": "The order of a given pipette"
          },
          "tipRackLoadName": {
            "type": "string",
            "title": "Tiprackloadname",
            "description": "The load name of the tiprack"
          },
          "tipRackDisplay": {
            "type": "string",
            "title": "Tiprackdisplay",
            "description": "The display name of the tiprack"
          },
          "tipRackUri": {
            "type": "string",
            "title": "Tiprackuri",
            "description": "The uri of the tiprack"
          }
        },
        "type": "object",
        "required": [
          "rank",
          "tipRackLoadName",
          "tipRackDisplay",
          "tipRackUri"
        ],
        "title": "CheckAttachedPipette"
      },
      "CircularWellDefinition2": {
        "properties": {
          "depth": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Depth"
          },
          "totalLiquidVolume": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Totalliquidvolume"
          },
          "x": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Z"
          },
          "geometryDefinitionId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Geometrydefinitionid"
          },
          "shape": {
            "type": "string",
            "enum": [
              "circular"
            ],
            "const": "circular",
            "title": "Shape"
          },
          "diameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Diameter"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "depth",
          "totalLiquidVolume",
          "x",
          "y",
          "z",
          "shape",
          "diameter"
        ],
        "title": "CircularWellDefinition2"
      },
      "CircularWellDefinition3": {
        "properties": {
          "depth": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Depth"
          },
          "totalLiquidVolume": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Totalliquidvolume"
          },
          "x": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Z"
          },
          "geometryDefinitionId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Geometrydefinitionid"
          },
          "shape": {
            "type": "string",
            "enum": [
              "circular"
            ],
            "const": "circular",
            "title": "Shape"
          },
          "diameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Diameter"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "depth",
          "totalLiquidVolume",
          "x",
          "y",
          "z",
          "shape",
          "diameter"
        ],
        "title": "CircularWellDefinition3"
      },
      "ClientDataKeyDoesNotExist": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ClientDataKeyDoesNotExist"
            ],
            "const": "ClientDataKeyDoesNotExist",
            "title": "Id",
            "default": "ClientDataKeyDoesNotExist"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Client Data Key Does Not Exist"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ClientDataKeyDoesNotExist",
        "description": "An error returned if trying to access a client data key that doesn't exist."
      },
      "CloseLabwareLatch": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/closeLabwareLatch"
            ],
            "const": "heaterShaker/closeLabwareLatch",
            "title": "Commandtype",
            "default": "heaterShaker/closeLabwareLatch"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CloseLabwareLatchParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CloseLabwareLatchResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CloseLabwareLatch",
        "description": "A command to close a Heater-Shaker's latch."
      },
      "CloseLabwareLatchCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/closeLabwareLatch"
            ],
            "const": "heaterShaker/closeLabwareLatch",
            "title": "Commandtype",
            "default": "heaterShaker/closeLabwareLatch"
          },
          "params": {
            "$ref": "#/components/schemas/CloseLabwareLatchParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CloseLabwareLatchCreate",
        "description": "A request to create a Heater-Shaker's close latch command."
      },
      "CloseLabwareLatchParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "CloseLabwareLatchParams",
        "description": "Input parameters to close a Heater-Shaker Module's labware latch."
      },
      "CloseLabwareLatchResult": {
        "properties": {},
        "type": "object",
        "title": "CloseLabwareLatchResult",
        "description": "Result data from closing a Heater-Shaker's labware latch."
      },
      "ColumnNozzleLayoutConfiguration": {
        "properties": {
          "style": {
            "type": "string",
            "enum": [
              "COLUMN"
            ],
            "const": "COLUMN",
            "title": "Style",
            "default": "COLUMN"
          },
          "primaryNozzle": {
            "type": "string",
            "enum": [
              "A1",
              "H1",
              "A12",
              "H12"
            ],
            "title": "Primarynozzle",
            "description": "The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle."
          }
        },
        "type": "object",
        "required": [
          "primaryNozzle"
        ],
        "title": "ColumnNozzleLayoutConfiguration",
        "description": "Information required for nozzle configurations of type ROW and COLUMN."
      },
      "CommandCollectionLinks": {
        "properties": {
          "current": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandLink"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about the \"current\" command. The \"current\" command is the one that's running right now, or, if there is none, the one that was running most recently."
          },
          "currentlyRecoveringFrom": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandLink"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about the command currently undergoing error recovery. This is basically the most recent protocol command to have failed, except that once you complete error recovery (see `GET /runs/{id}/actions`), this goes back to being `null` or omitted."
          }
        },
        "type": "object",
        "title": "CommandCollectionLinks",
        "description": "Links returned along with a collection of commands."
      },
      "CommandIntent": {
        "type": "string",
        "enum": [
          "protocol",
          "setup",
          "fixit"
        ],
        "title": "CommandIntent",
        "description": "Run intent for a given command.\n\nProps:\n    PROTOCOL: the command is part of the protocol run itself.\n    SETUP: the command is part of the setup phase of a run."
      },
      "CommandLink": {
        "properties": {
          "href": {
            "type": "string",
            "title": "Href",
            "description": "The HTTP API path to the command"
          },
          "meta": {
            "$ref": "#/components/schemas/CommandLinkMeta",
            "description": "Information about the command."
          }
        },
        "type": "object",
        "required": [
          "href",
          "meta"
        ],
        "title": "CommandLink",
        "description": "A link to a command resource."
      },
      "CommandLinkMeta": {
        "properties": {
          "runId": {
            "type": "string",
            "title": "Runid",
            "description": "The ID of the command's run."
          },
          "commandId": {
            "type": "string",
            "title": "Commandid",
            "description": "The ID of the command."
          },
          "index": {
            "type": "integer",
            "title": "Index",
            "description": "The index of the command in the run's overall command list."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "The value of the command's `key` field."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the command was created."
          }
        },
        "type": "object",
        "required": [
          "runId",
          "commandId",
          "index",
          "key",
          "createdAt"
        ],
        "title": "CommandLinkMeta",
        "description": "Metadata about a command resource referenced in `links`."
      },
      "CommandLinkNoMeta": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The ID of the command."
          },
          "href": {
            "type": "string",
            "title": "Href",
            "description": "The HTTP API path to the command."
          }
        },
        "type": "object",
        "required": [
          "id",
          "href"
        ],
        "title": "CommandLinkNoMeta",
        "description": "A link to a command resource without a meta field."
      },
      "CommandMatcher": {
        "properties": {
          "commandType": {
            "type": "string",
            "title": "Commandtype",
            "description": "The command type that this rule applies to."
          },
          "error": {
            "$ref": "#/components/schemas/ErrorMatcher",
            "description": "The error details that this rule applies to."
          }
        },
        "type": "object",
        "required": [
          "commandType",
          "error"
        ],
        "title": "CommandMatcher",
        "description": "Command/error data used for matching rules."
      },
      "CommandNote": {
        "properties": {
          "noteKind": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "warning",
                  "information"
                ]
              },
              {
                "type": "string"
              }
            ],
            "title": "Notekind",
            "description": "The kind of note this is. Only the literal possibilities should be relied upon programmatically."
          },
          "shortMessage": {
            "type": "string",
            "title": "Shortmessage",
            "description": "The accompanying human-readable short message (suitable for display in a single line)"
          },
          "longMessage": {
            "type": "string",
            "title": "Longmessage",
            "description": "A longer message that may contain newlines and formatting characters describing the note."
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "An identifier for the party that created the note"
          }
        },
        "type": "object",
        "required": [
          "noteKind",
          "shortMessage",
          "longMessage",
          "source"
        ],
        "title": "CommandNote",
        "description": "A note about a command's execution or dispatch."
      },
      "Comment": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "comment"
            ],
            "const": "comment",
            "title": "Commandtype",
            "default": "comment"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CommentParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommentResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Comment",
        "description": "Comment command model."
      },
      "CommentCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "comment"
            ],
            "const": "comment",
            "title": "Commandtype",
            "default": "comment"
          },
          "params": {
            "$ref": "#/components/schemas/CommentParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CommentCreate",
        "description": "Comment command request model."
      },
      "CommentParams": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A user-facing message"
          }
        },
        "type": "object",
        "required": [
          "message"
        ],
        "title": "CommentParams",
        "description": "Payload required to annotate execution with a comment."
      },
      "CommentResult": {
        "properties": {},
        "type": "object",
        "title": "CommentResult",
        "description": "Result data from the execution of a Comment command."
      },
      "ComparisonStatePerCalibration": {
        "properties": {
          "tipLength": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TipComparisonMap"
              },
              {
                "type": "null"
              }
            ]
          },
          "pipetteOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipetteOffsetComparisonMap"
              },
              {
                "type": "null"
              }
            ]
          },
          "deck": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckComparisonMap"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "ComparisonStatePerCalibration"
      },
      "ComparisonStatePerPipette": {
        "properties": {
          "first": {
            "$ref": "#/components/schemas/ComparisonStatePerCalibration"
          },
          "second": {
            "$ref": "#/components/schemas/ComparisonStatePerCalibration"
          }
        },
        "type": "object",
        "required": [
          "first",
          "second"
        ],
        "title": "ComparisonStatePerPipette"
      },
      "ComparisonStatus": {
        "properties": {
          "differenceVector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Differencevector",
            "description": "An offset vector in deck coordinates (x, y, z)"
          },
          "thresholdVector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Thresholdvector",
            "description": "An offset vector in deck coordinates (x, y, z)"
          },
          "exceedsThreshold": {
            "type": "boolean",
            "title": "Exceedsthreshold"
          }
        },
        "type": "object",
        "required": [
          "differenceVector",
          "thresholdVector",
          "exceedsThreshold"
        ],
        "title": "ComparisonStatus",
        "description": "A model describing the comparison of a checked point to calibrated value"
      },
      "CompletedAnalysis": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this analysis resource"
          },
          "status": {
            "type": "string",
            "enum": [
              "completed"
            ],
            "const": "completed",
            "title": "Status",
            "description": "Status marking the analysis as completed"
          },
          "result": {
            "$ref": "#/components/schemas/AnalysisResult",
            "description": "Whether the protocol is expected to run successfully"
          },
          "robotType": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "OT-2 Standard",
                  "OT-3 Standard"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Robottype",
            "description": "The type of robot that this protocol can run on. This field was added in v7.1.0. It will be `null` or omitted in analyses that were originally created on older versions."
          },
          "runTimeParameters": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/NumberParameter"
                },
                {
                  "$ref": "#/components/schemas/EnumParameter"
                },
                {
                  "$ref": "#/components/schemas/BooleanParameter"
                },
                {
                  "$ref": "#/components/schemas/CSVParameter"
                }
              ]
            },
            "type": "array",
            "title": "Runtimeparameters",
            "description": "Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request."
          },
          "commands": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AirGapInPlace"
                },
                {
                  "$ref": "#/components/schemas/Aspirate"
                },
                {
                  "$ref": "#/components/schemas/AspirateInPlace"
                },
                {
                  "$ref": "#/components/schemas/AspirateWhileTracking"
                },
                {
                  "$ref": "#/components/schemas/Comment"
                },
                {
                  "$ref": "#/components/schemas/Custom"
                },
                {
                  "$ref": "#/components/schemas/Dispense"
                },
                {
                  "$ref": "#/components/schemas/DispenseInPlace"
                },
                {
                  "$ref": "#/components/schemas/DispenseWhileTracking"
                },
                {
                  "$ref": "#/components/schemas/BlowOut"
                },
                {
                  "$ref": "#/components/schemas/BlowOutInPlace"
                },
                {
                  "$ref": "#/components/schemas/ConfigureForVolume"
                },
                {
                  "$ref": "#/components/schemas/ConfigureNozzleLayout"
                },
                {
                  "$ref": "#/components/schemas/DropTip"
                },
                {
                  "$ref": "#/components/schemas/DropTipInPlace"
                },
                {
                  "$ref": "#/components/schemas/Home"
                },
                {
                  "$ref": "#/components/schemas/RetractAxis"
                },
                {
                  "$ref": "#/components/schemas/LoadLabware"
                },
                {
                  "$ref": "#/components/schemas/ReloadLabware"
                },
                {
                  "$ref": "#/components/schemas/LoadLiquid"
                },
                {
                  "$ref": "#/components/schemas/LoadLiquidClass"
                },
                {
                  "$ref": "#/components/schemas/LoadModule"
                },
                {
                  "$ref": "#/components/schemas/LoadPipette"
                },
                {
                  "$ref": "#/components/schemas/LoadLidStack"
                },
                {
                  "$ref": "#/components/schemas/LoadLid"
                },
                {
                  "$ref": "#/components/schemas/MoveLabware"
                },
                {
                  "$ref": "#/components/schemas/MoveRelative"
                },
                {
                  "$ref": "#/components/schemas/MoveToCoordinates"
                },
                {
                  "$ref": "#/components/schemas/MoveToWell"
                },
                {
                  "$ref": "#/components/schemas/MoveToAddressableArea"
                },
                {
                  "$ref": "#/components/schemas/MoveToAddressableAreaForDropTip"
                },
                {
                  "$ref": "#/components/schemas/PrepareToAspirate"
                },
                {
                  "$ref": "#/components/schemas/WaitForResume"
                },
                {
                  "$ref": "#/components/schemas/WaitForDuration"
                },
                {
                  "$ref": "#/components/schemas/PickUpTip"
                },
                {
                  "$ref": "#/components/schemas/SavePosition"
                },
                {
                  "$ref": "#/components/schemas/SetRailLights"
                },
                {
                  "$ref": "#/components/schemas/TouchTip"
                },
                {
                  "$ref": "#/components/schemas/SetStatusBar"
                },
                {
                  "$ref": "#/components/schemas/VerifyTipPresence"
                },
                {
                  "$ref": "#/components/schemas/GetTipPresence"
                },
                {
                  "$ref": "#/components/schemas/GetNextTip"
                },
                {
                  "$ref": "#/components/schemas/LiquidProbe"
                },
                {
                  "$ref": "#/components/schemas/TryLiquidProbe"
                },
                {
                  "$ref": "#/components/schemas/EvotipSealPipette"
                },
                {
                  "$ref": "#/components/schemas/EvotipDispense"
                },
                {
                  "$ref": "#/components/schemas/EvotipUnsealPipette"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperature"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature"
                },
                {
                  "$ref": "#/components/schemas/DeactivateHeater"
                },
                {
                  "$ref": "#/components/schemas/SetAndWaitForShakeSpeed"
                },
                {
                  "$ref": "#/components/schemas/DeactivateShaker"
                },
                {
                  "$ref": "#/components/schemas/OpenLabwareLatch"
                },
                {
                  "$ref": "#/components/schemas/CloseLabwareLatch"
                },
                {
                  "$ref": "#/components/schemas/Disengage"
                },
                {
                  "$ref": "#/components/schemas/Engage"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperature"
                },
                {
                  "$ref": "#/components/schemas/DeactivateTemperature"
                },
                {
                  "$ref": "#/components/schemas/SetTargetBlockTemperature"
                },
                {
                  "$ref": "#/components/schemas/WaitForBlockTemperature"
                },
                {
                  "$ref": "#/components/schemas/SetTargetLidTemperature"
                },
                {
                  "$ref": "#/components/schemas/WaitForLidTemperature"
                },
                {
                  "$ref": "#/components/schemas/DeactivateBlock"
                },
                {
                  "$ref": "#/components/schemas/DeactivateLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid"
                },
                {
                  "$ref": "#/components/schemas/RunProfile"
                },
                {
                  "$ref": "#/components/schemas/RunExtendedProfile"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLid"
                },
                {
                  "$ref": "#/components/schemas/Initialize"
                },
                {
                  "$ref": "#/components/schemas/ReadAbsorbance"
                },
                {
                  "$ref": "#/components/schemas/Retrieve"
                },
                {
                  "$ref": "#/components/schemas/Store"
                },
                {
                  "$ref": "#/components/schemas/SetStoredLabware"
                },
                {
                  "$ref": "#/components/schemas/Fill"
                },
                {
                  "$ref": "#/components/schemas/Empty"
                },
                {
                  "$ref": "#/components/schemas/CalibrateGripper"
                },
                {
                  "$ref": "#/components/schemas/CalibratePipette"
                },
                {
                  "$ref": "#/components/schemas/CalibrateModule"
                },
                {
                  "$ref": "#/components/schemas/MoveToMaintenancePosition"
                },
                {
                  "$ref": "#/components/schemas/UnsafeBlowOutInPlace"
                },
                {
                  "$ref": "#/components/schemas/UnsafeDropTipInPlace"
                },
                {
                  "$ref": "#/components/schemas/UpdatePositionEstimators"
                },
                {
                  "$ref": "#/components/schemas/UnsafeEngageAxes"
                },
                {
                  "$ref": "#/components/schemas/UnsafeUngripLabware"
                },
                {
                  "$ref": "#/components/schemas/UnsafePlaceLabware"
                },
                {
                  "$ref": "#/components/schemas/MoveTo"
                },
                {
                  "$ref": "#/components/schemas/MoveAxesRelative"
                },
                {
                  "$ref": "#/components/schemas/MoveAxesTo"
                },
                {
                  "$ref": "#/components/schemas/openGripperJaw"
                },
                {
                  "$ref": "#/components/schemas/closeGripperJaw"
                }
              ],
              "discriminator": {
                "propertyName": "commandType",
                "mapping": {
                  "absorbanceReader/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLid",
                  "absorbanceReader/initialize": "#/components/schemas/Initialize",
                  "absorbanceReader/openLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLid",
                  "absorbanceReader/read": "#/components/schemas/ReadAbsorbance",
                  "airGapInPlace": "#/components/schemas/AirGapInPlace",
                  "aspirate": "#/components/schemas/Aspirate",
                  "aspirateInPlace": "#/components/schemas/AspirateInPlace",
                  "aspirateWhileTracking": "#/components/schemas/AspirateWhileTracking",
                  "blowOutInPlace": "#/components/schemas/BlowOutInPlace",
                  "blowout": "#/components/schemas/BlowOut",
                  "calibration/calibrateGripper": "#/components/schemas/CalibrateGripper",
                  "calibration/calibrateModule": "#/components/schemas/CalibrateModule",
                  "calibration/calibratePipette": "#/components/schemas/CalibratePipette",
                  "calibration/moveToMaintenancePosition": "#/components/schemas/MoveToMaintenancePosition",
                  "comment": "#/components/schemas/Comment",
                  "configureForVolume": "#/components/schemas/ConfigureForVolume",
                  "configureNozzleLayout": "#/components/schemas/ConfigureNozzleLayout",
                  "custom": "#/components/schemas/Custom",
                  "dispense": "#/components/schemas/Dispense",
                  "dispenseInPlace": "#/components/schemas/DispenseInPlace",
                  "dispenseWhileTracking": "#/components/schemas/DispenseWhileTracking",
                  "dropTip": "#/components/schemas/DropTip",
                  "dropTipInPlace": "#/components/schemas/DropTipInPlace",
                  "evotipDispense": "#/components/schemas/EvotipDispense",
                  "evotipSealPipette": "#/components/schemas/EvotipSealPipette",
                  "evotipUnsealPipette": "#/components/schemas/EvotipUnsealPipette",
                  "flexStacker/empty": "#/components/schemas/Empty",
                  "flexStacker/fill": "#/components/schemas/Fill",
                  "flexStacker/retrieve": "#/components/schemas/Retrieve",
                  "flexStacker/setStoredLabware": "#/components/schemas/SetStoredLabware",
                  "flexStacker/store": "#/components/schemas/Store",
                  "getNextTip": "#/components/schemas/GetNextTip",
                  "getTipPresence": "#/components/schemas/GetTipPresence",
                  "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatch",
                  "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeater",
                  "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShaker",
                  "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatch",
                  "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeed",
                  "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature",
                  "heaterShaker/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperature",
                  "home": "#/components/schemas/Home",
                  "liquidProbe": "#/components/schemas/LiquidProbe",
                  "loadLabware": "#/components/schemas/LoadLabware",
                  "loadLid": "#/components/schemas/LoadLid",
                  "loadLidStack": "#/components/schemas/LoadLidStack",
                  "loadLiquid": "#/components/schemas/LoadLiquid",
                  "loadLiquidClass": "#/components/schemas/LoadLiquidClass",
                  "loadModule": "#/components/schemas/LoadModule",
                  "loadPipette": "#/components/schemas/LoadPipette",
                  "magneticModule/disengage": "#/components/schemas/Disengage",
                  "magneticModule/engage": "#/components/schemas/Engage",
                  "moveLabware": "#/components/schemas/MoveLabware",
                  "moveRelative": "#/components/schemas/MoveRelative",
                  "moveToAddressableArea": "#/components/schemas/MoveToAddressableArea",
                  "moveToAddressableAreaForDropTip": "#/components/schemas/MoveToAddressableAreaForDropTip",
                  "moveToCoordinates": "#/components/schemas/MoveToCoordinates",
                  "moveToWell": "#/components/schemas/MoveToWell",
                  "pause": "#/components/schemas/WaitForResume",
                  "pickUpTip": "#/components/schemas/PickUpTip",
                  "prepareToAspirate": "#/components/schemas/PrepareToAspirate",
                  "reloadLabware": "#/components/schemas/ReloadLabware",
                  "retractAxis": "#/components/schemas/RetractAxis",
                  "robot/closeGripperJaw": "#/components/schemas/closeGripperJaw",
                  "robot/moveAxesRelative": "#/components/schemas/MoveAxesRelative",
                  "robot/moveAxesTo": "#/components/schemas/MoveAxesTo",
                  "robot/moveTo": "#/components/schemas/MoveTo",
                  "robot/openGripperJaw": "#/components/schemas/openGripperJaw",
                  "savePosition": "#/components/schemas/SavePosition",
                  "setRailLights": "#/components/schemas/SetRailLights",
                  "setStatusBar": "#/components/schemas/SetStatusBar",
                  "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperature",
                  "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature",
                  "temperatureModule/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperature",
                  "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid",
                  "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlock",
                  "thermocycler/deactivateLid": "#/components/schemas/DeactivateLid",
                  "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid",
                  "thermocycler/runExtendedProfile": "#/components/schemas/RunExtendedProfile",
                  "thermocycler/runProfile": "#/components/schemas/RunProfile",
                  "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperature",
                  "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperature",
                  "thermocycler/waitForBlockTemperature": "#/components/schemas/WaitForBlockTemperature",
                  "thermocycler/waitForLidTemperature": "#/components/schemas/WaitForLidTemperature",
                  "touchTip": "#/components/schemas/TouchTip",
                  "tryLiquidProbe": "#/components/schemas/TryLiquidProbe",
                  "unsafe/blowOutInPlace": "#/components/schemas/UnsafeBlowOutInPlace",
                  "unsafe/dropTipInPlace": "#/components/schemas/UnsafeDropTipInPlace",
                  "unsafe/engageAxes": "#/components/schemas/UnsafeEngageAxes",
                  "unsafe/placeLabware": "#/components/schemas/UnsafePlaceLabware",
                  "unsafe/ungripLabware": "#/components/schemas/UnsafeUngripLabware",
                  "unsafe/updatePositionEstimators": "#/components/schemas/UpdatePositionEstimators",
                  "verifyTipPresence": "#/components/schemas/VerifyTipPresence",
                  "waitForDuration": "#/components/schemas/WaitForDuration",
                  "waitForResume": "#/components/schemas/WaitForResume"
                }
              }
            },
            "type": "array",
            "title": "Commands",
            "description": "The protocol commands the run is expected to produce"
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/LoadedLabware"
            },
            "type": "array",
            "title": "Labware",
            "description": "Labware used by the protocol.\n\nIf a piece of labware moves between locations as part of the protocol, its *final* location will be reported in this list, not its *initial* location."
          },
          "pipettes": {
            "items": {
              "$ref": "#/components/schemas/LoadedPipette"
            },
            "type": "array",
            "title": "Pipettes",
            "description": "Pipettes used by the protocol"
          },
          "modules": {
            "items": {
              "$ref": "#/components/schemas/LoadedModule"
            },
            "type": "array",
            "title": "Modules",
            "description": "Modules that have been loaded into the run."
          },
          "liquids": {
            "items": {
              "$ref": "#/components/schemas/Liquid"
            },
            "type": "array",
            "title": "Liquids",
            "description": "Liquids used by the protocol"
          },
          "liquidClasses": {
            "items": {
              "$ref": "#/components/schemas/LiquidClassRecordWithId"
            },
            "type": "array",
            "title": "Liquidclasses",
            "description": "Liquid classes used by the protocol"
          },
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Errors",
            "description": "The protocol's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element."
          },
          "commandAnnotations": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/SecondOrderCommandAnnotation"
                },
                {
                  "$ref": "#/components/schemas/CustomCommandAnnotation"
                }
              ]
            },
            "type": "array",
            "title": "Commandannotations",
            "description": "Optional annotations for commands in this run."
          }
        },
        "type": "object",
        "required": [
          "id",
          "status",
          "result",
          "commands",
          "labware",
          "pipettes",
          "errors"
        ],
        "title": "CompletedAnalysis",
        "description": "A completed protocol run analysis.\n\nThis analysis provides three pieces of information:\n\n- A smoke test on whether the run is expected to succeed, given available data.\n- The equipment (labware, pipettes, modules) that the protocol will use.\n- The run commands that the protocol is expected to issue.\n\n!!! important \"Important note about non-deterministic protocols\"\n    Python protocols are allowed to be written in a way that makes their\n    behavior non-deterministic. For example, a protocol could use ``random``\n    to determine how much volume to aspirate.\n\n    If a protocol is non-deterministic, an analysis may differ from the\n    actual run (or any subsequent analysis). If you are writing or using\n    non-deterministic protocols, please keep this fact in mind.\n\n    JSON protocols are currently deterministic by design."
      },
      "ConfigureForVolume": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "configureForVolume"
            ],
            "const": "configureForVolume",
            "title": "Commandtype",
            "default": "configureForVolume"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/ConfigureForVolumeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ConfigureForVolumeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "ConfigureForVolume",
        "description": "Configure for volume command model."
      },
      "ConfigureForVolumeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "configureForVolume"
            ],
            "const": "configureForVolume",
            "title": "Commandtype",
            "default": "configureForVolume"
          },
          "params": {
            "$ref": "#/components/schemas/ConfigureForVolumeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "ConfigureForVolumeCreate",
        "description": "Configure for volume command creation request model."
      },
      "ConfigureForVolumeParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL. Must be at least 0 and no greater than a pipette-specific maximum volume."
          },
          "tipOverlapNotAfterVersion": {
            "type": "string",
            "title": "Tipoverlapnotafterversion",
            "description": "A version of tip overlap data to not exceed. The highest-versioned tip overlap data that does not exceed this version will be used. Versions are expressed as vN where N is an integer, counting up from v0. If None, the current highest version will be used."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "volume"
        ],
        "title": "ConfigureForVolumeParams",
        "description": "Parameters required to configure volume for a specific pipette."
      },
      "ConfigureForVolumeResult": {
        "properties": {},
        "type": "object",
        "title": "ConfigureForVolumeResult",
        "description": "Result data from execution of an ConfigureForVolume command."
      },
      "ConfigureNozzleLayout": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "configureNozzleLayout"
            ],
            "const": "configureNozzleLayout",
            "title": "Commandtype",
            "default": "configureNozzleLayout"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/ConfigureNozzleLayoutParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ConfigureNozzleLayoutResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "ConfigureNozzleLayout",
        "description": "Configure nozzle layout command model."
      },
      "ConfigureNozzleLayoutCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "configureNozzleLayout"
            ],
            "const": "configureNozzleLayout",
            "title": "Commandtype",
            "default": "configureNozzleLayout"
          },
          "params": {
            "$ref": "#/components/schemas/ConfigureNozzleLayoutParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "ConfigureNozzleLayoutCreate",
        "description": "Configure nozzle layout creation request model."
      },
      "ConfigureNozzleLayoutParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "configurationParams": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AllNozzleLayoutConfiguration"
              },
              {
                "$ref": "#/components/schemas/SingleNozzleLayoutConfiguration"
              },
              {
                "$ref": "#/components/schemas/RowNozzleLayoutConfiguration"
              },
              {
                "$ref": "#/components/schemas/ColumnNozzleLayoutConfiguration"
              },
              {
                "$ref": "#/components/schemas/QuadrantNozzleLayoutConfiguration"
              }
            ],
            "title": "Configurationparams"
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "configurationParams"
        ],
        "title": "ConfigureNozzleLayoutParams",
        "description": "Parameters required to configure the nozzle layout for a specific pipette."
      },
      "ConfigureNozzleLayoutResult": {
        "properties": {},
        "type": "object",
        "title": "ConfigureNozzleLayoutResult",
        "description": "Result data from execution of an configureNozzleLayout command."
      },
      "ConicalFrustum": {
        "properties": {
          "shape": {
            "type": "string",
            "enum": [
              "conical"
            ],
            "const": "conical",
            "title": "Shape"
          },
          "bottomDiameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomdiameter"
          },
          "topDiameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topdiameter"
          },
          "topHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topheight"
          },
          "bottomHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomheight"
          },
          "xCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Xcount",
            "default": 1
          },
          "yCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Ycount",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "shape",
          "bottomDiameter",
          "topDiameter",
          "topHeight",
          "bottomHeight"
        ],
        "title": "ConicalFrustum"
      },
      "ConnectionType": {
        "type": "string",
        "enum": [
          "wifi",
          "ethernet"
        ],
        "title": "ConnectionType"
      },
      "ConnectivityStatus": {
        "type": "string",
        "enum": [
          "full",
          "limited",
          "none",
          "portal",
          "unknown"
        ],
        "title": "ConnectivityStatus"
      },
      "Coordinate": {
        "properties": {
          "x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "Coordinate",
        "description": "Three-dimensional coordinates."
      },
      "CuboidalFrustum": {
        "properties": {
          "shape": {
            "type": "string",
            "enum": [
              "cuboidal"
            ],
            "const": "cuboidal",
            "title": "Shape"
          },
          "bottomXDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomxdimension"
          },
          "bottomYDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomydimension"
          },
          "topXDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topxdimension"
          },
          "topYDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topydimension"
          },
          "topHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topheight"
          },
          "bottomHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomheight"
          },
          "xCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Xcount",
            "default": 1
          },
          "yCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Ycount",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "shape",
          "bottomXDimension",
          "bottomYDimension",
          "topXDimension",
          "topYDimension",
          "topHeight",
          "bottomHeight"
        ],
        "title": "CuboidalFrustum"
      },
      "CurrentStateLinks": {
        "properties": {
          "lastCompleted": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandLinkNoMeta"
              },
              {
                "type": "null"
              }
            ],
            "description": "Path to the last completed command when current state was reported, if any."
          }
        },
        "type": "object",
        "title": "CurrentStateLinks",
        "description": "Links returned with the current state of a run."
      },
      "Custom": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "custom"
            ],
            "const": "custom",
            "title": "Commandtype",
            "default": "custom"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/CustomParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CustomResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Custom",
        "description": "Custom command model."
      },
      "CustomCommandAnnotation": {
        "properties": {
          "commandKeys": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Commandkeys",
            "description": "Command keys to which this annotation applies"
          },
          "annotationType": {
            "type": "string",
            "enum": [
              "custom"
            ],
            "const": "custom",
            "title": "Annotationtype",
            "default": "custom"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "commandKeys"
        ],
        "title": "CustomCommandAnnotation",
        "description": "Annotates a group of atomic commands in some manner that Opentrons software does not anticipate or originate."
      },
      "CustomCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "custom"
            ],
            "const": "custom",
            "title": "Commandtype",
            "default": "custom"
          },
          "params": {
            "$ref": "#/components/schemas/CustomParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CustomCreate",
        "description": "A request to create a custom command."
      },
      "CustomParams": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "CustomParams",
        "description": "Payload used by a custom command."
      },
      "CustomResult": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "CustomResult",
        "description": "Result data from a custom command."
      },
      "CutoutFixture": {
        "properties": {
          "cutoutFixtureId": {
            "type": "string",
            "title": "Cutoutfixtureid",
            "description": "What kind of cutout fixture is mounted onto the deck. Valid values are the `id`s of `cutoutFixtures` in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          },
          "cutoutId": {
            "type": "string",
            "title": "Cutoutid",
            "description": "Where on the deck this cutout fixture is mounted. Valid values are the `id`s of `cutouts` in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          },
          "opentronsModuleSerialNumber": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Opentronsmoduleserialnumber",
            "description": "The serial number of a module loaded as a fixture. [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          }
        },
        "type": "object",
        "required": [
          "cutoutFixtureId",
          "cutoutId"
        ],
        "title": "CutoutFixture",
        "description": "A single element of the robot's deck configuration."
      },
      "DataFile": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A unique identifier for this file."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the data file."
          },
          "source": {
            "$ref": "#/components/schemas/DataFileSource",
            "description": "The origin of the file (uploaded or generated)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When this data file was uploaded or generated.."
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "source",
          "createdAt"
        ],
        "title": "DataFile",
        "description": "A model representing a data file."
      },
      "DataFileInUse": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "DataFileInUse"
            ],
            "const": "DataFileInUse",
            "title": "Id",
            "default": "DataFileInUse"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Data file is in use"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "DataFileInUse",
        "description": "And error returned when attempting to delete a file that is still in use."
      },
      "DataFileSource": {
        "type": "string",
        "enum": [
          "uploaded",
          "generated"
        ],
        "title": "DataFileSource",
        "description": "The source this data file is from."
      },
      "DeactivateBlock": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/deactivateBlock"
            ],
            "const": "thermocycler/deactivateBlock",
            "title": "Commandtype",
            "default": "thermocycler/deactivateBlock"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateBlockParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeactivateBlockResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DeactivateBlock",
        "description": "A command to unset a Thermocycler's target block temperature."
      },
      "DeactivateBlockCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/deactivateBlock"
            ],
            "const": "thermocycler/deactivateBlock",
            "title": "Commandtype",
            "default": "thermocycler/deactivateBlock"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateBlockParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DeactivateBlockCreate",
        "description": "A request to create a Thermocycler's deactivate block command."
      },
      "DeactivateBlockParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DeactivateBlockParams",
        "description": "Input parameters to unset a Thermocycler's target block temperature."
      },
      "DeactivateBlockResult": {
        "properties": {},
        "type": "object",
        "title": "DeactivateBlockResult",
        "description": "Result data from unsetting a Thermocycler's target block temperature."
      },
      "DeactivateHeater": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/deactivateHeater"
            ],
            "const": "heaterShaker/deactivateHeater",
            "title": "Commandtype",
            "default": "heaterShaker/deactivateHeater"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateHeaterParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeactivateHeaterResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DeactivateHeater",
        "description": "A command to unset a Heater-Shaker's target temperature."
      },
      "DeactivateHeaterCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/deactivateHeater"
            ],
            "const": "heaterShaker/deactivateHeater",
            "title": "Commandtype",
            "default": "heaterShaker/deactivateHeater"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateHeaterParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DeactivateHeaterCreate",
        "description": "A request to create a Heater-Shaker's deactivate heater command."
      },
      "DeactivateHeaterParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DeactivateHeaterParams",
        "description": "Input parameters to unset a Heater-Shaker's target temperature."
      },
      "DeactivateHeaterResult": {
        "properties": {},
        "type": "object",
        "title": "DeactivateHeaterResult",
        "description": "Result data from unsetting a Heater-Shaker's target temperature."
      },
      "DeactivateLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/deactivateLid"
            ],
            "const": "thermocycler/deactivateLid",
            "title": "Commandtype",
            "default": "thermocycler/deactivateLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeactivateLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DeactivateLid",
        "description": "A command to unset a Thermocycler's target lid temperature."
      },
      "DeactivateLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/deactivateLid"
            ],
            "const": "thermocycler/deactivateLid",
            "title": "Commandtype",
            "default": "thermocycler/deactivateLid"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DeactivateLidCreate",
        "description": "A request to create a Thermocycler's deactivate lid command."
      },
      "DeactivateLidParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DeactivateLidParams",
        "description": "Input parameters to unset a Thermocycler's target lid temperature."
      },
      "DeactivateLidResult": {
        "properties": {},
        "type": "object",
        "title": "DeactivateLidResult",
        "description": "Result data from unsetting a Thermocycler's target lid temperature."
      },
      "DeactivateShaker": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/deactivateShaker"
            ],
            "const": "heaterShaker/deactivateShaker",
            "title": "Commandtype",
            "default": "heaterShaker/deactivateShaker"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateShakerParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeactivateShakerResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DeactivateShaker",
        "description": "A command to deactivate shaker for a Heater-Shaker."
      },
      "DeactivateShakerCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/deactivateShaker"
            ],
            "const": "heaterShaker/deactivateShaker",
            "title": "Commandtype",
            "default": "heaterShaker/deactivateShaker"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateShakerParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DeactivateShakerCreate",
        "description": "A request to create a Heater-Shaker's deactivate shaker command."
      },
      "DeactivateShakerParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DeactivateShakerParams",
        "description": "Input parameters to deactivate shaker for a Heater-Shaker Module."
      },
      "DeactivateShakerResult": {
        "properties": {},
        "type": "object",
        "title": "DeactivateShakerResult",
        "description": "Result data from deactivating shaker for a Heater-Shaker."
      },
      "DeactivateTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/deactivate"
            ],
            "const": "temperatureModule/deactivate",
            "title": "Commandtype",
            "default": "temperatureModule/deactivate"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeactivateTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DeactivateTemperature",
        "description": "A command to deactivate a Temperature Module."
      },
      "DeactivateTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/deactivate"
            ],
            "const": "temperatureModule/deactivate",
            "title": "Commandtype",
            "default": "temperatureModule/deactivate"
          },
          "params": {
            "$ref": "#/components/schemas/DeactivateTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DeactivateTemperatureCreate",
        "description": "A request to deactivate a Temperature Module."
      },
      "DeactivateTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Temperature Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DeactivateTemperatureParams",
        "description": "Input parameters to deactivate a Temperature Module."
      },
      "DeactivateTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "DeactivateTemperatureResult",
        "description": "Result data from deactivating a Temperature Module."
      },
      "DeckCalibrationCreateAttributes": {
        "properties": {
          "sessionType": {
            "type": "string",
            "enum": [
              "deckCalibration"
            ],
            "const": "deckCalibration",
            "title": "Sessiontype",
            "default": "deckCalibration"
          },
          "createParams": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BaseModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "DeckCalibrationCreateAttributes",
        "description": "The deck calibration create request."
      },
      "DeckCalibrationData": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/MatrixType",
            "description": "The type of deck calibration matrix: affine or attitude"
          },
          "matrix": {
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "type": "array",
            "title": "Matrix",
            "description": "The deck calibration transform matrix"
          },
          "lastModified": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastmodified",
            "description": "When this calibration was last modified"
          },
          "pipetteCalibratedWith": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pipettecalibratedwith",
            "description": "The ID of the pipette used in this calibration"
          },
          "tiprack": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiprack",
            "description": "A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes.",
            "deprecated": true
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SourceType"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibration source"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/robot_server__service__shared_models__calibration__CalibrationStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "The status of this calibration as determinedby a user performing calibration check."
          }
        },
        "type": "object",
        "required": [
          "type",
          "matrix"
        ],
        "title": "DeckCalibrationData"
      },
      "DeckCalibrationResponseAttributes": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Date and time that this session was created"
          },
          "details": {
            "$ref": "#/components/schemas/DeckCalibrationSessionStatus"
          },
          "sessionType": {
            "type": "string",
            "enum": [
              "deckCalibration"
            ],
            "const": "deckCalibration",
            "title": "Sessiontype",
            "default": "deckCalibration"
          },
          "createParams": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BaseModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "details"
        ],
        "title": "DeckCalibrationResponseAttributes",
        "description": "Response attributes of deck calibration session."
      },
      "DeckCalibrationSessionStatus": {
        "properties": {
          "instrument": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__helper_classes__AttachedPipette"
          },
          "currentStep": {
            "type": "string",
            "title": "Currentstep",
            "description": "Current step of deck calibration user flow"
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/RequiredLabware"
            },
            "type": "array",
            "title": "Labware"
          },
          "supportedCommands": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supportedcommands",
            "description": "A list of supported commands for this user flow"
          }
        },
        "type": "object",
        "required": [
          "instrument",
          "currentStep",
          "labware",
          "supportedCommands"
        ],
        "title": "DeckCalibrationSessionStatus",
        "description": "The current status of a deck calibration session.",
        "example": [
          {
            "currentStep": "sessionStarted",
            "instrument": {
              "model": "p300_single_v1.5",
              "mount": "right",
              "name": "p300_single",
              "serial": "P3HS12123041",
              "tip_length": 42
            },
            "labware": [
              {
                "definition": {
                  "ordering": "the ordering section..."
                },
                "isTiprack": "true",
                "loadName": "opentrons_96_tiprack_300ul",
                "namespace": "opentrons",
                "slot": "8",
                "version": 1
              }
            ]
          }
        ]
      },
      "DeckCalibrationStatus": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/DeckTransformState",
            "description": "An enum stating whether a user has a valid robotdeck calibration. See DeckTransformStateclass for more information."
          },
          "data": {
            "$ref": "#/components/schemas/DeckCalibrationData",
            "description": "Deck calibration data"
          }
        },
        "type": "object",
        "required": [
          "status",
          "data"
        ],
        "title": "DeckCalibrationStatus"
      },
      "DeckComparisonMap": {
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "IN_THRESHOLD",
              "OUTSIDE_THRESHOLD"
            ],
            "title": "Status",
            "description": "The status of this calibration type,dependent on the calibration beinginside or outside of the threshold"
          },
          "comparingPointOne": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "point 1 validation step"
          },
          "comparingPointTwo": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "point 2 validation step"
          },
          "comparingPointThree": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "point 3 validation step"
          }
        },
        "type": "object",
        "required": [
          "status"
        ],
        "title": "DeckComparisonMap"
      },
      "DeckConfigurationRequest": {
        "properties": {
          "cutoutFixtures": {
            "items": {
              "$ref": "#/components/schemas/CutoutFixture"
            },
            "type": "array",
            "title": "Cutoutfixtures",
            "description": "A full list of all the cutout fixtures that are mounted onto the deck. The order is arbitrary."
          }
        },
        "type": "object",
        "required": [
          "cutoutFixtures"
        ],
        "title": "DeckConfigurationRequest",
        "description": "A request to set the robot's deck configuration."
      },
      "DeckConfigurationResponse": {
        "properties": {
          "cutoutFixtures": {
            "items": {
              "$ref": "#/components/schemas/CutoutFixture"
            },
            "type": "array",
            "title": "Cutoutfixtures",
            "description": "A full list of all the cutout fixtures that are mounted onto the deck. The order is arbitrary."
          },
          "lastModifiedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastmodifiedat",
            "description": "When the deck configuration was last set over HTTP. If that has never happened, this will be `null` or omitted."
          }
        },
        "type": "object",
        "required": [
          "cutoutFixtures",
          "lastModifiedAt"
        ],
        "title": "DeckConfigurationResponse",
        "description": "A response for the robot's current deck configuration."
      },
      "DeckPoint": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "DeckPoint",
        "description": "Coordinates of a point in deck space."
      },
      "DeckSlotLocation": {
        "properties": {
          "slotName": {
            "$ref": "#/components/schemas/DeckSlotName",
            "description": "A slot on the robot's deck.\n\nThe plain numbers like `\"5\"` are for the OT-2, and the coordinates like `\"C2\"` are for the Flex.\n\nWhen you provide one of these values, you can use either style. It will automatically be converted to match the robot.\n\nWhen one of these values is returned, it will always match the robot."
          }
        },
        "type": "object",
        "required": [
          "slotName"
        ],
        "title": "DeckSlotLocation",
        "description": "The location of something placed in a single deck slot."
      },
      "DeckSlotName": {
        "type": "string",
        "enum": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
          "A1",
          "A2",
          "A3",
          "B1",
          "B2",
          "B3",
          "C1",
          "C2",
          "C3",
          "D1",
          "D2",
          "D3"
        ],
        "title": "DeckSlotName",
        "description": "Deck slot identifiers."
      },
      "DeckTransformState": {
        "type": "string",
        "enum": [
          "OK",
          "IDENTITY",
          "BAD_CALIBRATION",
          "SINGULARITY"
        ],
        "title": "DeckTransformState"
      },
      "DelayParams": {
        "properties": {
          "duration": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Duration",
            "description": "Duration of delay, in seconds."
          }
        },
        "type": "object",
        "required": [
          "duration"
        ],
        "title": "DelayParams",
        "description": "Parameters for delay."
      },
      "DelayProperties": {
        "properties": {
          "enable": {
            "type": "boolean",
            "title": "Enable",
            "description": "Whether delay is enabled."
          },
          "params": {
            "$ref": "#/components/schemas/DelayParams",
            "title": "Params",
            "description": "Parameters for the delay function."
          }
        },
        "type": "object",
        "required": [
          "enable"
        ],
        "title": "DelayProperties",
        "description": "Shared properties for delay.."
      },
      "DeprecatedMultiResponseModel_LabwareCalibration_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/LabwareCalibration"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedMultiResponseModel[LabwareCalibration]"
      },
      "DeprecatedMultiResponseModel_PipetteOffsetCalibration_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/PipetteOffsetCalibration"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedMultiResponseModel[PipetteOffsetCalibration]"
      },
      "DeprecatedMultiResponseModel_TipLengthCalibration_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/TipLengthCalibration"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedMultiResponseModel[TipLengthCalibration]"
      },
      "DeprecatedMultiResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__": {
        "properties": {
          "data": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/CalibrationCheckResponseAttributes"
                },
                {
                  "$ref": "#/components/schemas/TipLengthCalibrationResponseAttributes"
                },
                {
                  "$ref": "#/components/schemas/DeckCalibrationResponseAttributes"
                },
                {
                  "$ref": "#/components/schemas/PipetteOffsetCalibrationResponseAttributes"
                }
              ]
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedMultiResponseModel[Union[CalibrationCheckResponseAttributes, TipLengthCalibrationResponseAttributes, DeckCalibrationResponseAttributes, PipetteOffsetCalibrationResponseAttributes]]"
      },
      "DeprecatedResponseModel_SystemTimeResponseAttributes_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/SystemTimeResponseAttributes",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedResponseModel[SystemTimeResponseAttributes]"
      },
      "DeprecatedResponseModel_Union_CalibrationCheckResponseAttributes__TipLengthCalibrationResponseAttributes__DeckCalibrationResponseAttributes__PipetteOffsetCalibrationResponseAttributes__": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CalibrationCheckResponseAttributes"
              },
              {
                "$ref": "#/components/schemas/TipLengthCalibrationResponseAttributes"
              },
              {
                "$ref": "#/components/schemas/DeckCalibrationResponseAttributes"
              },
              {
                "$ref": "#/components/schemas/PipetteOffsetCalibrationResponseAttributes"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedResponseModel[Union[CalibrationCheckResponseAttributes, TipLengthCalibrationResponseAttributes, DeckCalibrationResponseAttributes, PipetteOffsetCalibrationResponseAttributes]]"
      },
      "DeprecatedResponseModel_Union_SessionCommandResponse_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition___EmptyModel__EmptyModel___SessionCommandResponse_Literal_load_labware___LoadLabwareCreate__LoadLabwareResult___SessionCommandResponse_Literal_load_pipette___LoadPipetteCreate__LoadPipetteResult___SessionCommandResponse_Literal_aspirate___AspirateCreate__AspirateResult___SessionCommandResponse_Literal_dispense___DispenseCreate__DispenseResult___SessionCommandResponse_Literal_pick_up_tip___PickUpTipCreate__PickUpTipResult___SessionCommandResponse_Literal_drop_tip___DropTipCreate__DropTipResult___SessionCommandResponse_Literal_jog___JogPosition__EmptyModel___SessionCommandResponse_Literal_set_has_calibration_block___SetHasCalibrationBlockRequestData__EmptyModel___SessionCommandResponse_Literal_load_labware___LoadLabwareByDefinitionRequestData__EmptyModel___": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition__EmptyModel_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_load_labware__LoadLabwareCreate_LoadLabwareResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_load_pipette__LoadPipetteCreate_LoadPipetteResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_aspirate__AspirateCreate_AspirateResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_dispense__DispenseCreate_DispenseResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_pick_up_tip__PickUpTipCreate_PickUpTipResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_drop_tip__DropTipCreate_DropTipResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_jog__JogPosition_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_set_has_calibration_block__SetHasCalibrationBlockRequestData_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandResponse_Literal_load_labware__LoadLabwareByDefinitionRequestData_EmptyModel_"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "A links object related to the primary data."
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "DeprecatedResponseModel[Union[SessionCommandResponse[Literal[<ProtocolCommand.start_run: 'protocol.startRun'>, <ProtocolCommand.start_simulate: 'protocol.startSimulate'>, <ProtocolCommand.cancel: 'protocol.cancel'>, <ProtocolCommand.pause: 'protocol.pause'>, <ProtocolCommand.resume: 'protocol.resume'>, <CalibrationCommand.move_to_tip_rack: 'calibration.moveToTipRack'>, <CalibrationCommand.move_to_point_one: 'calibration.moveToPointOne'>, <CalibrationCommand.move_to_deck: 'calibration.moveToDeck'>, <CalibrationCommand.move_to_reference_point: 'calibration.moveToReferencePoint'>, <CalibrationCommand.pick_up_tip: 'calibration.pickUpTip'>, <CalibrationCommand.confirm_tip_attached: 'calibration.confirmTip'>, <CalibrationCommand.invalidate_tip: 'calibration.invalidateTip'>, <CalibrationCommand.save_offset: 'calibration.saveOffset'>, <CalibrationCommand.exit: 'calibration.exitSession'>, <CalibrationCommand.invalidate_last_action: 'calibration.invalidateLastAction'>, <DeckCalibrationCommand.move_to_point_two: 'calibration.deck.moveToPointTwo'>, <DeckCalibrationCommand.move_to_point_three: 'calibration.deck.moveToPointThree'>, <CheckCalibrationCommand.compare_point: 'calibration.check.comparePoint'>, <CheckCalibrationCommand.switch_pipette: 'calibration.check.switchPipette'>, <CheckCalibrationCommand.return_tip: 'calibration.check.returnTip'>, <CheckCalibrationCommand.transition: 'calibration.check.transition'>], EmptyModel, EmptyModel], SessionCommandResponse[Literal[<EquipmentCommand.load_labware: 'equipment.loadLabware'>], LoadLabwareCreate, LoadLabwareResult], SessionCommandResponse[Literal[<EquipmentCommand.load_pipette: 'equipment.loadPipette'>], LoadPipetteCreate, LoadPipetteResult], SessionCommandResponse[Literal[<PipetteCommand.aspirate: 'pipette.aspirate'>], AspirateCreate, AspirateResult], SessionCommandResponse[Literal[<PipetteCommand.dispense: 'pipette.dispense'>], DispenseCreate, DispenseResult], SessionCommandResponse[Literal[<PipetteCommand.pick_up_tip: 'pipette.pickUpTip'>], PickUpTipCreate, PickUpTipResult], SessionCommandResponse[Literal[<PipetteCommand.drop_tip: 'pipette.dropTip'>], DropTipCreate, DropTipResult], SessionCommandResponse[Literal[<CalibrationCommand.jog: 'calibration.jog'>], JogPosition, EmptyModel], SessionCommandResponse[Literal[<CalibrationCommand.set_has_calibration_block: 'calibration.setHasCalibrationBlock'>], SetHasCalibrationBlockRequestData, EmptyModel], SessionCommandResponse[Literal[<CalibrationCommand.load_labware: 'calibration.loadLabware'>], LoadLabwareByDefinitionRequestData, EmptyModel]]]"
      },
      "Dimensions": {
        "properties": {
          "yDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Ydimension"
          },
          "zDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Zdimension"
          },
          "xDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Xdimension"
          }
        },
        "type": "object",
        "required": [
          "yDimension",
          "zDimension",
          "xDimension"
        ],
        "title": "Dimensions"
      },
      "Disengage": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "magneticModule/disengage"
            ],
            "const": "magneticModule/disengage",
            "title": "Commandtype",
            "default": "magneticModule/disengage"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DisengageParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DisengageResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Disengage",
        "description": "A command to disengage a Magnetic Module's magnets."
      },
      "DisengageCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "magneticModule/disengage"
            ],
            "const": "magneticModule/disengage",
            "title": "Commandtype",
            "default": "magneticModule/disengage"
          },
          "params": {
            "$ref": "#/components/schemas/DisengageParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DisengageCreate",
        "description": "A request to create a Magnetic Module disengage command."
      },
      "DisengageParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "The ID of the Magnetic Module whose magnets you want to disengage, from a prior `loadModule` command."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "DisengageParams",
        "description": "Input data to disengage a Magnetic Module's magnets."
      },
      "DisengageResult": {
        "properties": {},
        "type": "object",
        "title": "DisengageResult",
        "description": "The result of a Magnetic Module disengage command."
      },
      "Dispense": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "dispense"
            ],
            "const": "dispense",
            "title": "Commandtype",
            "default": "dispense"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DispenseResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Dispense",
        "description": "Dispense command model."
      },
      "DispenseCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "dispense"
            ],
            "const": "dispense",
            "title": "Commandtype",
            "default": "dispense"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DispenseCreate",
        "description": "Create dispense command request model."
      },
      "DispenseInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "dispenseInPlace"
            ],
            "const": "dispenseInPlace",
            "title": "Commandtype",
            "default": "dispenseInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DispenseInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DispenseInPlace",
        "description": "DispenseInPlace command model."
      },
      "DispenseInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "dispenseInPlace"
            ],
            "const": "dispenseInPlace",
            "title": "Commandtype",
            "default": "dispenseInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DispenseInPlaceCreate",
        "description": "DispenseInPlace command request model."
      },
      "DispenseInPlaceParams": {
        "properties": {
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to dispense, in L. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "pushOut": {
            "type": "number",
            "title": "Pushout",
            "description": "push the plunger a small amount farther than necessary for accurate low-volume dispensing"
          }
        },
        "type": "object",
        "required": [
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "DispenseInPlaceParams",
        "description": "Payload required to dispense in place."
      },
      "DispenseInPlaceResult": {
        "properties": {
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "DispenseInPlaceResult",
        "description": "Result data from the execution of a DispenseInPlace command."
      },
      "DispenseParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/LiquidHandlingWellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to dispense, in L. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "pushOut": {
            "type": "number",
            "title": "Pushout",
            "description": "push the plunger a small amount farther than necessary for accurate low-volume dispensing"
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "DispenseParams",
        "description": "Payload required to dispense to a specific well."
      },
      "DispenseResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "DispenseResult",
        "description": "Result data from the execution of a Dispense command."
      },
      "DispenseWhileTracking": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "dispenseWhileTracking"
            ],
            "const": "dispenseWhileTracking",
            "title": "Commandtype",
            "default": "dispenseWhileTracking"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseWhileTrackingParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DispenseWhileTrackingResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DispenseWhileTracking",
        "description": "Dispense command model."
      },
      "DispenseWhileTrackingCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "dispenseWhileTracking"
            ],
            "const": "dispenseWhileTracking",
            "title": "Commandtype",
            "default": "dispenseWhileTracking"
          },
          "params": {
            "$ref": "#/components/schemas/DispenseWhileTrackingParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DispenseWhileTrackingCreate",
        "description": "Create dispenseWhileTracking command request model."
      },
      "DispenseWhileTrackingParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/LiquidHandlingWellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to dispense, in L. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "pushOut": {
            "type": "number",
            "title": "Pushout",
            "description": "push the plunger a small amount farther than necessary for accurate low-volume dispensing"
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "DispenseWhileTrackingParams",
        "description": "Payload required to dispense to a specific well."
      },
      "DispenseWhileTrackingResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "DispenseWhileTrackingResult",
        "description": "Result data from the execution of a Dispense command."
      },
      "DisplayCategory": {
        "type": "string",
        "enum": [
          "tipRack",
          "tubeRack",
          "reservoir",
          "trash",
          "wellPlate",
          "aluminumBlock",
          "adapter",
          "other",
          "lid",
          "system"
        ],
        "title": "DisplayCategory"
      },
      "DoorState": {
        "type": "string",
        "enum": [
          "open",
          "closed"
        ],
        "title": "DoorState"
      },
      "DoorStatusModel": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/DoorState",
            "description": "Whether the door is open or closed."
          },
          "doorRequiredClosedForProtocol": {
            "type": "boolean",
            "title": "Doorrequiredclosedforprotocol",
            "description": "Whether the door must be closed to run a protcol."
          }
        },
        "type": "object",
        "required": [
          "status",
          "doorRequiredClosedForProtocol"
        ],
        "title": "DoorStatusModel",
        "description": "Model for the current door status."
      },
      "DropTip": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "dropTip"
            ],
            "const": "dropTip",
            "title": "Commandtype",
            "default": "dropTip"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DropTipParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DropTipResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TipPhysicallyAttachedError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DropTip",
        "description": "Drop tip command model."
      },
      "DropTipCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "dropTip"
            ],
            "const": "dropTip",
            "title": "Commandtype",
            "default": "dropTip"
          },
          "params": {
            "$ref": "#/components/schemas/DropTipParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DropTipCreate",
        "description": "Drop tip command creation request model."
      },
      "DropTipInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "dropTipInPlace"
            ],
            "const": "dropTipInPlace",
            "title": "Commandtype",
            "default": "dropTipInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/DropTipInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DropTipInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TipPhysicallyAttachedError"
              },
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "DropTipInPlace",
        "description": "Drop tip in place command model."
      },
      "DropTipInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "dropTipInPlace"
            ],
            "const": "dropTipInPlace",
            "title": "Commandtype",
            "default": "dropTipInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/DropTipInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "DropTipInPlaceCreate",
        "description": "Drop tip in place command creation request model."
      },
      "DropTipInPlaceParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "homeAfter": {
            "type": "boolean",
            "title": "Homeafter",
            "description": "Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "DropTipInPlaceParams",
        "description": "Payload required to drop a tip in place."
      },
      "DropTipInPlaceResult": {
        "properties": {},
        "type": "object",
        "title": "DropTipInPlaceResult",
        "description": "Result data from the execution of a DropTipInPlace command."
      },
      "DropTipParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/DropTipWellLocation",
            "description": "Relative well location at which to drop the tip."
          },
          "homeAfter": {
            "type": "boolean",
            "title": "Homeafter",
            "description": "Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware."
          },
          "alternateDropLocation": {
            "type": "boolean",
            "title": "Alternatedroplocation",
            "description": "Whether to alternate location where tip is dropped within the labware. If True, this command will ignore the wellLocation provided and alternate between dropping tips at two predetermined locations inside the specified labware well. If False, the tip will be dropped at the top center of the well."
          },
          "scrape_tips": {
            "type": "boolean",
            "title": "Scrape Tips",
            "description": "Whether or not to scrape off the tips with the ejector all the way down. If True, and the target location is a tip rack well, it will move the pipette. Towards the center of the tip rack with the ejector in the 'drop_tip' position. If False, no horizontal movement will occur."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "labwareId",
          "wellName"
        ],
        "title": "DropTipParams",
        "description": "Payload required to drop a tip in a specific well."
      },
      "DropTipResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "DropTipResult",
        "description": "Result data from the execution of a DropTip command."
      },
      "DropTipWellLocation": {
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/DropTipWellOrigin",
            "default": "default"
          },
          "offset": {
            "$ref": "#/components/schemas/WellOffset"
          }
        },
        "type": "object",
        "title": "DropTipWellLocation",
        "description": "Like WellLocation, but for dropping tips.\n\nUnlike a typical WellLocation, the location for a drop tip\ndefaults to location based on the tip length rather than the well's top."
      },
      "DropTipWellOrigin": {
        "type": "string",
        "enum": [
          "top",
          "bottom",
          "center",
          "default"
        ],
        "title": "DropTipWellOrigin",
        "description": "The origin of a DropTipWellLocation offset.\n\nProps:\n    TOP: the top-center of the well\n    BOTTOM: the bottom-center of the well\n    CENTER: the middle-center of the well\n    DEFAULT: the default drop-tip location of the well,\n        based on pipette configuration and length of the tip."
      },
      "EapConfigOption": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the config option"
          },
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "A human-readable and nicely formatted name for the option"
          },
          "required": {
            "type": "boolean",
            "title": "Required",
            "description": "Whether the option is required for this EAP variant or optional"
          },
          "type": {
            "$ref": "#/components/schemas/EapConfigOptionType",
            "description": "The type of the value. If string, a non-sensitive string like a username. If password, a sensitive string like a passphrase for a keyfile or a password. If file, upload the file with POST /wifi/keys and pass the hash."
          }
        },
        "type": "object",
        "required": [
          "name",
          "displayName",
          "required",
          "type"
        ],
        "title": "EapConfigOption",
        "description": "An object describing the name and format of an EAP config option"
      },
      "EapConfigOptionType": {
        "type": "string",
        "enum": [
          "string",
          "password",
          "file"
        ],
        "title": "EapConfigOptionType"
      },
      "EapOptions": {
        "properties": {
          "options": {
            "items": {
              "$ref": "#/components/schemas/EapVariant"
            },
            "type": "array",
            "title": "Options"
          }
        },
        "type": "object",
        "required": [
          "options"
        ],
        "title": "EapOptions",
        "description": "An object describing all supported EAP variants and their parameters",
        "example": {
          "options": [
            {
              "displayName": "PEAP/MS-CHAP v2",
              "name": "peap/mschapv2",
              "options": [
                {
                  "displayName": "Username",
                  "name": "identity",
                  "required": true,
                  "type": "string"
                },
                {
                  "displayName": "Anonymous Identity",
                  "name": "anonymousIdentity",
                  "required": false,
                  "type": "string"
                },
                {
                  "displayName": "CA Certificate File",
                  "name": "caCert",
                  "required": false,
                  "type": "file"
                },
                {
                  "displayName": "password",
                  "name": "password",
                  "required": true,
                  "type": "password"
                }
              ]
            }
          ]
        }
      },
      "EapVariant": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The identifier for the EAP variant"
          },
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "A human-readable formatted name for the EAP variant"
          },
          "options": {
            "items": {
              "$ref": "#/components/schemas/EapConfigOption"
            },
            "type": "array",
            "title": "Options",
            "description": "A list of objects describing configuration options for the EAP variant"
          }
        },
        "type": "object",
        "required": [
          "name",
          "displayName",
          "options"
        ],
        "title": "EapVariant",
        "description": "An object describing an EAP variant"
      },
      "Empty": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/empty"
            ],
            "const": "flexStacker/empty",
            "title": "Commandtype",
            "default": "flexStacker/empty"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/EmptyParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmptyResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Empty",
        "description": "A command to empty the Flex Stacker of labware."
      },
      "EmptyCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/empty"
            ],
            "const": "flexStacker/empty",
            "title": "Commandtype",
            "default": "flexStacker/empty"
          },
          "params": {
            "$ref": "#/components/schemas/EmptyParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "EmptyCreate",
        "description": "A request to execute a Flex Stacker empty command."
      },
      "EmptyModel": {
        "properties": {},
        "type": "object",
        "title": "EmptyModel"
      },
      "EmptyParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Flex Stacker"
          },
          "strategy": {
            "$ref": "#/components/schemas/StackerFillEmptyStrategy",
            "description": "How to empty the stacker. If manualWithPause, pause the protocol until the client sends an interaction, and mark the labware pool as empty thereafter. If logical, do not pause but immediately apply the specified count."
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "The message to display on connected clients during a manualWithPause strategy empty."
          },
          "count": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Count",
            "description": "The new count of labware in the pool. If None, default to an empty pool. If this number is larger than the amount of labware currently in the pool, default to the smaller amount. Do not use the value in the parameters as an outside observer; instead, use the count value from the results."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "strategy"
        ],
        "title": "EmptyParams",
        "description": "The parameters defining how a stacker should be emptied."
      },
      "EmptyResult": {
        "properties": {
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "The new amount of labware stored in the stacker labware pool."
          },
          "primaryLabwareURI": {
            "type": "string",
            "title": "Primarylabwareuri",
            "description": "The labware definition URI of the primary labware."
          },
          "adapterLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwareuri",
            "description": "The labware definition URI of the adapter labware."
          },
          "lidLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwareuri",
            "description": "The labware definition URI of the lid labware."
          }
        },
        "type": "object",
        "required": [
          "count",
          "primaryLabwareURI"
        ],
        "title": "EmptyResult",
        "description": "Result data from a stacker empty command."
      },
      "Engage": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "magneticModule/engage"
            ],
            "const": "magneticModule/engage",
            "title": "Commandtype",
            "default": "magneticModule/engage"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/EngageParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EngageResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Engage",
        "description": "A command to engage a Magnetic Module's magnets."
      },
      "EngageCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "magneticModule/engage"
            ],
            "const": "magneticModule/engage",
            "title": "Commandtype",
            "default": "magneticModule/engage"
          },
          "params": {
            "$ref": "#/components/schemas/EngageParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "EngageCreate",
        "description": "A request to create a Magnetic Module engage command."
      },
      "EngageParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "The ID of the Magnetic Module whose magnets you want to raise, from a prior `loadModule` command."
          },
          "height": {
            "type": "number",
            "title": "Height",
            "description": "How high, in millimeters, to raise the magnets.\n\nZero means the tops of the magnets are level with the ledge that the labware rests on. This will be slightly above the magnets' minimum height, the hardware home position. Negative values are allowed, to put the magnets below the ledge.\n\nUnits are always true millimeters. This is unlike certain labware definitions, engage commands in the Python Protocol API, and engage commands in older versions of the JSON protocol schema. Take care to convert properly."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "height"
        ],
        "title": "EngageParams",
        "description": "Input data to engage a Magnetic Module."
      },
      "EngageResult": {
        "properties": {},
        "type": "object",
        "title": "EngageResult",
        "description": "The result of a Magnetic Module engage command."
      },
      "EngagedMotor": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Is engine enabled"
          }
        },
        "type": "object",
        "required": [
          "enabled"
        ],
        "title": "EngagedMotor",
        "description": "Engaged motor"
      },
      "EngagedMotors": {
        "properties": {
          "x": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "y": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "z_l": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "z_r": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "p_l": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "p_r": {
            "$ref": "#/components/schemas/EngagedMotor"
          },
          "q": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EngagedMotor"
              },
              {
                "type": "null"
              }
            ]
          },
          "g": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EngagedMotor"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z_l",
          "z_r",
          "p_l",
          "p_r"
        ],
        "title": "EngagedMotors",
        "description": "Which motors are engaged."
      },
      "EngineStatus": {
        "type": "string",
        "enum": [
          "idle",
          "running",
          "paused",
          "blocked-by-open-door",
          "stop-requested",
          "finishing",
          "awaiting-recovery",
          "awaiting-recovery-paused",
          "awaiting-recovery-blocked-by-open-door",
          "stopped",
          "failed",
          "succeeded"
        ],
        "title": "EngineStatus",
        "description": "Current execution status of a ProtocolEngine.\n\nThis is a high-level summary of what the robot is doing and what interactions are\nappropriate."
      },
      "EnumChoice": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display string for the param's choice."
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Value",
            "description": "Enum value of the param's choice."
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "value"
        ],
        "title": "EnumChoice",
        "description": "Components of choices used in RTP Enum Parameters."
      },
      "EnumParameter": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display string for the parameter."
          },
          "variableName": {
            "type": "string",
            "title": "Variablename",
            "description": "Python variable name of the parameter."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of the parameter."
          },
          "suffix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Suffix",
            "description": "Units (like mL, mm/sec, etc) or a custom suffix for the parameter."
          },
          "type": {
            "type": "string",
            "enum": [
              "int",
              "float",
              "str"
            ],
            "title": "Type",
            "description": "String specifying whether the parameter is an int or float or string type."
          },
          "choices": {
            "items": {
              "$ref": "#/components/schemas/EnumChoice"
            },
            "type": "array",
            "title": "Choices",
            "description": "List of valid choices for this parameter."
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Value",
            "description": "The value assigned to the parameter; if not supplied by the client, will be assigned the default value."
          },
          "default": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Default",
            "description": "Default value of the parameter, to be used when there is no client-specified value."
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "variableName",
          "type",
          "choices",
          "value",
          "default"
        ],
        "title": "EnumParameter",
        "description": "A string enum defined in a protocol."
      },
      "ErrorBody": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__errors__error_responses__ErrorDetails"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody",
        "description": "A response body for a single error."
      },
      "ErrorBody_ClientDataKeyDoesNotExist_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ClientDataKeyDoesNotExist"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[ClientDataKeyDoesNotExist]"
      },
      "ErrorBody_DataFileInUse_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/DataFileInUse"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[DataFileInUse]"
      },
      "ErrorBody_FileIdNotFound_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/FileIdNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[FileIdNotFound]"
      },
      "ErrorBody_FileNotFound_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/FileNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[FileNotFound]"
      },
      "ErrorBody_FirmwareUpdateFailed_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/FirmwareUpdateFailed"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[FirmwareUpdateFailed]"
      },
      "ErrorBody_InvalidDeckConfiguration_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/InvalidDeckConfiguration"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[InvalidDeckConfiguration]"
      },
      "ErrorBody_LabwareCalibrationEndpointsRemoved_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/LabwareCalibrationEndpointsRemoved"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[LabwareCalibrationEndpointsRemoved]"
      },
      "ErrorBody_LastAnalysisPending_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/LastAnalysisPending"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[LastAnalysisPending]"
      },
      "ErrorBody_NoCurrentRunFound_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/NoCurrentRunFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[NoCurrentRunFound]"
      },
      "ErrorBody_NoOngoingUpdate_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/NoOngoingUpdate"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[NoOngoingUpdate]"
      },
      "ErrorBody_NoUpdateAvailable_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/NoUpdateAvailable"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[NoUpdateAvailable]"
      },
      "ErrorBody_NotSupportedOnOT2_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/NotSupportedOnOT2"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[NotSupportedOnOT2]"
      },
      "ErrorBody_PreSerializedCommandsNotAvailable_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/PreSerializedCommandsNotAvailable"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[PreSerializedCommandsNotAvailable]"
      },
      "ErrorBody_ProtocolNotFound_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ProtocolNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[ProtocolNotFound]"
      },
      "ErrorBody_ProtocolRunIsActive_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ProtocolRunIsActive"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[ProtocolRunIsActive]"
      },
      "ErrorBody_ProtocolUsedByRun_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ProtocolUsedByRun"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[ProtocolUsedByRun]"
      },
      "ErrorBody_RunActive_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/RunActive"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunActive]"
      },
      "ErrorBody_RunAlreadyActive_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/RunAlreadyActive"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunAlreadyActive]"
      },
      "ErrorBody_RunNotIdle_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__maintenance_runs__router__base_router__RunNotIdle"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunNotIdle]"
      },
      "ErrorBody_RunStopped_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/RunStopped"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunStopped]"
      },
      "ErrorBody_SubsystemNotPresent_": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/SubsystemNotPresent"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[SubsystemNotPresent]"
      },
      "ErrorBody_Union_FileIdNotFound__FileNotFound__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/FileIdNotFound"
                },
                {
                  "$ref": "#/components/schemas/FileNotFound"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[FileIdNotFound, FileNotFound]]"
      },
      "ErrorBody_Union_MultipleDataFileSources__NoDataFileSourceProvided__UnexpectedFileFormat__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/MultipleDataFileSources"
                },
                {
                  "$ref": "#/components/schemas/NoDataFileSourceProvided"
                },
                {
                  "$ref": "#/components/schemas/UnexpectedFileFormat"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[MultipleDataFileSources, NoDataFileSourceProvided, UnexpectedFileFormat]]"
      },
      "ErrorBody_Union_ProtocolFilesInvalid__ProtocolRobotTypeMismatch__FileIdNotFound__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ProtocolFilesInvalid"
                },
                {
                  "$ref": "#/components/schemas/ProtocolRobotTypeMismatch"
                },
                {
                  "$ref": "#/components/schemas/FileIdNotFound"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[ProtocolFilesInvalid, ProtocolRobotTypeMismatch, FileIdNotFound]]"
      },
      "ErrorBody_Union_ProtocolNotFound__AnalysisNotFound__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ProtocolNotFound"
                },
                {
                  "$ref": "#/components/schemas/AnalysisNotFound"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[ProtocolNotFound, AnalysisNotFound]]"
      },
      "ErrorBody_Union_RunActionNotAllowed__RunStopped__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/RunActionNotAllowed"
                },
                {
                  "$ref": "#/components/schemas/RunStopped"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[RunActionNotAllowed, RunStopped]]"
      },
      "ErrorBody_Union_RunStopped__RunNotIdle__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/RunStopped"
                },
                {
                  "$ref": "#/components/schemas/robot_server__runs__router__base_router__RunNotIdle"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[RunStopped, RunNotIdle]]"
      },
      "ErrorBody_Union_RunStopped__SetupCommandNotAllowed__": {
        "properties": {
          "errors": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/RunStopped"
                },
                {
                  "$ref": "#/components/schemas/SetupCommandNotAllowed"
                }
              ]
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[Union[RunStopped, SetupCommandNotAllowed]]"
      },
      "ErrorLocationInfo": {
        "properties": {
          "retryLocation": {
            "prefixItems": [
              {
                "type": "number"
              },
              {
                "type": "number"
              },
              {
                "type": "number"
              }
            ],
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Retrylocation"
          }
        },
        "type": "object",
        "required": [
          "retryLocation"
        ],
        "title": "ErrorLocationInfo",
        "description": "Holds a retry location for in-place error recovery.\n\nThis is appropriate to pass to a `moveToCoordinates` command,\nassuming the pipette has not been configured with a different nozzle layout\nin the meantime."
      },
      "ErrorMatcher": {
        "properties": {
          "errorType": {
            "type": "string",
            "title": "Errortype",
            "description": "The error type that this rule applies to."
          }
        },
        "type": "object",
        "required": [
          "errorType"
        ],
        "title": "ErrorMatcher",
        "description": "The error type that this rule applies to."
      },
      "ErrorOccurrence": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "description": "Whether this error is *defined.*\n\n*Defined* errors have a strictly defined cause and effect, and we generally\ndesign them to be recoverable. For example, a `pickUpTip` command might\nreturn a `tipPhysicallyMissing` error, which is defined, and which you can\nrecover from by doing a new `pickUpTip` in a different location.\n\nThe `errorType` and `errorInfo` fields are useful for reacting to defined\nerrors.\n\n*Undefined* errors are everything else. They could represent more obscure\nhardware failures that we aren't handling yet, or just bugs in our software.\nYou can continue issuing commands to a run after it encounters an undefined\nerror, but the robot may not behave well. For example, if a movement command\nfails with an undefined error, it could leave the robot in a messed-up\nstate, and the next movement command could have bad path planning that\ncollides the pipettes with stuff on the deck. We allow you to take this risk\nbecause it's sometimes better than safely stopping the run, which can\nwaste time and reagents.\n",
            "default": false
          },
          "errorType": {
            "type": "string",
            "title": "Errortype",
            "description": "This field has two meanings.\n\nWhen `isDefined` is `true`, this is a machine- and developer-readable\nidentifier for what kind of error this is. You can use this to implement\ninteractive error recovery flows, like watching for `\"overpressure\"` errors\nso you can tell the operator to unclog the tip.\n\nWhen `isDefined` is `false`, this is deprecated. For historical reasons,\nit will be the Python class name of some internal exception,\nlike `\"KeyError\"` or `\"UnexpectedProtocolError\"`. The string values are not\nstable across software versions. If you're looking for something to show to\nrobot operators, use `errorCode` and `detail` instead.\n"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "An enumerated error code for the error type.\nThis is intended to be shown to the robot operator to direct them to the\ncorrect rough area for troubleshooting.\n",
            "default": "4000"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A short human-readable message about the error.\n\nThis is intended to provide the robot operator with more specific details than\n`errorCode` alone. It should be no longer than a couple of sentences,\nand it should not contain internal newlines or indentation.\n\nIt should not internally repeat `errorCode`, but it may internally repeat `errorType`\nif it helps the message make sense when it's displayed in its own separate block.\n"
          },
          "errorInfo": {
            "type": "object",
            "title": "Errorinfo",
            "description": "Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n",
            "default": {}
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorType",
          "detail",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "ErrorOccurrence",
        "description": "An occurrence of a specific error during protocol execution."
      },
      "ErrorRecoveryPolicy": {
        "properties": {
          "policyRules": {
            "items": {
              "$ref": "#/components/schemas/ErrorRecoveryRule"
            },
            "type": "array",
            "title": "Policyrules",
            "description": "A list of error recovery rules to apply for a run's recovery management. The rules are evaluated first-to-last. The first exact match will dictate recovery management."
          }
        },
        "type": "object",
        "required": [
          "policyRules"
        ],
        "title": "ErrorRecoveryPolicy",
        "description": "Request/Response model for new error recovery policy rules creation."
      },
      "ErrorRecoveryRule": {
        "properties": {
          "matchCriteria": {
            "$ref": "#/components/schemas/MatchCriteria",
            "description": "The criteria that must be met for this rule to be applied."
          },
          "ifMatch": {
            "$ref": "#/components/schemas/ReactionIfMatch"
          }
        },
        "type": "object",
        "required": [
          "matchCriteria",
          "ifMatch"
        ],
        "title": "ErrorRecoveryRule",
        "description": "Model for new error recovery rule."
      },
      "ErrorSource": {
        "properties": {
          "pointer": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pointer",
            "description": "A JSON Pointer [RFC6901] to the associated entity in the request document."
          },
          "parameter": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parameter",
            "description": "a string indicating which URI query parameter caused the error."
          },
          "header": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Header",
            "description": "A string indicating which header caused the error."
          }
        },
        "type": "object",
        "title": "ErrorSource",
        "description": "An object containing references to the source of the error."
      },
      "EstopPhysicalStatus": {
        "type": "string",
        "enum": [
          "engaged",
          "disengaged",
          "notPresent"
        ],
        "title": "EstopPhysicalStatus",
        "description": "Physical status of a specific estop."
      },
      "EstopState": {
        "type": "string",
        "enum": [
          "notPresent",
          "physicallyEngaged",
          "logicallyEngaged",
          "disengaged"
        ],
        "title": "EstopState",
        "description": "Current status of the estop on this robot."
      },
      "EstopStatusModel": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/EstopState",
            "description": "The current status of the estop on this robot."
          },
          "leftEstopPhysicalStatus": {
            "$ref": "#/components/schemas/EstopPhysicalStatus",
            "description": "Physical status of the left estop mount."
          },
          "rightEstopPhysicalStatus": {
            "$ref": "#/components/schemas/EstopPhysicalStatus",
            "description": "Physical status of the right estop mount."
          }
        },
        "type": "object",
        "required": [
          "status",
          "leftEstopPhysicalStatus",
          "rightEstopPhysicalStatus"
        ],
        "title": "EstopStatusModel",
        "description": "Model for the current estop status."
      },
      "EvotipDispense": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "evotipDispense"
            ],
            "const": "evotipDispense",
            "title": "Commandtype",
            "default": "evotipDispense"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipDispenseParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EvotipDispenseResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "EvotipDispense",
        "description": "DispenseInPlace command model."
      },
      "EvotipDispenseCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "evotipDispense"
            ],
            "const": "evotipDispense",
            "title": "Commandtype",
            "default": "evotipDispense"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipDispenseParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "EvotipDispenseCreate",
        "description": "DispenseInPlace command request model."
      },
      "EvotipDispenseParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/LiquidHandlingWellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "The amount of liquid to dispense, in L. Must not be greater than the currently aspirated volume. There is some tolerance for floating point rounding errors."
          },
          "correctionVolume": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Correctionvolume",
            "description": "The correction volume in uL."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "flowRate",
          "volume",
          "pipetteId"
        ],
        "title": "EvotipDispenseParams",
        "description": "Payload required to dispense in place."
      },
      "EvotipDispenseResult": {
        "properties": {
          "volume": {
            "type": "number",
            "minimum": 0,
            "title": "Volume",
            "description": "Amount of liquid in uL handled in the operation."
          }
        },
        "type": "object",
        "required": [
          "volume"
        ],
        "title": "EvotipDispenseResult",
        "description": "Result data from the execution of a DispenseInPlace command."
      },
      "EvotipSealPipette": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "evotipSealPipette"
            ],
            "const": "evotipSealPipette",
            "title": "Commandtype",
            "default": "evotipSealPipette"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipSealPipetteParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EvotipSealPipetteResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "EvotipSealPipette",
        "description": "Seal evotip resin tip command model."
      },
      "EvotipSealPipetteCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "evotipSealPipette"
            ],
            "const": "evotipSealPipette",
            "title": "Commandtype",
            "default": "evotipSealPipette"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipSealPipetteParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "EvotipSealPipetteCreate",
        "description": "Seal evotip resin tip command creation request model."
      },
      "EvotipSealPipetteParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/PickUpTipWellLocation",
            "description": "Relative well location at which to pick up the tip."
          },
          "tipPickUpParams": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TipPickUpParams"
              },
              {
                "type": "null"
              }
            ],
            "description": "Specific parameters for "
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "labwareId",
          "wellName"
        ],
        "title": "EvotipSealPipetteParams",
        "description": "Payload needed to seal resin tips to a pipette."
      },
      "EvotipSealPipetteResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "tipVolume": {
            "type": "number",
            "minimum": 0,
            "title": "Tipvolume",
            "description": "Maximum volume of liquid that the picked up tip can hold, in L.",
            "default": 0
          },
          "tipLength": {
            "type": "number",
            "minimum": 0,
            "title": "Tiplength",
            "description": "The length of the tip in mm.",
            "default": 0
          },
          "tipDiameter": {
            "type": "number",
            "minimum": 0,
            "title": "Tipdiameter",
            "description": "The diameter of the tip in mm.",
            "default": 0
          }
        },
        "type": "object",
        "title": "EvotipSealPipetteResult",
        "description": "Result data from the execution of a EvotipSealPipette."
      },
      "EvotipUnsealPipette": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "evotipUnsealPipette"
            ],
            "const": "evotipUnsealPipette",
            "title": "Commandtype",
            "default": "evotipUnsealPipette"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipUnsealPipetteParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EvotipUnsealPipetteResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "EvotipUnsealPipette",
        "description": "Evotip unseal command model."
      },
      "EvotipUnsealPipetteCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "evotipUnsealPipette"
            ],
            "const": "evotipUnsealPipette",
            "title": "Commandtype",
            "default": "evotipUnsealPipette"
          },
          "params": {
            "$ref": "#/components/schemas/EvotipUnsealPipetteParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "EvotipUnsealPipetteCreate",
        "description": "Evotip unseal command creation request model."
      },
      "EvotipUnsealPipetteParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/DropTipWellLocation",
            "description": "Relative well location at which to drop the tip."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "labwareId",
          "wellName"
        ],
        "title": "EvotipUnsealPipetteParams",
        "description": "Payload required to drop a tip in a specific well."
      },
      "EvotipUnsealPipetteResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "EvotipUnsealPipetteResult",
        "description": "Result data from the execution of a DropTip command."
      },
      "FactoryResetOption": {
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ResetOptionId",
            "description": "A short machine-readable id for the setting"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "A short human-readable name for the setting"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A longer human-readable description of the setting"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "description"
        ],
        "title": "FactoryResetOption"
      },
      "FactoryResetOptions": {
        "properties": {
          "options": {
            "items": {
              "$ref": "#/components/schemas/FactoryResetOption"
            },
            "type": "array",
            "title": "Options"
          }
        },
        "type": "object",
        "required": [
          "options"
        ],
        "title": "FactoryResetOptions",
        "description": "Available values to reset as factory reset"
      },
      "FileIdNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "FileIdNotFound"
            ],
            "const": "FileIdNotFound",
            "title": "Id",
            "default": "FileIdNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Specified file id not found on the robot"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "FileIdNotFound",
        "description": "An error returned when specified file id was not found on the robot."
      },
      "FileInfo": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The UUID identifier of the file stored on the robot."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the file, including the extension."
          }
        },
        "type": "object",
        "required": [
          "id",
          "name"
        ],
        "title": "FileInfo",
        "description": "A file UUID descriptor."
      },
      "FileNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "FileNotFound"
            ],
            "const": "FileNotFound",
            "title": "Id",
            "default": "FileNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Specified file path not found on the robot"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "FileNotFound",
        "description": "An error returned when specified file path was not found on the robot."
      },
      "Fill": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/fill"
            ],
            "const": "flexStacker/fill",
            "title": "Commandtype",
            "default": "flexStacker/fill"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/FillParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FillResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Fill",
        "description": "A command to fill the Flex Stacker with labware."
      },
      "FillCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/fill"
            ],
            "const": "flexStacker/fill",
            "title": "Commandtype",
            "default": "flexStacker/fill"
          },
          "params": {
            "$ref": "#/components/schemas/FillParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "FillCreate",
        "description": "A request to execute a Flex Stacker fill command."
      },
      "FillParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Flex Stacker"
          },
          "strategy": {
            "$ref": "#/components/schemas/StackerFillEmptyStrategy",
            "description": "How to fill the stacker. If manualWithPause, pause the protocol until the client sends an interaction, and apply the new specified count thereafter. If logical, do not pause but immediately apply the specified count."
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "The message to display on connected clients during a manualWithPause strategy fill."
          },
          "count": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Count",
            "description": "How full the labware pool should now be. If None, default to the maximum amount of the currently-configured labware the pool can hold. If this number is larger than the maximum the pool can hold, it will be clamped to the maximum. If this number is smaller than the current amount of labware the pool holds, it will be clamped to that minimum. Do not use the value in the parameters as an outside observer; instead, use the count value from the results."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "strategy"
        ],
        "title": "FillParams",
        "description": "The parameters defining how a stacker should be filled."
      },
      "FillResult": {
        "properties": {
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "The new amount of labware stored in the stacker labware pool."
          },
          "primaryLabwareURI": {
            "type": "string",
            "title": "Primarylabwareuri",
            "description": "The labware definition URI of the primary labware."
          },
          "adapterLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwareuri",
            "description": "The labware definition URI of the adapter labware."
          },
          "lidLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwareuri",
            "description": "The labware definition URI of the lid labware."
          }
        },
        "type": "object",
        "required": [
          "count",
          "primaryLabwareURI"
        ],
        "title": "FillResult",
        "description": "Result data from a stacker fill command."
      },
      "FirmwareUpdateFailed": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "FirmwareUpdateFailed"
            ],
            "const": "FirmwareUpdateFailed",
            "title": "Id",
            "default": "FirmwareUpdateFailed"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Firmware Update Failed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "FirmwareUpdateFailed",
        "description": "An error if a firmware update failed for some reason."
      },
      "FlexStackerModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "flexStackerModuleType"
            ],
            "const": "flexStackerModuleType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "flexStackerModuleV1"
            ],
            "const": "flexStackerModuleV1",
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/FlexStackerModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "FlexStackerModule",
        "description": "An attached Flex Stacker Module."
      },
      "FlexStackerModuleData": {
        "properties": {
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Overall status of the module."
          },
          "latchState": {
            "$ref": "#/components/schemas/LatchState",
            "description": "The state of the labware latch."
          },
          "platformState": {
            "$ref": "#/components/schemas/PlatformState",
            "description": "The state of the platform."
          },
          "hopperDoorState": {
            "$ref": "#/components/schemas/HopperDoorState",
            "description": "The state of the hopper door."
          },
          "axisStateX": {
            "$ref": "#/components/schemas/StackerAxisState",
            "description": "The state of the X axis limit switches."
          },
          "axisStateZ": {
            "$ref": "#/components/schemas/StackerAxisState",
            "description": "The state of the Z axis limit switches."
          }
        },
        "type": "object",
        "required": [
          "status",
          "latchState",
          "platformState",
          "hopperDoorState",
          "axisStateX",
          "axisStateZ"
        ],
        "title": "FlexStackerModuleData",
        "description": "Live data from a Flex Stacker module."
      },
      "GetNextTip": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "getNextTip"
            ],
            "const": "getNextTip",
            "title": "Commandtype",
            "default": "getNextTip"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/GetNextTipParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GetNextTipResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "GetNextTip",
        "description": "Get next tip command model."
      },
      "GetNextTipCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "getNextTip"
            ],
            "const": "getNextTip",
            "title": "Commandtype",
            "default": "getNextTip"
          },
          "params": {
            "$ref": "#/components/schemas/GetNextTipParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "GetNextTipCreate",
        "description": "Get next tip command creation request model."
      },
      "GetNextTipParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "labwareIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Labwareids",
            "description": "Labware ID(s) of tip racks to resolve next available tip(s) from Labware IDs will be resolved sequentially"
          },
          "startingTipWell": {
            "type": "string",
            "title": "Startingtipwell",
            "description": "Name of starting tip rack 'well'. This only applies to the first tip rack in the list provided in labwareIDs"
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "labwareIds"
        ],
        "title": "GetNextTipParams",
        "description": "Payload needed to resolve the next available tip."
      },
      "GetNextTipResult": {
        "properties": {
          "nextTipInfo": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NextTipInfo"
              },
              {
                "$ref": "#/components/schemas/NoTipAvailable"
              }
            ],
            "title": "Nexttipinfo",
            "description": "Labware ID and well name of next available tip for a pipette, or information why no tip could be resolved."
          }
        },
        "type": "object",
        "required": [
          "nextTipInfo"
        ],
        "title": "GetNextTipResult",
        "description": "Result data from the execution of a GetNextTip."
      },
      "GetTipPresence": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "getTipPresence"
            ],
            "const": "getTipPresence",
            "title": "Commandtype",
            "default": "getTipPresence"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/GetTipPresenceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GetTipPresenceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "GetTipPresence",
        "description": "GetTipPresence command model."
      },
      "GetTipPresenceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "getTipPresence"
            ],
            "const": "getTipPresence",
            "title": "Commandtype",
            "default": "getTipPresence"
          },
          "params": {
            "$ref": "#/components/schemas/GetTipPresenceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "GetTipPresenceCreate",
        "description": "GetTipPresence command creation request model."
      },
      "GetTipPresenceParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "GetTipPresenceParams",
        "description": "Payload required for a GetTipPresence command."
      },
      "GetTipPresenceResult": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/TipPresenceStatus",
            "description": "Whether or not a tip is attached on the pipette. This only works on on FLEX because OT-2 pipettes do not possess tip presence sensors, hence, will always return TipPresenceStatus.UNKNOWN."
          }
        },
        "type": "object",
        "required": [
          "status"
        ],
        "title": "GetTipPresenceResult",
        "description": "Result data from the execution of a GetTipPresence command."
      },
      "Gripper": {
        "properties": {
          "mount": {
            "type": "string",
            "title": "Mount",
            "description": "The mount this instrument is attached to."
          },
          "instrumentType": {
            "type": "string",
            "enum": [
              "gripper"
            ],
            "const": "gripper",
            "title": "Instrumenttype",
            "default": "gripper"
          },
          "instrumentModel": {
            "type": "string",
            "title": "Instrumentmodel"
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Instrument hardware serial number."
          },
          "subsystem": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SubSystem"
              },
              {
                "type": "null"
              }
            ],
            "description": "The subsystem corresponding to this instrument."
          },
          "ok": {
            "type": "boolean",
            "enum": [
              true
            ],
            "const": true,
            "title": "Ok",
            "description": "Whether this instrument is OK and ready to go"
          },
          "firmwareVersion": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Firmwareversion",
            "description": "The firmware version of this instrument (if applicable)"
          },
          "data": {
            "$ref": "#/components/schemas/GripperData"
          }
        },
        "type": "object",
        "required": [
          "mount",
          "instrumentModel",
          "serialNumber",
          "ok",
          "data"
        ],
        "title": "Gripper",
        "description": "Attached gripper info & configuration."
      },
      "GripperCalibrationOffset": {
        "properties": {
          "offset": {
            "$ref": "#/components/schemas/Point"
          },
          "source": {
            "$ref": "#/components/schemas/SourceType"
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__calibration_storage__types__CalibrationStatus"
          },
          "last_modified": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Modified"
          }
        },
        "type": "object",
        "required": [
          "offset",
          "source",
          "status"
        ],
        "title": "GripperCalibrationOffset"
      },
      "GripperData": {
        "properties": {
          "jawState": {
            "type": "string",
            "title": "Jawstate",
            "description": "Gripper Jaw state."
          },
          "calibratedOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/InstrumentCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "Calibrated gripper offset."
          }
        },
        "type": "object",
        "required": [
          "jawState"
        ],
        "title": "GripperData",
        "description": "Data from attached gripper."
      },
      "GripperMovementError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "gripperMovement"
            ],
            "const": "gripperMovement",
            "title": "Errortype",
            "default": "gripperMovement"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "An enumerated error code for the error type.\nThis is intended to be shown to the robot operator to direct them to the\ncorrect rough area for troubleshooting.\n",
            "default": "4000"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A short human-readable message about the error.\n\nThis is intended to provide the robot operator with more specific details than\n`errorCode` alone. It should be no longer than a couple of sentences,\nand it should not contain internal newlines or indentation.\n\nIt should not internally repeat `errorCode`, but it may internally repeat `errorType`\nif it helps the message make sense when it's displayed in its own separate block.\n"
          },
          "errorInfo": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__move_labware__ErrorDetails"
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "detail",
          "errorInfo",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "GripperMovementError",
        "description": "Returned when something physically goes wrong when the gripper moves labware.\n\nWhen this error happens, the engine will leave the labware in its original place."
      },
      "GripperOffsets": {
        "properties": {
          "pickUpOffset": {
            "$ref": "#/components/schemas/Vector"
          },
          "dropOffset": {
            "$ref": "#/components/schemas/Vector"
          }
        },
        "type": "object",
        "required": [
          "pickUpOffset",
          "dropOffset"
        ],
        "title": "GripperOffsets"
      },
      "Group": {
        "properties": {
          "wells": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Wells"
          },
          "metadata": {
            "$ref": "#/components/schemas/GroupMetadata"
          },
          "brand": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BrandData"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "wells",
          "metadata"
        ],
        "title": "Group"
      },
      "GroupMetadata": {
        "properties": {
          "displayName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Displayname"
          },
          "displayCategory": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DisplayCategory"
              },
              {
                "type": "null"
              }
            ]
          },
          "wellBottomShape": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "flat",
                  "u",
                  "v"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Wellbottomshape"
          }
        },
        "type": "object",
        "title": "GroupMetadata"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "Health": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The robot's name. In most cases the same as its mDNS advertisement domain name, but this can get out of sync. Mostly useful for user-facing titles.",
            "examples": [
              "Otie"
            ]
          },
          "robot_model": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "OT-2 Standard"
                ],
                "const": "OT-2 Standard"
              },
              {
                "type": "string",
                "enum": [
                  "OT-3 Standard"
                ],
                "const": "OT-3 Standard"
              }
            ],
            "title": "Robot Model",
            "description": "Which model of Opentrons robot this is"
          },
          "api_version": {
            "type": "string",
            "title": "Api Version",
            "description": "The API server's software version",
            "examples": [
              "3.15.2"
            ]
          },
          "fw_version": {
            "type": "string",
            "title": "Fw Version",
            "description": "The motor controller's firmware version. Doesn't follow a pattern; suitable only for display or exact matching.",
            "examples": [
              "v2.15.0"
            ]
          },
          "board_revision": {
            "type": "string",
            "title": "Board Revision",
            "description": "The hardware revision of the OT-2's central routing board.",
            "examples": [
              "2.1"
            ]
          },
          "logs": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Logs",
            "description": "List of paths at which to find log endpoints",
            "examples": [
              [
                "/logs/serial.log",
                "/logs/api.log"
              ]
            ]
          },
          "system_version": {
            "type": "string",
            "title": "System Version",
            "description": "The robot's operating system version.",
            "examples": [
              "1.2.1"
            ]
          },
          "maximum_protocol_api_version": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "maxItems": 2,
            "minItems": 2,
            "title": "Maximum Protocol Api Version",
            "description": "The system's maximum supported Protocol API version, in the format `[major_version, minor_version]`",
            "examples": [
              [
                2,
                8
              ]
            ]
          },
          "minimum_protocol_api_version": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "maxItems": 2,
            "minItems": 2,
            "title": "Minimum Protocol Api Version",
            "description": "The system's minimum supported Protocol API version, in the format `[major_version, minor_version]`",
            "examples": [
              [
                2,
                0
              ]
            ]
          },
          "robot_serial": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Robot Serial",
            "description": "The robot serial number. Should be used if present; if not present, use result of /server/update/health.",
            "examples": [
              "OT2CEP20190604A02"
            ]
          },
          "links": {
            "$ref": "#/components/schemas/HealthLinks"
          }
        },
        "type": "object",
        "required": [
          "name",
          "robot_model",
          "api_version",
          "fw_version",
          "board_revision",
          "logs",
          "system_version",
          "maximum_protocol_api_version",
          "minimum_protocol_api_version",
          "links"
        ],
        "title": "Health",
        "description": "Information about the server and system."
      },
      "HealthLinks": {
        "properties": {
          "apiLog": {
            "type": "string",
            "title": "Apilog",
            "description": "The path to the API logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.",
            "deprecated": true,
            "examples": [
              "/logs/api.log"
            ]
          },
          "serialLog": {
            "type": "string",
            "title": "Seriallog",
            "description": "The path to the motor control serial communication logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.",
            "deprecated": true,
            "examples": [
              "/logs/serial.log"
            ]
          },
          "serverLog": {
            "type": "string",
            "title": "Serverlog",
            "description": "The path to the HTTP server logs endpoint. Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.",
            "deprecated": true,
            "examples": [
              "/logs/server.log"
            ]
          },
          "oddLog": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Oddlog",
            "description": "The path to the on-device display app logs endpoint (only present on the Opentrons Flex). Deprecated: Use the `logs` field of the `GET /health` response or refer to the OpenAPI specification of the `/logs` endpoint, instead.",
            "deprecated": true,
            "examples": [
              "/logs/touchscreen.log"
            ]
          },
          "apiSpec": {
            "type": "string",
            "title": "Apispec",
            "description": "The path to the OpenAPI specification of the server",
            "examples": [
              "/openapi.json"
            ]
          },
          "systemTime": {
            "type": "string",
            "title": "Systemtime",
            "description": "The path to the system time endpoints",
            "examples": [
              "/system/time"
            ]
          }
        },
        "type": "object",
        "required": [
          "apiLog",
          "serialLog",
          "serverLog",
          "apiSpec",
          "systemTime"
        ],
        "title": "HealthLinks",
        "description": "Useful server links."
      },
      "HeaterShakerLabwareLatchStatus": {
        "type": "string",
        "enum": [
          "opening",
          "idle_open",
          "closing",
          "idle_closed",
          "idle_unknown",
          "unknown"
        ],
        "title": "HeaterShakerLabwareLatchStatus",
        "description": "Heater-shaker labware latch status"
      },
      "HeaterShakerModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "heaterShakerModuleType"
            ],
            "const": "heaterShakerModuleType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "heaterShakerModuleV1"
            ],
            "const": "heaterShakerModuleV1",
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/HeaterShakerModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "HeaterShakerModule",
        "description": "An attached Heater-Shaker Module."
      },
      "HeaterShakerModuleData": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HeaterShakerStatus",
            "description": "Overall status of the module."
          },
          "labwareLatchStatus": {
            "$ref": "#/components/schemas/HeaterShakerLabwareLatchStatus",
            "description": "Status of the module's labware latch"
          },
          "speedStatus": {
            "$ref": "#/components/schemas/SpeedStatus",
            "description": "Status of the module's shaker."
          },
          "currentSpeed": {
            "type": "integer",
            "title": "Currentspeed",
            "description": "Current speed of the shaker, in rotations-per-minute."
          },
          "targetSpeed": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Targetspeed",
            "description": "Target speed of the shaker, if set, in rotations-per-minute."
          },
          "temperatureStatus": {
            "$ref": "#/components/schemas/TemperatureStatus",
            "description": "Status of the module's heater."
          },
          "currentTemperature": {
            "type": "number",
            "title": "Currenttemperature",
            "description": "Current temperature of the heater, in degrees Celsius."
          },
          "targetTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Targettemperature",
            "description": "Target temperature of the heater, if set, in degrees Celsius."
          },
          "errorDetails": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errordetails",
            "description": "Error details, if the module hardware has encountered something unexpected and unrecoverable."
          }
        },
        "type": "object",
        "required": [
          "status",
          "labwareLatchStatus",
          "speedStatus",
          "currentSpeed",
          "targetSpeed",
          "temperatureStatus",
          "currentTemperature",
          "targetTemperature",
          "errorDetails"
        ],
        "title": "HeaterShakerModuleData",
        "description": "Live data from a Heater-Shaker module."
      },
      "HeaterShakerStatus": {
        "type": "string",
        "enum": [
          "idle",
          "running",
          "error"
        ],
        "title": "HeaterShakerStatus"
      },
      "HexColor": {
        "type": "string",
        "pattern": "^#(?:[0-9a-fA-F]{3,4}){1,2}$",
        "title": "HexColor",
        "description": "Hex color representation."
      },
      "Home": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "home"
            ],
            "const": "home",
            "title": "Commandtype",
            "default": "home"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/HomeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HomeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Home",
        "description": "Command to send some (or all) motors to their home positions.\n\nHoming a motor re-establishes positional accuracy the first time a motor\nis used, or any time the motor \"loses\" its position, for example, after\na halt or after a collision."
      },
      "HomeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "home"
            ],
            "const": "home",
            "title": "Commandtype",
            "default": "home"
          },
          "params": {
            "$ref": "#/components/schemas/HomeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "HomeCreate",
        "description": "Data to create a Home command."
      },
      "HomeParams": {
        "properties": {
          "axes": {
            "items": {
              "$ref": "#/components/schemas/MotorAxis"
            },
            "type": "array",
            "title": "Axes",
            "description": "Axes to return to their home positions. If omitted, will home all motors. Extra axes may be implicitly homed to ensure accurate homing of the explicitly specified axes."
          },
          "skipIfMountPositionOk": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "title": "Skipifmountpositionok",
            "description": "If this parameter is provided, the gantry will only be homed if the specified mount has an invalid position. If omitted, the homing action will be executed unconditionally."
          }
        },
        "type": "object",
        "title": "HomeParams",
        "description": "Payload required for a Home command."
      },
      "HomeResult": {
        "properties": {},
        "type": "object",
        "title": "HomeResult",
        "description": "Result data from the execution of a Home command."
      },
      "HomeTarget": {
        "type": "string",
        "enum": [
          "pipette",
          "robot"
        ],
        "title": "HomeTarget"
      },
      "HopperDoorState": {
        "type": "string",
        "enum": [
          "closed",
          "opened"
        ],
        "title": "HopperDoorState"
      },
      "InStackerHopperLocation": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "inStackerHopper"
            ],
            "const": "inStackerHopper",
            "title": "Kind",
            "default": "inStackerHopper"
          },
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "The ID of the stacker in which this labware is."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "InStackerHopperLocation",
        "description": "The location of a labware in a stacker hopper."
      },
      "InconsistentCalibrationFailure": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "inconsistent-pipette-offset"
            ],
            "const": "inconsistent-pipette-offset",
            "title": "Kind",
            "default": "inconsistent-pipette-offset"
          },
          "offsets": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Vec3f"
            },
            "type": "object",
            "title": "Offsets"
          },
          "limit": {
            "type": "number",
            "title": "Limit"
          }
        },
        "type": "object",
        "required": [
          "offsets",
          "limit"
        ],
        "title": "InconsistentCalibrationFailure",
        "description": "Pipette offsets are very different from each other.\n\nThis indicates that one of the pipettes (though we can't tell which one)\nwas likely calibrated with its calibration probe not fully attached, and\nshould be redone. However, it's possible that the pipettes are in fact\ncalibrated correctly and their offsets look strange, so this should be\ntaken as an advisory."
      },
      "Initialize": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/initialize"
            ],
            "const": "absorbanceReader/initialize",
            "title": "Commandtype",
            "default": "absorbanceReader/initialize"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/InitializeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/InitializeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Initialize",
        "description": "A command to initialize an Absorbance Reader."
      },
      "InitializeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/initialize"
            ],
            "const": "absorbanceReader/initialize",
            "title": "Commandtype",
            "default": "absorbanceReader/initialize"
          },
          "params": {
            "$ref": "#/components/schemas/InitializeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "InitializeCreate",
        "description": "A request to execute an Absorbance Reader measurement."
      },
      "InitializeParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the absorbance reader."
          },
          "measureMode": {
            "type": "string",
            "enum": [
              "single",
              "multi"
            ],
            "title": "Measuremode",
            "description": "Initialize single or multi measurement mode."
          },
          "sampleWavelengths": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Samplewavelengths",
            "description": "Sample wavelengths in nm."
          },
          "referenceWavelength": {
            "type": "integer",
            "title": "Referencewavelength",
            "description": "Optional reference wavelength in nm."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "measureMode",
          "sampleWavelengths"
        ],
        "title": "InitializeParams",
        "description": "Input parameters to initialize an absorbance reading."
      },
      "InitializeResult": {
        "properties": {},
        "type": "object",
        "title": "InitializeResult",
        "description": "Result data from initializing an aborbance reading."
      },
      "InnerWellGeometry": {
        "properties": {
          "sections": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ConicalFrustum"
                },
                {
                  "$ref": "#/components/schemas/CuboidalFrustum"
                },
                {
                  "$ref": "#/components/schemas/SquaredConeSegment"
                },
                {
                  "$ref": "#/components/schemas/RoundedCuboidSegment"
                },
                {
                  "$ref": "#/components/schemas/SphericalSegment"
                }
              ],
              "discriminator": {
                "propertyName": "shape",
                "mapping": {
                  "conical": "#/components/schemas/ConicalFrustum",
                  "cuboidal": "#/components/schemas/CuboidalFrustum",
                  "roundedcuboid": "#/components/schemas/RoundedCuboidSegment",
                  "spherical": "#/components/schemas/SphericalSegment",
                  "squaredcone": "#/components/schemas/SquaredConeSegment"
                }
              }
            },
            "type": "array",
            "minItems": 1,
            "title": "Sections"
          }
        },
        "type": "object",
        "required": [
          "sections"
        ],
        "title": "InnerWellGeometry"
      },
      "InstrumentCalibrationData": {
        "properties": {
          "offset": {
            "$ref": "#/components/schemas/Vec3f"
          },
          "source": {
            "$ref": "#/components/schemas/SourceType"
          },
          "last_modified": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Modified"
          },
          "reasonability_check_failures": {
            "items": {
              "$ref": "#/components/schemas/InconsistentCalibrationFailure"
            },
            "type": "array",
            "title": "Reasonability Check Failures"
          }
        },
        "type": "object",
        "required": [
          "offset",
          "source",
          "reasonability_check_failures"
        ],
        "title": "InstrumentCalibrationData",
        "description": "An instrument's calibration data."
      },
      "InstrumentCalibrationStatus": {
        "properties": {
          "right": {
            "$ref": "#/components/schemas/InstrumentOffset"
          },
          "left": {
            "$ref": "#/components/schemas/InstrumentOffset"
          }
        },
        "type": "object",
        "required": [
          "right",
          "left"
        ],
        "title": "InstrumentCalibrationStatus"
      },
      "InstrumentOffset": {
        "properties": {
          "single": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Single",
            "description": "This will always be `[0, 0, 0]`. Use the `GET /calibration/pipette_offset` endpoint instead.",
            "deprecated": true
          },
          "multi": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Multi",
            "description": "This will always be `[0, 0, 0]`. Use the `GET /calibration/pipette_offset` endpoint instead.",
            "deprecated": true
          }
        },
        "type": "object",
        "required": [
          "single",
          "multi"
        ],
        "title": "InstrumentOffset"
      },
      "InstrumentOffsetVector": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "InstrumentOffsetVector",
        "description": "Instrument Offset from home position to robot deck."
      },
      "InstrumentSensorId": {
        "type": "string",
        "enum": [
          "primary",
          "secondary",
          "both"
        ],
        "title": "InstrumentSensorId",
        "description": "Primary and secondary sensor ids."
      },
      "InterfaceStatus": {
        "properties": {
          "ipAddress": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ipaddress",
            "description": "The interface IP address with CIDR subnet appended (e.g. 10.0.0.1/24)"
          },
          "macAddress": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Macaddress",
            "description": "The MAC address of this interface (at least when connected to this network - it may change due to NetworkManager's privacy functionality when disconnected or connected to a different network)"
          },
          "gatewayAddress": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gatewayaddress",
            "description": "The address of the configured gateway"
          },
          "state": {
            "type": "string",
            "title": "State",
            "description": "The state of the connection. (i.e. connected, disconnected, connection failed)"
          },
          "type": {
            "$ref": "#/components/schemas/ConnectionType",
            "description": "What kind of interface this is"
          }
        },
        "type": "object",
        "required": [
          "state",
          "type"
        ],
        "title": "InterfaceStatus",
        "description": "Status for an interface"
      },
      "InvalidDeckConfiguration": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "InvalidDeckConfiguration"
            ],
            "const": "InvalidDeckConfiguration",
            "title": "Id",
            "default": "InvalidDeckConfiguration"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Invalid Deck Configuration"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "InvalidDeckConfiguration",
        "description": "Error details for when a client supplies an invalid deck configuration."
      },
      "JogPosition": {
        "properties": {
          "vector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Vector"
          }
        },
        "type": "object",
        "required": [
          "vector"
        ],
        "title": "JogPosition"
      },
      "LabwareCalibration": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "calibrationData": {
            "$ref": "#/components/schemas/CalibrationData",
            "description": "A dictionary of calibration dataincluding tip length and offsets"
          },
          "loadName": {
            "type": "string",
            "title": "Loadname",
            "description": "The loadname of the labware definition."
          },
          "namespace": {
            "type": "string",
            "title": "Namespace",
            "description": "The namespace location of the labware definition"
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The labware definition version"
          },
          "parent": {
            "type": "string",
            "title": "Parent",
            "description": "The module associated with this offset or an empty string if the offset is associated with a slot"
          },
          "definitionHash": {
            "type": "string",
            "title": "Definitionhash",
            "description": "The sha256 hash of key labware definition details"
          }
        },
        "type": "object",
        "required": [
          "id",
          "calibrationData",
          "loadName",
          "namespace",
          "version",
          "parent",
          "definitionHash"
        ],
        "title": "LabwareCalibration",
        "description": "A model describing labware calibrations (tiplength and offset)",
        "examples": [
          {
            "calibrationData": {
              "offset": {
                "lastModified": "2020-07-10T12:40:17.05",
                "value": [
                  1,
                  -2,
                  10
                ]
              },
              "tipLength": {
                "lastModified": "2020-07-10T12:50:47.156321",
                "value": 10
              }
            },
            "loadName": "opentrons_96_tiprack_300ul",
            "namespace": "opentrons",
            "parent": "",
            "version": "1"
          },
          {
            "calibrationData": {
              "offset": {
                "lastModified": "2020-07-10T12:40:17.05",
                "value": [
                  1,
                  -2,
                  10
                ]
              },
              "tipLength": {
                "lastModified": "2020-07-10T12:50:47.156321",
                "value": 10
              }
            },
            "loadName": "corning_96_wellPlate_384ul",
            "namespace": "opentrons",
            "parent": "temperatureModuleV2",
            "version": "1"
          }
        ]
      },
      "LabwareCalibrationEndpointsRemoved": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "LabwareCalibrationEndpointsRemoved"
            ],
            "const": "LabwareCalibrationEndpointsRemoved",
            "title": "Id",
            "default": "LabwareCalibrationEndpointsRemoved"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Labware Calibration Endpoints Removed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Use the `/runs` endpoints to manage labware offsets."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4002"
          }
        },
        "type": "object",
        "title": "LabwareCalibrationEndpointsRemoved",
        "description": "An error if you try to use the deprecated Labware Calibration endpoints."
      },
      "LabwareDefinition2": {
        "properties": {
          "schemaVersion": {
            "type": "integer",
            "enum": [
              2
            ],
            "const": 2,
            "title": "Schemaversion"
          },
          "version": {
            "type": "integer",
            "minimum": 1,
            "title": "Version"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9._]+$",
            "title": "Namespace"
          },
          "metadata": {
            "$ref": "#/components/schemas/opentrons_shared_data__labware__labware_definition__Metadata"
          },
          "brand": {
            "$ref": "#/components/schemas/BrandData"
          },
          "parameters": {
            "$ref": "#/components/schemas/Parameters2"
          },
          "cornerOffsetFromSlot": {
            "$ref": "#/components/schemas/Vector"
          },
          "ordering": {
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array",
            "title": "Ordering"
          },
          "dimensions": {
            "$ref": "#/components/schemas/Dimensions"
          },
          "wells": {
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CircularWellDefinition2"
                },
                {
                  "$ref": "#/components/schemas/RectangularWellDefinition2"
                }
              ],
              "discriminator": {
                "propertyName": "shape",
                "mapping": {
                  "circular": "#/components/schemas/CircularWellDefinition2",
                  "rectangular": "#/components/schemas/RectangularWellDefinition2"
                }
              }
            },
            "type": "object",
            "title": "Wells"
          },
          "groups": {
            "items": {
              "$ref": "#/components/schemas/Group"
            },
            "type": "array",
            "title": "Groups"
          },
          "stackingOffsetWithLabware": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Vector"
            },
            "type": "object",
            "title": "Stackingoffsetwithlabware"
          },
          "stackingOffsetWithModule": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Vector"
            },
            "type": "object",
            "title": "Stackingoffsetwithmodule"
          },
          "allowedRoles": {
            "items": {
              "$ref": "#/components/schemas/LabwareRole"
            },
            "type": "array",
            "title": "Allowedroles"
          },
          "gripperOffsets": {
            "additionalProperties": {
              "$ref": "#/components/schemas/GripperOffsets"
            },
            "type": "object",
            "title": "Gripperoffsets"
          },
          "gripForce": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gripforce"
          },
          "gripHeightFromLabwareBottom": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gripheightfromlabwarebottom"
          },
          "stackLimit": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stacklimit"
          },
          "compatibleParentLabware": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Compatibleparentlabware"
          },
          "innerLabwareGeometry": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/InnerWellGeometry"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Innerlabwaregeometry"
          }
        },
        "type": "object",
        "required": [
          "schemaVersion",
          "version",
          "namespace",
          "metadata",
          "brand",
          "parameters",
          "cornerOffsetFromSlot",
          "ordering",
          "dimensions",
          "wells",
          "groups"
        ],
        "title": "LabwareDefinition2"
      },
      "LabwareDefinition3": {
        "properties": {
          "$otSharedSchema": {
            "type": "string",
            "enum": [
              "#/labware/schemas/3"
            ],
            "const": "#/labware/schemas/3",
            "title": "$Otsharedschema"
          },
          "schemaVersion": {
            "type": "integer",
            "enum": [
              3
            ],
            "const": 3,
            "title": "Schemaversion"
          },
          "version": {
            "type": "integer",
            "minimum": 1,
            "title": "Version"
          },
          "namespace": {
            "type": "string",
            "pattern": "^[a-z0-9._]+$",
            "title": "Namespace"
          },
          "metadata": {
            "$ref": "#/components/schemas/opentrons_shared_data__labware__labware_definition__Metadata"
          },
          "brand": {
            "$ref": "#/components/schemas/BrandData"
          },
          "parameters": {
            "$ref": "#/components/schemas/Parameters3"
          },
          "cornerOffsetFromSlot": {
            "$ref": "#/components/schemas/Vector"
          },
          "ordering": {
            "items": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "array",
            "title": "Ordering"
          },
          "dimensions": {
            "$ref": "#/components/schemas/Dimensions"
          },
          "wells": {
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CircularWellDefinition3"
                },
                {
                  "$ref": "#/components/schemas/RectangularWellDefinition3"
                }
              ],
              "discriminator": {
                "propertyName": "shape",
                "mapping": {
                  "circular": "#/components/schemas/CircularWellDefinition3",
                  "rectangular": "#/components/schemas/RectangularWellDefinition3"
                }
              }
            },
            "type": "object",
            "title": "Wells"
          },
          "groups": {
            "items": {
              "$ref": "#/components/schemas/Group"
            },
            "type": "array",
            "title": "Groups"
          },
          "stackingOffsetWithLabware": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Vector"
            },
            "type": "object",
            "title": "Stackingoffsetwithlabware"
          },
          "stackingOffsetWithModule": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Vector"
            },
            "type": "object",
            "title": "Stackingoffsetwithmodule"
          },
          "allowedRoles": {
            "items": {
              "$ref": "#/components/schemas/LabwareRole"
            },
            "type": "array",
            "title": "Allowedroles"
          },
          "gripperOffsets": {
            "additionalProperties": {
              "$ref": "#/components/schemas/GripperOffsets"
            },
            "type": "object",
            "title": "Gripperoffsets"
          },
          "gripForce": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gripforce"
          },
          "gripHeightFromLabwareBottom": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gripheightfromlabwarebottom"
          },
          "stackLimit": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stacklimit"
          },
          "compatibleParentLabware": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Compatibleparentlabware"
          },
          "innerLabwareGeometry": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/InnerWellGeometry"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Innerlabwaregeometry"
          }
        },
        "type": "object",
        "required": [
          "$otSharedSchema",
          "schemaVersion",
          "version",
          "namespace",
          "metadata",
          "brand",
          "parameters",
          "cornerOffsetFromSlot",
          "ordering",
          "dimensions",
          "wells",
          "groups"
        ],
        "title": "LabwareDefinition3"
      },
      "LabwareDefinitionSummary": {
        "properties": {
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The definition's unique resource identifier in the run."
          }
        },
        "type": "object",
        "required": [
          "definitionUri"
        ],
        "title": "LabwareDefinitionSummary",
        "description": "Summary of data about a created labware definition."
      },
      "LabwareMovementOffsetData": {
        "properties": {
          "pickUpOffset": {
            "$ref": "#/components/schemas/LabwareOffsetVector"
          },
          "dropOffset": {
            "$ref": "#/components/schemas/LabwareOffsetVector"
          }
        },
        "type": "object",
        "required": [
          "pickUpOffset",
          "dropOffset"
        ],
        "title": "LabwareMovementOffsetData",
        "description": "Offsets to be used during labware movement."
      },
      "LabwareMovementStrategy": {
        "type": "string",
        "enum": [
          "usingGripper",
          "manualMoveWithPause",
          "manualMoveWithoutPause"
        ],
        "title": "LabwareMovementStrategy",
        "description": "Strategy to use for labware movement."
      },
      "LabwareOffset": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique labware offset record identifier."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When this labware offset was added."
          },
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The URI for the labware's definition."
          },
          "location": {
            "$ref": "#/components/schemas/LegacyLabwareOffsetLocation",
            "description": "Where the labware is located on the robot. Deprecated and present only for backwards compatibility; cannot represent certain locations. Use locationSequence instead."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "kind",
                    "mapping": {
                      "onAddressableArea": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent",
                      "onLabware": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent",
                      "onModule": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    }
                  }
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locationsequence",
            "description": "Where the labware is located on the robot. Can represent all locations, but may not be present for older runs."
          },
          "vector": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "The offset applied to matching labware."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "definitionUri",
          "location",
          "vector"
        ],
        "title": "LabwareOffset",
        "description": "An offset that the robot adds to a pipette's position when it moves to a labware.\n\nDuring the run, if a labware is loaded whose definition URI and location\nboth match what's found here, the given offset will be added to all\npipette movements that use that labware as a reference point."
      },
      "LabwareOffsetCreate": {
        "properties": {
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The URI for the labware's definition."
          },
          "locationSequence": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent"
                }
              ],
              "discriminator": {
                "propertyName": "kind",
                "mapping": {
                  "onAddressableArea": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent",
                  "onLabware": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent",
                  "onModule": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                }
              }
            },
            "type": "array",
            "title": "Locationsequence",
            "description": "Where the labware is located on the robot."
          },
          "vector": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "The offset applied to matching labware."
          }
        },
        "type": "object",
        "required": [
          "definitionUri",
          "locationSequence",
          "vector"
        ],
        "title": "LabwareOffsetCreate",
        "description": "Create request data for a labware offset with a modern location sequence."
      },
      "LabwareOffsetVector": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "LabwareOffsetVector",
        "description": "Offset, in deck coordinates from nominal to actual position."
      },
      "LabwareRole": {
        "type": "string",
        "enum": [
          "labware",
          "fixture",
          "adapter",
          "maintenance",
          "lid",
          "system"
        ],
        "title": "LabwareRole"
      },
      "LastAnalysisPending": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "LastAnalysisPending"
            ],
            "const": "LastAnalysisPending",
            "title": "Id",
            "default": "LastAnalysisPending"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Last Analysis Still Pending."
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "LastAnalysisPending",
        "description": "An error returned when the most recent analysis of a protocol is still pending."
      },
      "LatchState": {
        "type": "string",
        "enum": [
          "closed",
          "opened"
        ],
        "title": "LatchState"
      },
      "LegacyErrorResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A human-readable message describing the error."
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error"
          }
        },
        "type": "object",
        "required": [
          "message",
          "errorCode"
        ],
        "title": "LegacyErrorResponse",
        "description": "An error response with a human readable message."
      },
      "LegacyLabwareOffsetCreate": {
        "properties": {
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The URI for the labware's definition."
          },
          "location": {
            "$ref": "#/components/schemas/LegacyLabwareOffsetLocation",
            "description": "Where the labware is located on the robot."
          },
          "vector": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "The offset applied to matching labware."
          }
        },
        "type": "object",
        "required": [
          "definitionUri",
          "location",
          "vector"
        ],
        "title": "LegacyLabwareOffsetCreate",
        "description": "Create request data for a labware offset with a legacy location field."
      },
      "LegacyLabwareOffsetLocation": {
        "properties": {
          "slotName": {
            "$ref": "#/components/schemas/DeckSlotName",
            "description": "The deck slot where the protocol will load the labware. Or, if the protocol will load the labware on a module, the deck slot where the protocol will load that module.\n\nThe plain numbers like `\"5\"` are for the OT-2, and the coordinates like `\"C2\"` are for the Flex.\n\nWhen you provide one of these values, you can use either style. It will automatically be converted to match the robot.\n\nWhen one of these values is returned, it will always match the robot."
          },
          "moduleModel": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleModel"
              },
              {
                "type": "null"
              }
            ],
            "description": "The model of the module that the labware will be loaded onto, if applicable.\n\nBecause of module compatibility, the model that the protocol requests may not be exactly the same as what it will find physically connected during execution. For this labware offset to apply, this field must be the *requested* model, not the connected one. You can retrieve this from a `loadModule` command's `params.model` in the protocol's analysis."
          },
          "definitionUri": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Definitionuri",
            "description": "The definition URI of a labware that a labware can be loaded onto, if applicable.\n\nThis can be combined with moduleModel if the labware is loaded on top of an adapter that is loaded on a module."
          }
        },
        "type": "object",
        "required": [
          "slotName"
        ],
        "title": "LegacyLabwareOffsetLocation",
        "description": "Parameters describing when a given offset may apply to a given labware load."
      },
      "Links": {
        "properties": {
          "restart": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Restart",
            "description": "A URI to POST to restart the robot. If this is present, it must be requested for any settings changes to take effect"
          }
        },
        "type": "object",
        "title": "Links"
      },
      "Liquid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "displayName": {
            "type": "string",
            "title": "Displayname"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "displayColor": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HexColor"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "displayName",
          "description"
        ],
        "title": "Liquid",
        "description": "Payload required to create a liquid."
      },
      "LiquidClassRecord": {
        "properties": {
          "tiprack": {
            "type": "string",
            "title": "Tiprack",
            "description": "The name of tiprack whose tip will be used when handling this specific liquid class with this pipette"
          },
          "aspirate": {
            "$ref": "#/components/schemas/AspirateProperties",
            "description": "Aspirate parameters for this tip type."
          },
          "singleDispense": {
            "$ref": "#/components/schemas/SingleDispenseProperties",
            "description": "Single dispense parameters for this tip type."
          },
          "multiDispense": {
            "$ref": "#/components/schemas/MultiDispenseProperties",
            "title": "Multidispense",
            "description": "Optional multi-dispense parameters for this tip type."
          },
          "liquidClassName": {
            "type": "string",
            "title": "Liquidclassname",
            "description": "Identifier for the liquid of this liquid class, e.g. glycerol50."
          },
          "pipetteModel": {
            "type": "string",
            "title": "Pipettemodel",
            "description": "Identifier for the pipette of this liquid class."
          }
        },
        "type": "object",
        "required": [
          "tiprack",
          "aspirate",
          "singleDispense",
          "liquidClassName",
          "pipetteModel"
        ],
        "title": "LiquidClassRecord",
        "description": "LiquidClassRecord is our internal representation of an (immutable) liquid class.\n\nConceptually, a liquid class record is the tuple (name, pipette, tip, transfer properties).\nWe consider two liquid classes to be the same if every entry in that tuple is the same; and liquid\nclasses are different if any entry in the tuple is different.\n\nThis class defines the tuple via inheritance so that we can reuse the definitions from shared_data."
      },
      "LiquidClassRecordWithId": {
        "properties": {
          "tiprack": {
            "type": "string",
            "title": "Tiprack",
            "description": "The name of tiprack whose tip will be used when handling this specific liquid class with this pipette"
          },
          "aspirate": {
            "$ref": "#/components/schemas/AspirateProperties",
            "description": "Aspirate parameters for this tip type."
          },
          "singleDispense": {
            "$ref": "#/components/schemas/SingleDispenseProperties",
            "description": "Single dispense parameters for this tip type."
          },
          "multiDispense": {
            "$ref": "#/components/schemas/MultiDispenseProperties",
            "title": "Multidispense",
            "description": "Optional multi-dispense parameters for this tip type."
          },
          "liquidClassName": {
            "type": "string",
            "title": "Liquidclassname",
            "description": "Identifier for the liquid of this liquid class, e.g. glycerol50."
          },
          "pipetteModel": {
            "type": "string",
            "title": "Pipettemodel",
            "description": "Identifier for the pipette of this liquid class."
          },
          "liquidClassId": {
            "type": "string",
            "title": "Liquidclassid",
            "description": "Unique identifier for this liquid class."
          }
        },
        "type": "object",
        "required": [
          "tiprack",
          "aspirate",
          "singleDispense",
          "liquidClassName",
          "pipetteModel",
          "liquidClassId"
        ],
        "title": "LiquidClassRecordWithId",
        "description": "A LiquidClassRecord with its ID, for use in summary lists."
      },
      "LiquidClassTouchTipParams": {
        "properties": {
          "zOffset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Zoffset",
            "description": "Offset from the top of the well for touch-tip, in millimeters."
          },
          "mmToEdge": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Mmtoedge",
            "description": "Offset away from the the well edge, in millimeters."
          },
          "speed": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ],
            "title": "Speed",
            "description": "Touch-tip speed, in millimeters per second."
          }
        },
        "type": "object",
        "required": [
          "zOffset",
          "mmToEdge",
          "speed"
        ],
        "title": "LiquidClassTouchTipParams",
        "description": "Parameters for touch-tip."
      },
      "LiquidHandlingWellLocation": {
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/WellOrigin",
            "default": "top"
          },
          "offset": {
            "$ref": "#/components/schemas/WellOffset"
          },
          "volumeOffset": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string",
                "enum": [
                  "operationVolume"
                ],
                "const": "operationVolume"
              }
            ],
            "title": "Volumeoffset",
            "description": "A volume of liquid, in L, to offset the z-axis offset. When \"operationVolume\" is specified, this volume is pulled from the command volume parameter.",
            "default": 0
          }
        },
        "type": "object",
        "title": "LiquidHandlingWellLocation",
        "description": "A relative location in reference to a well's location.\n\nTo be used with commands that handle liquids."
      },
      "LiquidNotFoundError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "liquidNotFound"
            ],
            "const": "liquidNotFound",
            "title": "Errortype",
            "default": "liquidNotFound"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "2017"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Liquid Not Found"
          },
          "errorInfo": {
            "type": "object",
            "title": "Errorinfo",
            "description": "Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n",
            "default": {}
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "LiquidNotFoundError",
        "description": "Returned when no liquid is detected during the liquid probe process/move.\n\nAfter a failed probing, the pipette returns to the process start position."
      },
      "LiquidProbe": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "liquidProbe"
            ],
            "const": "liquidProbe",
            "title": "Commandtype",
            "default": "liquidProbe"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LiquidProbeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LiquidProbeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LiquidNotFoundError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LiquidProbe",
        "description": "The model for a full `liquidProbe` command."
      },
      "LiquidProbeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "liquidProbe"
            ],
            "const": "liquidProbe",
            "title": "Commandtype",
            "default": "liquidProbe"
          },
          "params": {
            "$ref": "#/components/schemas/LiquidProbeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LiquidProbeCreate",
        "description": "The request model for a `liquidProbe` command."
      },
      "LiquidProbeParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/WellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "pipetteId"
        ],
        "title": "LiquidProbeParams",
        "description": "Parameters required for a `liquidProbe` command."
      },
      "LiquidProbeResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "z_position": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatedProbeResult"
              },
              {
                "type": "number"
              }
            ],
            "title": "Z Position",
            "description": "The Z coordinate, in mm, of the found liquid in deck space."
          }
        },
        "type": "object",
        "required": [
          "z_position"
        ],
        "title": "LiquidProbeResult",
        "description": "Result data from the execution of a `liquidProbe` command."
      },
      "LoadLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadLabware"
            ],
            "const": "loadLabware",
            "title": "Commandtype",
            "default": "loadLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadLabware",
        "description": "Load labware command resource model."
      },
      "LoadLabwareByDefinitionRequestData": {
        "properties": {
          "tiprackDefinition": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiprackdefinition",
            "description": "The tiprack definition to load into a user flow"
          }
        },
        "type": "object",
        "title": "LoadLabwareByDefinitionRequestData"
      },
      "LoadLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadLabware"
            ],
            "const": "loadLabware",
            "title": "Commandtype",
            "default": "loadLabware"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadLabwareCreate",
        "description": "Load labware command creation request."
      },
      "LoadLabwareParams": {
        "properties": {
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "Location the labware should be loaded into."
          },
          "loadName": {
            "type": "string",
            "title": "Loadname",
            "description": "Name used to reference a labware definition."
          },
          "namespace": {
            "type": "string",
            "title": "Namespace",
            "description": "The namespace the labware definition belongs to."
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The labware definition version."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "An optional ID to assign to this labware. If None, an ID will be generated."
          },
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "An optional user-specified display name or label for this labware."
          }
        },
        "type": "object",
        "required": [
          "location",
          "loadName",
          "namespace",
          "version"
        ],
        "title": "LoadLabwareParams",
        "description": "Payload required to load a labware into a slot."
      },
      "LoadLabwareResult": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The id of the labware."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locationsequence",
            "description": "The full location down to the deck on which this labware exists."
          },
          "offsetId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offsetid",
            "description": "An ID referencing the labware offset that will apply to this labware in this location."
          },
          "definition": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LabwareDefinition2"
              },
              {
                "$ref": "#/components/schemas/LabwareDefinition3"
              }
            ],
            "title": "Definition",
            "description": "The full definition data for this labware.",
            "discriminator": {
              "propertyName": "schemaVersion",
              "mapping": {
                "2": "#/components/schemas/LabwareDefinition2",
                "3": "#/components/schemas/LabwareDefinition3"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "definition"
        ],
        "title": "LoadLabwareResult",
        "description": "Result data from the execution of a LoadLabware command."
      },
      "LoadLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadLid"
            ],
            "const": "loadLid",
            "title": "Commandtype",
            "default": "loadLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadLid",
        "description": "Load lid command resource model."
      },
      "LoadLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadLid"
            ],
            "const": "loadLid",
            "title": "Commandtype",
            "default": "loadLid"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadLidCreate",
        "description": "Load lid command creation request."
      },
      "LoadLidParams": {
        "properties": {
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "Labware the lid should be loaded onto."
          },
          "loadName": {
            "type": "string",
            "title": "Loadname",
            "description": "Name used to reference a lid labware definition."
          },
          "namespace": {
            "type": "string",
            "title": "Namespace",
            "description": "The namespace the lid labware definition belongs to."
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The lid labware definition version."
          }
        },
        "type": "object",
        "required": [
          "location",
          "loadName",
          "namespace",
          "version"
        ],
        "title": "LoadLidParams",
        "description": "Payload required to load a lid onto a labware."
      },
      "LoadLidResult": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The id of the labware."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locationsequence",
            "description": "The full location down to the deck on which this labware exists."
          },
          "definition": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LabwareDefinition2"
              },
              {
                "$ref": "#/components/schemas/LabwareDefinition3"
              }
            ],
            "title": "Definition",
            "description": "The full definition data for this lid labware.",
            "discriminator": {
              "propertyName": "schemaVersion",
              "mapping": {
                "2": "#/components/schemas/LabwareDefinition2",
                "3": "#/components/schemas/LabwareDefinition3"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "definition"
        ],
        "title": "LoadLidResult",
        "description": "Result data from the execution of a LoadLabware command."
      },
      "LoadLidStack": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadLidStack"
            ],
            "const": "loadLidStack",
            "title": "Commandtype",
            "default": "loadLidStack"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLidStackParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLidStackResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadLidStack",
        "description": "Load lid stack command resource model."
      },
      "LoadLidStackCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadLidStack"
            ],
            "const": "loadLidStack",
            "title": "Commandtype",
            "default": "loadLidStack"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLidStackParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadLidStackCreate",
        "description": "Load lid stack command creation request."
      },
      "LoadLidStackParams": {
        "properties": {
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "Location the lid stack should be loaded into."
          },
          "loadName": {
            "type": "string",
            "title": "Loadname",
            "description": "Name used to reference a lid labware definition."
          },
          "namespace": {
            "type": "string",
            "title": "Namespace",
            "description": "The namespace the lid labware definition belongs to."
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The lid labware definition version."
          },
          "stackLabwareId": {
            "type": "string",
            "title": "Stacklabwareid",
            "description": "An optional ID to assign to the lid stack labware object created.If None, an ID will be generated."
          },
          "labwareIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Labwareids",
            "description": "An optional list of IDs to assign to the lids in the stack.If None, an ID will be generated."
          },
          "quantity": {
            "type": "integer",
            "title": "Quantity",
            "description": "The quantity of lids to load."
          }
        },
        "type": "object",
        "required": [
          "location",
          "loadName",
          "namespace",
          "version",
          "quantity"
        ],
        "title": "LoadLidStackParams",
        "description": "Payload required to load a lid stack onto a location."
      },
      "LoadLidStackResult": {
        "properties": {
          "stackLabwareId": {
            "type": "string",
            "title": "Stacklabwareid",
            "description": "An ID to reference the lid stack labware object created."
          },
          "labwareIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Labwareids",
            "description": "A list of lid labware IDs to reference the lids in this stack by. The first ID is the bottom of the stack."
          },
          "definition": {
            "anyOf": [
              {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/LabwareDefinition2"
                  },
                  {
                    "$ref": "#/components/schemas/LabwareDefinition3"
                  }
                ],
                "discriminator": {
                  "propertyName": "schemaVersion",
                  "mapping": {
                    "2": "#/components/schemas/LabwareDefinition2",
                    "3": "#/components/schemas/LabwareDefinition3"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Definition",
            "description": "The full definition data for this lid labware."
          },
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "The Location that the stack of lid labware has been loaded."
          },
          "lidStackDefinition": {
            "anyOf": [
              {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/LabwareDefinition2"
                  },
                  {
                    "$ref": "#/components/schemas/LabwareDefinition3"
                  }
                ],
                "discriminator": {
                  "propertyName": "schemaVersion",
                  "mapping": {
                    "2": "#/components/schemas/LabwareDefinition2",
                    "3": "#/components/schemas/LabwareDefinition3"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidstackdefinition",
            "description": "The definition of the lid stack object. Optional for backwards-compatibility."
          },
          "stackLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Stacklocationsequence",
            "description": "The location sequence for the lid stack labware object created."
          },
          "locationSequences": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                      },
                      {
                        "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                      },
                      {
                        "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                      },
                      {
                        "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                      },
                      {
                        "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                      },
                      {
                        "$ref": "#/components/schemas/InStackerHopperLocation"
                      }
                    ]
                  },
                  "type": "array"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locationsequences",
            "description": "The location sequences for the lids just loaded into the stack. These are in the same order as labwareIds."
          }
        },
        "type": "object",
        "required": [
          "stackLabwareId",
          "labwareIds",
          "definition",
          "location"
        ],
        "title": "LoadLidStackResult",
        "description": "Result data from the execution of a LoadLidStack command."
      },
      "LoadLiquid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadLiquid"
            ],
            "const": "loadLiquid",
            "title": "Commandtype",
            "default": "loadLiquid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLiquidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLiquidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadLiquid",
        "description": "Load liquid command resource model."
      },
      "LoadLiquidClass": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadLiquidClass"
            ],
            "const": "loadLiquidClass",
            "title": "Commandtype",
            "default": "loadLiquidClass"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLiquidClassParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLiquidClassResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadLiquidClass",
        "description": "Load Liquid Class command resource model."
      },
      "LoadLiquidClassCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadLiquidClass"
            ],
            "const": "loadLiquidClass",
            "title": "Commandtype",
            "default": "loadLiquidClass"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLiquidClassParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadLiquidClassCreate",
        "description": "Load Liquid Class command creation request."
      },
      "LoadLiquidClassParams": {
        "properties": {
          "liquidClassId": {
            "type": "string",
            "title": "Liquidclassid",
            "description": "Unique identifier for the liquid class to store. If you do not supply a liquidClassId, we will generate one."
          },
          "liquidClassRecord": {
            "$ref": "#/components/schemas/LiquidClassRecord",
            "description": "The liquid class to store."
          }
        },
        "type": "object",
        "required": [
          "liquidClassRecord"
        ],
        "title": "LoadLiquidClassParams",
        "description": "The liquid class transfer properties to store."
      },
      "LoadLiquidClassResult": {
        "properties": {
          "liquidClassId": {
            "type": "string",
            "title": "Liquidclassid",
            "description": "The ID for the liquid class that was loaded, either the one you supplied or the one we generated."
          }
        },
        "type": "object",
        "required": [
          "liquidClassId"
        ],
        "title": "LoadLiquidClassResult",
        "description": "Result from execution of LoadLiquidClass command."
      },
      "LoadLiquidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadLiquid"
            ],
            "const": "loadLiquid",
            "title": "Commandtype",
            "default": "loadLiquid"
          },
          "params": {
            "$ref": "#/components/schemas/LoadLiquidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadLiquidCreate",
        "description": "Load liquid command creation request."
      },
      "LoadLiquidParams": {
        "properties": {
          "liquidId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "enum": [
                  "EMPTY"
                ],
                "const": "EMPTY"
              }
            ],
            "title": "Liquidid",
            "description": "Unique identifier of the liquid to load. If this is the sentinel value EMPTY, all values of volumeByWell must be 0."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Unique identifier of labware to load liquid into."
          },
          "volumeByWell": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Volumebywell",
            "description": "Volume of liquid, in L, loaded into each well by name, in this labware. If the liquid id is the sentinel value EMPTY, all volumes must be 0."
          }
        },
        "type": "object",
        "required": [
          "liquidId",
          "labwareId",
          "volumeByWell"
        ],
        "title": "LoadLiquidParams",
        "description": "Payload required to load a liquid into a well."
      },
      "LoadLiquidResult": {
        "properties": {},
        "type": "object",
        "title": "LoadLiquidResult",
        "description": "Result data from the execution of a LoadLiquid command."
      },
      "LoadModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadModule"
            ],
            "const": "loadModule",
            "title": "Commandtype",
            "default": "loadModule"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadModuleParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadModuleResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadModule",
        "description": "The model for a load module command."
      },
      "LoadModuleCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadModule"
            ],
            "const": "loadModule",
            "title": "Commandtype",
            "default": "loadModule"
          },
          "params": {
            "$ref": "#/components/schemas/LoadModuleParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadModuleCreate",
        "description": "The model for a creation request for a load module command."
      },
      "LoadModuleParams": {
        "properties": {
          "model": {
            "$ref": "#/components/schemas/ModuleModel",
            "description": "The model name of the module to load.\n\nProtocol Engine will look for a connected module that either exactly matches this one, or is compatible.\n\n For example, if you request a `temperatureModuleV1` here, Protocol Engine might load a `temperatureModuleV1` or a `temperatureModuleV2`.\n\n The model that it finds connected will be available through `result.model`."
          },
          "location": {
            "$ref": "#/components/schemas/DeckSlotLocation",
            "description": "The location into which this module should be loaded.\n\nFor the Thermocycler Module, which occupies multiple deck slots, this should be the front-most occupied slot (normally slot 7)."
          },
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "An optional ID to assign to this module. If None, an ID will be generated."
          }
        },
        "type": "object",
        "required": [
          "model",
          "location"
        ],
        "title": "LoadModuleParams",
        "description": "Payload required to load a module."
      },
      "LoadModuleResult": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "An ID to reference this module in subsequent commands."
          },
          "definition": {
            "$ref": "#/components/schemas/ModuleDefinition",
            "description": "The definition of the connected module. This field is an implementation detail. We might change or remove it without warning. Do not access it or rely on it being present.",
            "deprecated": true
          },
          "model": {
            "$ref": "#/components/schemas/ModuleModel",
            "description": "The hardware model of the connected module. This can be different from the exact model that this command requested. See `params.model`.\n\nThis field is only meaningful in the run's actual execution, not in the protocol's analysis. In analysis, it will be an arbitrary placeholder."
          },
          "serialNumber": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Serialnumber",
            "description": "Hardware serial number of the connected module. Will be `None` if a module is not electrically connected to the robot (like the Magnetic Block)."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "definition",
          "model"
        ],
        "title": "LoadModuleResult",
        "description": "The results of loading a module."
      },
      "LoadPipette": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "loadPipette"
            ],
            "const": "loadPipette",
            "title": "Commandtype",
            "default": "loadPipette"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/LoadPipetteParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadPipetteResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "LoadPipette",
        "description": "Load pipette command model."
      },
      "LoadPipetteCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "loadPipette"
            ],
            "const": "loadPipette",
            "title": "Commandtype",
            "default": "loadPipette"
          },
          "params": {
            "$ref": "#/components/schemas/LoadPipetteParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "LoadPipetteCreate",
        "description": "Load pipette command creation request model."
      },
      "LoadPipetteParams": {
        "properties": {
          "pipetteName": {
            "$ref": "#/components/schemas/PipetteNameType",
            "description": "The load name of the pipette to be required."
          },
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "description": "The mount the pipette should be present on."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "An optional ID to assign to this pipette. If None, an ID will be generated."
          },
          "tipOverlapNotAfterVersion": {
            "type": "string",
            "title": "Tipoverlapnotafterversion",
            "description": "A version of tip overlap data to not exceed. The highest-versioned tip overlap data that does not exceed this version will be used. Versions are expressed as vN where N is an integer, counting up from v0. If None, the current highest version will be used."
          },
          "liquidPresenceDetection": {
            "type": "boolean",
            "title": "Liquidpresencedetection",
            "description": "Enable liquid presence detection for this pipette. Defaults to False."
          }
        },
        "type": "object",
        "required": [
          "pipetteName",
          "mount"
        ],
        "title": "LoadPipetteParams",
        "description": "Payload needed to load a pipette on to a mount."
      },
      "LoadPipetteResult": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "An ID to reference this pipette in subsequent commands."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "LoadPipetteResult",
        "description": "Result data for executing a LoadPipette."
      },
      "LoadedLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "loadName": {
            "type": "string",
            "title": "Loadname"
          },
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri"
          },
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              },
              {
                "$ref": "#/components/schemas/InStackerHopperLocation"
              }
            ],
            "title": "Location",
            "description": "The labware's current location."
          },
          "lid_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lid Id",
            "description": "Labware ID of a Lid currently loaded on top of the labware."
          },
          "offsetId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offsetid",
            "description": "An ID referencing the labware offset that applies to this labware placement. Null or undefined means no offset was provided for this load, so the default of (0, 0, 0) will be used."
          },
          "displayName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Displayname",
            "description": "A user-specified display name for this labware, if provided."
          }
        },
        "type": "object",
        "required": [
          "id",
          "loadName",
          "definitionUri",
          "location"
        ],
        "title": "LoadedLabware",
        "description": "A labware that has been loaded."
      },
      "LoadedModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "model": {
            "$ref": "#/components/schemas/ModuleModel"
          },
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "type": "null"
              }
            ]
          },
          "serialNumber": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Serialnumber"
          }
        },
        "type": "object",
        "required": [
          "id",
          "model"
        ],
        "title": "LoadedModule",
        "description": "A module that has been loaded."
      },
      "LoadedPipette": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "pipetteName": {
            "$ref": "#/components/schemas/PipetteNameType"
          },
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType"
          }
        },
        "type": "object",
        "required": [
          "id",
          "pipetteName",
          "mount"
        ],
        "title": "LoadedPipette",
        "description": "A pipette that has been loaded."
      },
      "LogFormat": {
        "type": "string",
        "enum": [
          "text",
          "json"
        ],
        "title": "LogFormat",
        "description": "Format to use for log records"
      },
      "LogIdentifier": {
        "type": "string",
        "enum": [
          "api.log",
          "serial.log",
          "can_bus.log",
          "server.log",
          "combined_api_server.log",
          "update_server.log",
          "touchscreen.log"
        ],
        "title": "LogIdentifier",
        "description": "Identifier of the log"
      },
      "LogLevel": {
        "properties": {
          "log_level": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogLevels"
              },
              {
                "type": "null"
              }
            ],
            "description": "The value to set (conforming to Python log levels)"
          }
        },
        "type": "object",
        "title": "LogLevel"
      },
      "LogLevels": {
        "type": "string",
        "enum": [
          "debug",
          "info",
          "warning",
          "error"
        ],
        "title": "LogLevels"
      },
      "MagneticModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "magneticModuleType"
            ],
            "const": "magneticModuleType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "magneticModuleV1",
              "magneticModuleV2"
            ],
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/MagneticModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "MagneticModule",
        "description": "An attached Magnetic Module."
      },
      "MagneticModuleData": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/MagneticStatus"
          },
          "engaged": {
            "type": "boolean",
            "title": "Engaged",
            "description": "Whether the magnets are raised or lowered"
          },
          "height": {
            "type": "number",
            "title": "Height",
            "description": "The height of the top of the magnets relative to the labware base, in millimeters."
          }
        },
        "type": "object",
        "required": [
          "status",
          "engaged",
          "height"
        ],
        "title": "MagneticModuleData",
        "description": "Live data from an attached Magnetic Module."
      },
      "MagneticStatus": {
        "type": "string",
        "enum": [
          "engaged",
          "disengaged"
        ],
        "title": "MagneticStatus"
      },
      "MaintenancePosition": {
        "type": "string",
        "enum": [
          "attachPlate",
          "attachInstrument"
        ],
        "title": "MaintenancePosition",
        "description": "Maintenance position options."
      },
      "MaintenanceRun": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique run identifier."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the run was created"
          },
          "status": {
            "$ref": "#/components/schemas/EngineStatus",
            "description": "Execution status of the run"
          },
          "current": {
            "type": "boolean",
            "title": "Current",
            "description": "Whether this run is currently controlling the robot. There can be, at most, one current run."
          },
          "actions": {
            "items": {},
            "type": "array",
            "title": "Actions",
            "description": " This is currently always an empty list, and is provided for symmetry with non-maintenance runs. Non-maintenance runs let you issue actions with `POST /runs/{id}/actions`, but there is currently no equivalent endpoint for maintenance runs."
          },
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Errors",
            "description": "The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element."
          },
          "hasEverEnteredErrorRecovery": {
            "type": "boolean",
            "title": "Haseverenterederrorrecovery",
            "description": "Whether the run has entered error recovery."
          },
          "pipettes": {
            "items": {
              "$ref": "#/components/schemas/LoadedPipette"
            },
            "type": "array",
            "title": "Pipettes",
            "description": "Pipettes that have been loaded into the run."
          },
          "modules": {
            "items": {
              "$ref": "#/components/schemas/LoadedModule"
            },
            "type": "array",
            "title": "Modules",
            "description": "Modules that have been loaded into the run."
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/LoadedLabware"
            },
            "type": "array",
            "title": "Labware",
            "description": "Labware that has been loaded into the run."
          },
          "liquids": {
            "items": {
              "$ref": "#/components/schemas/Liquid"
            },
            "type": "array",
            "title": "Liquids",
            "description": "Liquids loaded to the run."
          },
          "liquidClasses": {
            "items": {
              "$ref": "#/components/schemas/LiquidClassRecordWithId"
            },
            "type": "array",
            "title": "Liquidclasses",
            "description": "Liquid classes loaded to the run."
          },
          "labwareOffsets": {
            "items": {
              "$ref": "#/components/schemas/LabwareOffset"
            },
            "type": "array",
            "title": "Labwareoffsets",
            "description": "Labware offsets to apply as labware are loaded."
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Run completed at timestamp."
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Run started at timestamp."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "status",
          "current",
          "actions",
          "errors",
          "hasEverEnteredErrorRecovery",
          "pipettes",
          "modules",
          "labware",
          "liquids",
          "liquidClasses",
          "labwareOffsets"
        ],
        "title": "MaintenanceRun",
        "description": "Maintenance run resource model."
      },
      "MaintenanceRunCreate": {
        "properties": {
          "labwareOffsets": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LegacyLabwareOffsetCreate"
                },
                {
                  "$ref": "#/components/schemas/LabwareOffsetCreate"
                }
              ]
            },
            "type": "array",
            "title": "Labwareoffsets",
            "description": "Labware offsets to apply as labware are loaded."
          }
        },
        "type": "object",
        "title": "MaintenanceRunCreate",
        "description": "Create request data for a new maintenance run."
      },
      "MatchCriteria": {
        "properties": {
          "command": {
            "$ref": "#/components/schemas/CommandMatcher",
            "description": "The command and error types that this rule applies to."
          }
        },
        "type": "object",
        "required": [
          "command"
        ],
        "title": "MatchCriteria",
        "description": "The criteria that this rule will attempt to match."
      },
      "MatrixType": {
        "type": "string",
        "enum": [
          "affine",
          "attitude"
        ],
        "title": "MatrixType",
        "description": "The deck calibration matrix type"
      },
      "MixParams": {
        "properties": {
          "repetitions": {
            "type": "integer",
            "minimum": 0,
            "title": "Repetitions",
            "description": "Number of mixing repetitions. 0 is valid, but no mixing will occur."
          },
          "volume": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "number",
                "exclusiveMinimum": 0
              }
            ],
            "title": "Volume",
            "description": "Volume used for mixing, in microliters."
          }
        },
        "type": "object",
        "required": [
          "repetitions",
          "volume"
        ],
        "title": "MixParams",
        "description": "Parameters for mix."
      },
      "MixProperties": {
        "properties": {
          "enable": {
            "type": "boolean",
            "title": "Enable",
            "description": "Whether mix is enabled."
          },
          "params": {
            "$ref": "#/components/schemas/MixParams",
            "title": "Params",
            "description": "Parameters for the mix function."
          }
        },
        "type": "object",
        "required": [
          "enable"
        ],
        "title": "MixProperties",
        "description": "Mixing properties."
      },
      "ModuleCalibrationData": {
        "properties": {
          "offset": {
            "$ref": "#/components/schemas/Vec3f"
          },
          "slot": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Slot"
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SourceType"
              },
              {
                "type": "null"
              }
            ]
          },
          "last_modified": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Modified"
          }
        },
        "type": "object",
        "required": [
          "offset"
        ],
        "title": "ModuleCalibrationData",
        "description": "A module's calibration data."
      },
      "ModuleCalibrationPoint": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "ModuleCalibrationPoint",
        "description": "Calibration Point type for module definition."
      },
      "ModuleDefinition": {
        "properties": {
          "otSharedSchema": {
            "type": "string",
            "title": "Otsharedschema",
            "description": "The current schema.",
            "default": "module/schemas/2"
          },
          "moduleType": {
            "$ref": "#/components/schemas/ModuleType",
            "description": "Module type (Temperature/Magnetic/Thermocycler)"
          },
          "model": {
            "$ref": "#/components/schemas/ModuleModel",
            "description": "Model name of the module"
          },
          "labwareOffset": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "Labware offset in x, y, z."
          },
          "dimensions": {
            "$ref": "#/components/schemas/ModuleDimensions",
            "description": "Module dimension"
          },
          "calibrationPoint": {
            "$ref": "#/components/schemas/ModuleCalibrationPoint",
            "description": "Calibration point of module."
          },
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display name."
          },
          "quirks": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Quirks",
            "description": "Module quirks"
          },
          "slotTransforms": {
            "type": "object",
            "title": "Slottransforms",
            "description": "Dictionary of transforms for each slot."
          },
          "compatibleWith": {
            "items": {
              "$ref": "#/components/schemas/ModuleModel"
            },
            "type": "array",
            "title": "Compatiblewith",
            "description": "List of module models this model is compatible with."
          },
          "gripperOffsets": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/LabwareMovementOffsetData"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gripperoffsets",
            "description": "Offsets to use for labware movement using gripper"
          }
        },
        "type": "object",
        "required": [
          "moduleType",
          "model",
          "labwareOffset",
          "dimensions",
          "calibrationPoint",
          "displayName",
          "quirks",
          "slotTransforms",
          "compatibleWith"
        ],
        "title": "ModuleDefinition",
        "description": "A module definition conforming to module definition schema v3."
      },
      "ModuleDimensions": {
        "properties": {
          "bareOverallHeight": {
            "type": "number",
            "title": "Bareoverallheight"
          },
          "overLabwareHeight": {
            "type": "number",
            "title": "Overlabwareheight"
          },
          "lidHeight": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidheight"
          },
          "maxStackerFillHeight": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxstackerfillheight"
          },
          "maxStackerRetrievableHeight": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxstackerretrievableheight"
          }
        },
        "type": "object",
        "required": [
          "bareOverallHeight",
          "overLabwareHeight"
        ],
        "title": "ModuleDimensions",
        "description": "Dimension type for modules."
      },
      "ModuleLocation": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "The ID of a loaded module from a prior `loadModule` command."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "ModuleLocation",
        "description": "The location of something placed atop a hardware module."
      },
      "ModuleModel": {
        "type": "string",
        "enum": [
          "temperatureModuleV1",
          "temperatureModuleV2",
          "magneticModuleV1",
          "magneticModuleV2",
          "thermocyclerModuleV1",
          "thermocyclerModuleV2",
          "heaterShakerModuleV1",
          "magneticBlockV1",
          "absorbanceReaderV1",
          "flexStackerModuleV1"
        ],
        "title": "ModuleModel",
        "description": "All available modules' models."
      },
      "ModuleOffsetVector": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "ModuleOffsetVector",
        "description": "Offset, in deck coordinates, from nominal to actual position of labware on a module."
      },
      "ModuleType": {
        "type": "string",
        "enum": [
          "thermocyclerModuleType",
          "temperatureModuleType",
          "magneticModuleType",
          "heaterShakerModuleType",
          "magneticBlockType",
          "absorbanceReaderType",
          "flexStackerModuleType"
        ],
        "title": "ModuleType"
      },
      "MotionTarget": {
        "type": "string",
        "enum": [
          "pipette",
          "mount"
        ],
        "title": "MotionTarget",
        "description": "What should be moved. If mount, move the nominal position of the mount;\nif pipette, move the nozzle of the pipette"
      },
      "MotorAxis": {
        "type": "string",
        "enum": [
          "x",
          "y",
          "leftZ",
          "rightZ",
          "leftPlunger",
          "rightPlunger",
          "extensionZ",
          "extensionJaw",
          "axis96ChannelCam"
        ],
        "title": "MotorAxis",
        "description": "Motor axis on which to issue a home command."
      },
      "MotorName": {
        "type": "string",
        "enum": [
          "x",
          "y",
          "z_l",
          "z_r",
          "z_g",
          "p_l",
          "p_r",
          "q",
          "g",
          "z",
          "a",
          "b",
          "c"
        ],
        "title": "MotorName"
      },
      "Mount": {
        "type": "string",
        "enum": [
          "right",
          "left"
        ],
        "title": "Mount"
      },
      "MoveAxesRelative": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveAxesRelative"
            ],
            "const": "robot/moveAxesRelative",
            "title": "Commandtype",
            "default": "robot/moveAxesRelative"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveAxesRelativeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveAxesRelativeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveAxesRelative",
        "description": "MoveAxesRelative command model."
      },
      "MoveAxesRelativeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveAxesRelative"
            ],
            "const": "robot/moveAxesRelative",
            "title": "Commandtype",
            "default": "robot/moveAxesRelative"
          },
          "params": {
            "$ref": "#/components/schemas/MoveAxesRelativeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveAxesRelativeCreate",
        "description": "MoveAxesRelative command request model."
      },
      "MoveAxesRelativeParams": {
        "properties": {
          "axis_map": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Axis Map",
            "description": "A dictionary mapping axes to relative movements in mm."
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "The max velocity to move the axes at. Will fall to hardware defaults if none provided."
          }
        },
        "type": "object",
        "required": [
          "axis_map"
        ],
        "title": "MoveAxesRelativeParams",
        "description": "Payload required to move axes relative to position."
      },
      "MoveAxesRelativeResult": {
        "properties": {
          "position": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Position",
            "description": "The position of all axes on the robot. If no mount was provided, the last moved mount is used to determine the location.",
            "default": {
              "x": 0,
              "y": 0,
              "leftZ": 0,
              "rightZ": 0,
              "leftPlunger": 0,
              "rightPlunger": 0,
              "extensionZ": 0,
              "extensionJaw": 0,
              "axis96ChannelCam": 0
            }
          }
        },
        "type": "object",
        "title": "MoveAxesRelativeResult",
        "description": "Result data from the execution of a MoveAxesRelative command."
      },
      "MoveAxesTo": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveAxesTo"
            ],
            "const": "robot/moveAxesTo",
            "title": "Commandtype",
            "default": "robot/moveAxesTo"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveAxesToParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveAxesToResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveAxesTo",
        "description": "MoveAxesTo command model."
      },
      "MoveAxesToCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveAxesTo"
            ],
            "const": "robot/moveAxesTo",
            "title": "Commandtype",
            "default": "robot/moveAxesTo"
          },
          "params": {
            "$ref": "#/components/schemas/MoveAxesToParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveAxesToCreate",
        "description": "MoveAxesTo command request model."
      },
      "MoveAxesToParams": {
        "properties": {
          "axis_map": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Axis Map",
            "description": "The specified axes to move to an absolute deck position with."
          },
          "critical_point": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Critical Point",
            "description": "The critical point to move the mount with."
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "The max velocity to move the axes at. Will fall to hardware defaults if none provided."
          }
        },
        "type": "object",
        "required": [
          "axis_map"
        ],
        "title": "MoveAxesToParams",
        "description": "Payload required to move axes to absolute position."
      },
      "MoveAxesToResult": {
        "properties": {
          "position": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Position",
            "description": "The position of all axes on the robot. If no mount was provided, the last moved mount is used to determine the location.",
            "default": {
              "x": 0,
              "y": 0,
              "leftZ": 0,
              "rightZ": 0,
              "leftPlunger": 0,
              "rightPlunger": 0,
              "extensionZ": 0,
              "extensionJaw": 0,
              "axis96ChannelCam": 0
            }
          }
        },
        "type": "object",
        "title": "MoveAxesToResult",
        "description": "Result data from the execution of a MoveAxesTo command."
      },
      "MoveLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveLabware"
            ],
            "const": "moveLabware",
            "title": "Commandtype",
            "default": "moveLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GripperMovementError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveLabware",
        "description": "A ``moveLabware`` command."
      },
      "MoveLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveLabware"
            ],
            "const": "moveLabware",
            "title": "Commandtype",
            "default": "moveLabware"
          },
          "params": {
            "$ref": "#/components/schemas/MoveLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveLabwareCreate",
        "description": "A request to create a ``moveLabware`` command."
      },
      "MoveLabwareParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The ID of the labware to move."
          },
          "newLocation": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Newlocation",
            "description": "Where to move the labware."
          },
          "strategy": {
            "$ref": "#/components/schemas/LabwareMovementStrategy",
            "description": "Whether to use the gripper to perform the labware movement or to perform a manual movement with an option to pause."
          },
          "pickUpOffset": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "title": "Pickupoffset",
            "description": "Offset to use when picking up labware. Experimental param, subject to change"
          },
          "dropOffset": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "title": "Dropoffset",
            "description": "Offset to use when dropping off labware. Experimental param, subject to change"
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "newLocation",
          "strategy"
        ],
        "title": "MoveLabwareParams",
        "description": "Input parameters for a ``moveLabware`` command."
      },
      "MoveLabwareResult": {
        "properties": {
          "offsetId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offsetid",
            "description": "An ID referencing the labware offset that will apply to this labware now that it's in the new location. This offset will be in effect until the labware is moved with another `moveLabware` command. Null or undefined means no offset applies, so the default of (0, 0, 0) will be used."
          },
          "eventualDestinationLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Eventualdestinationlocationsequence",
            "description": "The full location in which this labware will eventually reside. This will typically be the same as its immediate destination, but if this labware is going to the trash then this field will be off deck."
          },
          "immediateDestinationLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Immediatedestinationlocationsequence",
            "description": "The full location to which this labware is being moved, right now."
          },
          "originLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Originlocationsequence",
            "description": "The full location down to the deck of the labware before this command."
          }
        },
        "type": "object",
        "title": "MoveLabwareResult",
        "description": "The output of a successful ``moveLabware`` command."
      },
      "MoveRelative": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveRelative"
            ],
            "const": "moveRelative",
            "title": "Commandtype",
            "default": "moveRelative"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveRelativeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveRelativeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveRelative",
        "description": "Command to move (jog) a given pipette a relative distance."
      },
      "MoveRelativeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveRelative"
            ],
            "const": "moveRelative",
            "title": "Commandtype",
            "default": "moveRelative"
          },
          "params": {
            "$ref": "#/components/schemas/MoveRelativeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveRelativeCreate",
        "description": "Data to create a MoveRelative command."
      },
      "MoveRelativeParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Pipette to move."
          },
          "axis": {
            "$ref": "#/components/schemas/MovementAxis",
            "description": "Axis along which to move."
          },
          "distance": {
            "type": "number",
            "title": "Distance",
            "description": "Distance to move in millimeters. A positive number will move towards the right (x), back (y), top (z) of the deck."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "axis",
          "distance"
        ],
        "title": "MoveRelativeParams",
        "description": "Payload required for a MoveRelative command."
      },
      "MoveRelativeResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveRelativeResult",
        "description": "Result data from the execution of a MoveRelative command."
      },
      "MoveTo": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveTo"
            ],
            "const": "robot/moveTo",
            "title": "Commandtype",
            "default": "robot/moveTo"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveTo",
        "description": "MoveTo command model."
      },
      "MoveToAddressableArea": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveToAddressableArea"
            ],
            "const": "moveToAddressableArea",
            "title": "Commandtype",
            "default": "moveToAddressableArea"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToAddressableAreaParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveToAddressableArea",
        "description": "Move to addressable area command model."
      },
      "MoveToAddressableAreaCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveToAddressableArea"
            ],
            "const": "moveToAddressableArea",
            "title": "Commandtype",
            "default": "moveToAddressableArea"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToAddressableAreaParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToAddressableAreaCreate",
        "description": "Move to addressable area command creation request model."
      },
      "MoveToAddressableAreaForDropTip": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveToAddressableAreaForDropTip"
            ],
            "const": "moveToAddressableAreaForDropTip",
            "title": "Commandtype",
            "default": "moveToAddressableAreaForDropTip"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToAddressableAreaForDropTipParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaForDropTipResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveToAddressableAreaForDropTip",
        "description": "Move to addressable area for drop tip command model."
      },
      "MoveToAddressableAreaForDropTipCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveToAddressableAreaForDropTip"
            ],
            "const": "moveToAddressableAreaForDropTip",
            "title": "Commandtype",
            "default": "moveToAddressableAreaForDropTip"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToAddressableAreaForDropTipParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToAddressableAreaForDropTipCreate",
        "description": "Move to addressable area for drop tip command creation request model."
      },
      "MoveToAddressableAreaForDropTipParams": {
        "properties": {
          "minimumZHeight": {
            "type": "number",
            "title": "Minimumzheight",
            "description": "Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect."
          },
          "forceDirect": {
            "type": "boolean",
            "title": "Forcedirect",
            "description": "If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
            "default": false
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "Override the travel speed in mm/s. This controls the straight linear speed of motion."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "addressableAreaName": {
            "type": "string",
            "title": "Addressableareaname",
            "description": "The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          },
          "offset": {
            "$ref": "#/components/schemas/AddressableOffsetVector",
            "description": "Relative offset of addressable area to move pipette's critical point.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "alternateDropLocation": {
            "type": "boolean",
            "title": "Alternatedroplocation",
            "description": "Whether to alternate location where tip is dropped within the addressable area. If True, this command will ignore the offset provided and alternate between dropping tips at two predetermined locations inside the specified labware well. If False, the tip will be dropped at the top center of the area."
          },
          "ignoreTipConfiguration": {
            "type": "boolean",
            "title": "Ignoretipconfiguration",
            "description": "Whether to utilize the critical point of the tip configuraiton when moving to an addressable area. If True, this command will ignore the tip configuration and use the center of the entire instrument as the critical point for movement. If False, this command will use the critical point provided by the current tip configuration."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "addressableAreaName"
        ],
        "title": "MoveToAddressableAreaForDropTipParams",
        "description": "Payload required to move a pipette to a specific addressable area.\n\nAn *addressable area* is a space in the robot that may or may not be usable depending on how\nthe robot's deck is configured. For example, if a Flex is configured with a waste chute, it will\nhave additional addressable areas representing the opening of the waste chute, where tips and\nlabware can be dropped.\n\nThis moves the pipette so all of its nozzles are centered over the addressable area.\nIf the pipette is currently configured with a partial tip layout, this centering is over all\nthe pipette's physical nozzles, not just the nozzles that are active.\n\nThe z-position will be chosen to put the bottom of the tips---or the bottom of the nozzles,\nif there are no tips---level with the top of the addressable area.\n\nWhen this command is executed, Protocol Engine will make sure the robot's deck is configured\nsuch that the requested addressable area actually exists. For example, if you request\nthe addressable area B4, it will make sure the robot is set up with a B3/B4 staging area slot.\nIf that's not the case, the command will fail."
      },
      "MoveToAddressableAreaForDropTipResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveToAddressableAreaForDropTipResult",
        "description": "Result data from the execution of a MoveToAddressableAreaForDropTip command."
      },
      "MoveToAddressableAreaParams": {
        "properties": {
          "minimumZHeight": {
            "type": "number",
            "title": "Minimumzheight",
            "description": "Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect."
          },
          "forceDirect": {
            "type": "boolean",
            "title": "Forcedirect",
            "description": "If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
            "default": false
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "Override the travel speed in mm/s. This controls the straight linear speed of motion."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "addressableAreaName": {
            "type": "string",
            "title": "Addressableareaname",
            "description": "The name of the addressable area that you want to use. Valid values are the `id`s of `addressableArea`s in the [deck definition](https://github.com/Opentrons/opentrons/tree/edge/shared-data/deck)."
          },
          "offset": {
            "$ref": "#/components/schemas/AddressableOffsetVector",
            "description": "Relative offset of addressable area to move pipette's critical point.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "stayAtHighestPossibleZ": {
            "type": "boolean",
            "title": "Stayathighestpossiblez",
            "description": "If `true`, the pipette will retract to its highest possible height and stay there instead of descending to the destination. `minimumZHeight` will be ignored.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "addressableAreaName"
        ],
        "title": "MoveToAddressableAreaParams",
        "description": "Payload required to move a pipette to a specific addressable area.\n\nAn *addressable area* is a space in the robot that may or may not be usable depending on how\nthe robot's deck is configured. For example, if a Flex is configured with a waste chute, it will\nhave additional addressable areas representing the opening of the waste chute, where tips and\nlabware can be dropped.\n\nThis moves the pipette so all of its nozzles are centered over the addressable area.\nIf the pipette is currently configured with a partial tip layout, this centering is over all\nthe pipette's physical nozzles, not just the nozzles that are active.\n\nThe z-position will be chosen to put the bottom of the tips---or the bottom of the nozzles,\nif there are no tips---level with the top of the addressable area.\n\nWhen this command is executed, Protocol Engine will make sure the robot's deck is configured\nsuch that the requested addressable area actually exists. For example, if you request\nthe addressable area B4, it will make sure the robot is set up with a B3/B4 staging area slot.\nIf that's not the case, the command will fail."
      },
      "MoveToAddressableAreaResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveToAddressableAreaResult",
        "description": "Result data from the execution of a MoveToAddressableArea command."
      },
      "MoveToCoordinates": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveToCoordinates"
            ],
            "const": "moveToCoordinates",
            "title": "Commandtype",
            "default": "moveToCoordinates"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToCoordinatesParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToCoordinatesResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveToCoordinates",
        "description": "Move to well command model."
      },
      "MoveToCoordinatesCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveToCoordinates"
            ],
            "const": "moveToCoordinates",
            "title": "Commandtype",
            "default": "moveToCoordinates"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToCoordinatesParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToCoordinatesCreate",
        "description": "Move to coordinates command creation request model."
      },
      "MoveToCoordinatesParams": {
        "properties": {
          "minimumZHeight": {
            "type": "number",
            "title": "Minimumzheight",
            "description": "Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect."
          },
          "forceDirect": {
            "type": "boolean",
            "title": "Forcedirect",
            "description": "If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
            "default": false
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "Override the travel speed in mm/s. This controls the straight linear speed of motion."
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "coordinates": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "X, Y and Z coordinates in mm from deck's origin location (left-front-bottom corner of work space)"
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "coordinates"
        ],
        "title": "MoveToCoordinatesParams",
        "description": "Payload required to move a pipette to coordinates."
      },
      "MoveToCoordinatesResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveToCoordinatesResult",
        "description": "Result data from the execution of a MoveToCoordinates command."
      },
      "MoveToCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "robot/moveTo"
            ],
            "const": "robot/moveTo",
            "title": "Commandtype",
            "default": "robot/moveTo"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToCreate",
        "description": "MoveTo command request model."
      },
      "MoveToMaintenancePosition": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/moveToMaintenancePosition"
            ],
            "const": "calibration/moveToMaintenancePosition",
            "title": "Commandtype",
            "default": "calibration/moveToMaintenancePosition"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToMaintenancePositionParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToMaintenancePositionResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveToMaintenancePosition",
        "description": "Calibration set up position command model."
      },
      "MoveToMaintenancePositionCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "calibration/moveToMaintenancePosition"
            ],
            "const": "calibration/moveToMaintenancePosition",
            "title": "Commandtype",
            "default": "calibration/moveToMaintenancePosition"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToMaintenancePositionParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToMaintenancePositionCreate",
        "description": "Calibration set up position command creation request model."
      },
      "MoveToMaintenancePositionParams": {
        "properties": {
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "description": "Gantry mount to move maintenance position."
          },
          "maintenancePosition": {
            "$ref": "#/components/schemas/MaintenancePosition",
            "description": "The position the gantry mount needs to move to.",
            "default": "attachInstrument"
          }
        },
        "type": "object",
        "required": [
          "mount"
        ],
        "title": "MoveToMaintenancePositionParams",
        "description": "Calibration set up position command parameters."
      },
      "MoveToMaintenancePositionResult": {
        "properties": {},
        "type": "object",
        "title": "MoveToMaintenancePositionResult",
        "description": "Result data from the execution of a MoveToMaintenancePosition command."
      },
      "MoveToParams": {
        "properties": {
          "mount": {
            "$ref": "#/components/schemas/opentrons__types__MountType",
            "description": "The mount to move to the destination point."
          },
          "destination": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "X, Y and Z coordinates in mm from deck's origin location (left-front-bottom corner of work space)"
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "The max velocity to move the axes at. Will fall to hardware defaults if none provided."
          }
        },
        "type": "object",
        "required": [
          "mount",
          "destination"
        ],
        "title": "MoveToParams",
        "description": "Payload required to move to a destination position."
      },
      "MoveToResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveToResult",
        "description": "Result data from the execution of a MoveTo command."
      },
      "MoveToWell": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "moveToWell"
            ],
            "const": "moveToWell",
            "title": "Commandtype",
            "default": "moveToWell"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToWellParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MoveToWellResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "MoveToWell",
        "description": "Move to well command model."
      },
      "MoveToWellCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "moveToWell"
            ],
            "const": "moveToWell",
            "title": "Commandtype",
            "default": "moveToWell"
          },
          "params": {
            "$ref": "#/components/schemas/MoveToWellParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "MoveToWellCreate",
        "description": "Move to well command creation request model."
      },
      "MoveToWellParams": {
        "properties": {
          "minimumZHeight": {
            "type": "number",
            "title": "Minimumzheight",
            "description": "Optional minimal Z margin in mm. If this is larger than the API's default safe Z margin, it will make the arc higher. If it's smaller, it will have no effect."
          },
          "forceDirect": {
            "type": "boolean",
            "title": "Forcedirect",
            "description": "If true, moving from one labware/well to another will not arc to the default safe z, but instead will move directly to the specified location. This will also force the `minimumZHeight` param to be ignored. A 'direct' movement is in X/Y/Z simultaneously.",
            "default": false
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "Override the travel speed in mm/s. This controls the straight linear speed of motion."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/WellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "pipetteId"
        ],
        "title": "MoveToWellParams",
        "description": "Payload required to move a pipette to a specific well."
      },
      "MoveToWellResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "MoveToWellResult",
        "description": "Result data from the execution of a MoveToWell command."
      },
      "MovementAxis": {
        "type": "string",
        "enum": [
          "x",
          "y",
          "z"
        ],
        "title": "MovementAxis",
        "description": "Axis on which to issue a relative movement."
      },
      "MultiBodyMeta": {
        "properties": {
          "cursor": {
            "type": "integer",
            "title": "Cursor",
            "description": "The index of the response's cursor in the overall collection the response represents."
          },
          "totalLength": {
            "type": "integer",
            "title": "Totallength",
            "description": "Total number of items in the overall collection."
          }
        },
        "type": "object",
        "required": [
          "cursor",
          "totalLength"
        ],
        "title": "MultiBodyMeta"
      },
      "MultiBody_RunCommandSummary_CommandCollectionLinks_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/RunCommandSummary"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "$ref": "#/components/schemas/CommandCollectionLinks",
            "description": "A links object related to the primary data."
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "links",
          "meta"
        ],
        "title": "MultiBody[RunCommandSummary, CommandCollectionLinks]"
      },
      "MultiBody_Union_Run__BadRun__AllRunsLinks_": {
        "properties": {
          "data": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Run"
                },
                {
                  "$ref": "#/components/schemas/BadRun"
                }
              ]
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "links": {
            "$ref": "#/components/schemas/AllRunsLinks",
            "description": "A links object related to the primary data."
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "links",
          "meta"
        ],
        "title": "MultiBody[Union[Run, BadRun], AllRunsLinks]"
      },
      "MultiDispenseProperties": {
        "properties": {
          "submerge": {
            "$ref": "#/components/schemas/Submerge",
            "description": "Submerge settings for multi-dispense."
          },
          "retract": {
            "$ref": "#/components/schemas/RetractDispense",
            "description": "Pipette retract settings after a multi-dispense."
          },
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for multi-dispense."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for single multi-dispense."
          },
          "flowRateByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Flowratebyvolume",
            "description": "Settings for flow rate keyed by target dispense volume."
          },
          "correctionByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Correctionbyvolume",
            "description": "Settings for volume correction keyed by by target dispense volume, representing additional volume the plunger should move to accurately hit target volume."
          },
          "conditioningByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Conditioningbyvolume",
            "description": "Settings for conditioning volume keyed by target dispense volume."
          },
          "disposalByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Disposalbyvolume",
            "description": "Settings for disposal volume keyed by target dispense volume."
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay settings after each dispense"
          }
        },
        "type": "object",
        "required": [
          "submerge",
          "retract",
          "positionReference",
          "offset",
          "flowRateByVolume",
          "correctionByVolume",
          "conditioningByVolume",
          "disposalByVolume",
          "delay"
        ],
        "title": "MultiDispenseProperties",
        "description": "Properties specific to the multi-dispense function."
      },
      "MultipleDataFileSources": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "MultipleDataFileSources"
            ],
            "const": "MultipleDataFileSources",
            "title": "Id",
            "default": "MultipleDataFileSources"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Multiple sources found for data files"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "MultipleDataFileSources",
        "description": "An error returned when multiple data file sources are specified in one request."
      },
      "NetworkingSecurityType": {
        "type": "string",
        "enum": [
          "wpa-eap",
          "wpa-psk",
          "none",
          "unsupported"
        ],
        "title": "NetworkingSecurityType",
        "description": "Top-level type of network security"
      },
      "NetworkingStatus": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/ConnectivityStatus",
            "description": "Overall connectivity of the robot",
            "default": "none"
          },
          "interfaces": {
            "additionalProperties": {
              "$ref": "#/components/schemas/InterfaceStatus"
            },
            "type": "object",
            "title": "Interfaces",
            "description": "Per-interface networking status. Properties are named for network interfaces",
            "default": {}
          }
        },
        "type": "object",
        "title": "NetworkingStatus",
        "example": {
          "interfaces": {
            "eth0": {
              "ipAddress": "169.254.229.173/16",
              "macAddress": "B8:27:EB:39:C0:9A",
              "state": "connected",
              "type": "ethernet"
            },
            "wlan0": {
              "gatewayAddress": "192.168.43.161",
              "ipAddress": "192.168.43.97/24",
              "macAddress": "B8:27:EB:6C:95:CF",
              "state": "connected",
              "type": "wifi"
            }
          },
          "status": "full"
        }
      },
      "NextStepLink": {
        "properties": {
          "url": {
            "type": "string",
            "title": "Url"
          },
          "params": {
            "type": "object",
            "title": "Params"
          }
        },
        "type": "object",
        "required": [
          "url",
          "params"
        ],
        "title": "NextStepLink"
      },
      "NextSteps": {
        "properties": {
          "links": {
            "additionalProperties": {
              "$ref": "#/components/schemas/NextStepLink"
            },
            "type": "object",
            "title": "Links"
          }
        },
        "type": "object",
        "required": [
          "links"
        ],
        "title": "NextSteps"
      },
      "NextTipInfo": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The labware ID of the tip rack where the next available tip(s) are located."
          },
          "tipStartingWell": {
            "type": "string",
            "title": "Tipstartingwell",
            "description": "The (starting) well name of the next available tip(s)."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "tipStartingWell"
        ],
        "title": "NextTipInfo",
        "description": "Next available tip labware and well name data."
      },
      "NoCurrentRunFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "NoCurrentRunFound"
            ],
            "const": "NoCurrentRunFound",
            "title": "Id",
            "default": "NoCurrentRunFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "No current run found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "NoCurrentRunFound",
        "description": "An error if there is no current run to fetch."
      },
      "NoDataFileSourceProvided": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "NoDataFileSourceProvided"
            ],
            "const": "NoDataFileSourceProvided",
            "title": "Id",
            "default": "NoDataFileSourceProvided"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "No data file source provided"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "NoDataFileSourceProvided",
        "description": "An error returned when no data file sources are specified in the request."
      },
      "NoOngoingUpdate": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "NoOngoingUpdate"
            ],
            "const": "NoOngoingUpdate",
            "title": "Id",
            "default": "NoOngoingUpdate"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "No Ongoing Update"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "NoOngoingUpdate",
        "description": "An error if there is no ongoing update for a subsystem."
      },
      "NoTipAvailable": {
        "properties": {
          "noTipReason": {
            "$ref": "#/components/schemas/NoTipReason",
            "description": "The reason why no next available tip could be provided."
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional message explaining why a tip wasn't available."
          }
        },
        "type": "object",
        "required": [
          "noTipReason"
        ],
        "title": "NoTipAvailable",
        "description": "No available next tip data."
      },
      "NoTipReason": {
        "type": "string",
        "enum": [
          "noAvailableTips",
          "startingTipWithPartial",
          "incompatibleConfiguration"
        ],
        "title": "NoTipReason",
        "description": "The cause of no tip being available for a pipette and tip rack(s)."
      },
      "NoUpdateAvailable": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "NoUpdateAvailable"
            ],
            "const": "NoUpdateAvailable",
            "title": "Id",
            "default": "NoUpdateAvailable"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "No Update Available"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "NoUpdateAvailable",
        "description": "An error if no update is available for the specified mount."
      },
      "NotOnDeckLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "notOnDeck"
            ],
            "const": "notOnDeck",
            "title": "Kind",
            "default": "notOnDeck"
          },
          "logicalLocationName": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "offDeck"
                ],
                "const": "offDeck"
              },
              {
                "type": "string",
                "enum": [
                  "systemLocation"
                ],
                "const": "systemLocation"
              }
            ],
            "title": "Logicallocationname"
          }
        },
        "type": "object",
        "required": [
          "logicalLocationName"
        ],
        "title": "NotOnDeckLocationSequenceComponent",
        "description": "Labware on a system location."
      },
      "NotSupportedOnOT2": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "NotSupportedOnOT2"
            ],
            "const": "NotSupportedOnOT2",
            "title": "Id",
            "default": "NotSupportedOnOT2"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Not Supported On OT-2"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "NotSupportedOnOT2",
        "description": "An error returned when an operation is not supported on an OT2."
      },
      "NozzleLayoutConfig": {
        "type": "string",
        "enum": [
          "column",
          "row",
          "single",
          "full",
          "subrect"
        ],
        "title": "NozzleLayoutConfig",
        "description": "Possible valid nozzle configurations."
      },
      "NumberParameter": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "Display string for the parameter."
          },
          "variableName": {
            "type": "string",
            "title": "Variablename",
            "description": "Python variable name of the parameter."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of the parameter."
          },
          "suffix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Suffix",
            "description": "Units (like mL, mm/sec, etc) or a custom suffix for the parameter."
          },
          "type": {
            "type": "string",
            "enum": [
              "int",
              "float"
            ],
            "title": "Type",
            "description": "String specifying whether the number is an int or float type."
          },
          "min": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Min",
            "description": "Minimum value that the number param is allowed to have."
          },
          "max": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Max",
            "description": "Maximum value that the number param is allowed to have."
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Value",
            "description": "The value assigned to the parameter; if not supplied by the client, will be assigned the default value."
          },
          "default": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Default",
            "description": "Default value of the parameter, to be used when there is no client-specified value."
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "variableName",
          "type",
          "min",
          "max",
          "value",
          "default"
        ],
        "title": "NumberParameter",
        "description": "An integer parameter defined in a protocol."
      },
      "OffsetData": {
        "properties": {
          "value": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Value",
            "description": "A labware offset vector in deck coordinates (x, y, z)"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "title": "Lastmodified",
            "description": "When this calibration was last modified"
          }
        },
        "type": "object",
        "required": [
          "value",
          "lastModified"
        ],
        "title": "OffsetData"
      },
      "OnAddressableAreaLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onAddressableArea"
            ],
            "const": "onAddressableArea",
            "title": "Kind",
            "default": "onAddressableArea"
          },
          "addressableAreaName": {
            "type": "string",
            "title": "Addressableareaname"
          }
        },
        "type": "object",
        "required": [
          "addressableAreaName"
        ],
        "title": "OnAddressableAreaLocationSequenceComponent",
        "description": "Labware on an addressable area."
      },
      "OnAddressableAreaOffsetLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onAddressableArea"
            ],
            "const": "onAddressableArea",
            "title": "Kind",
            "default": "onAddressableArea"
          },
          "addressableAreaName": {
            "type": "string",
            "title": "Addressableareaname",
            "description": "The ID of an addressable area that a labware or module can be loaded onto, such as (on the OT-2) \"2\" or (on the Flex) \"C1\". \n\nOn the Flex, this field must be correct for the kind of entity it hosts. For instance, if the prior entity in the location sequence is an `OnModuleOffsetLocationSequenceComponent(moduleModel=temperatureModuleV2)`, this entity must be temperatureModuleV2NN where NN is the slot name in which the module resides. "
          }
        },
        "type": "object",
        "required": [
          "addressableAreaName"
        ],
        "title": "OnAddressableAreaOffsetLocationSequenceComponent",
        "description": "Offset location sequence component for a labware on an addressable area."
      },
      "OnCutoutFixtureLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onCutoutFixture"
            ],
            "const": "onCutoutFixture",
            "title": "Kind",
            "default": "onCutoutFixture"
          },
          "possibleCutoutFixtureIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Possiblecutoutfixtureids"
          },
          "cutoutId": {
            "type": "string",
            "title": "Cutoutid"
          }
        },
        "type": "object",
        "required": [
          "possibleCutoutFixtureIds",
          "cutoutId"
        ],
        "title": "OnCutoutFixtureLocationSequenceComponent",
        "description": "Something on a deck cutout fixture."
      },
      "OnLabwareLocation": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The ID of a loaded Labware from a prior `loadLabware` command."
          }
        },
        "type": "object",
        "required": [
          "labwareId"
        ],
        "title": "OnLabwareLocation",
        "description": "The location of something placed atop another labware."
      },
      "OnLabwareLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onLabware"
            ],
            "const": "onLabware",
            "title": "Kind",
            "default": "onLabware"
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid"
          },
          "lidId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidid"
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "lidId"
        ],
        "title": "OnLabwareLocationSequenceComponent",
        "description": "Labware on another labware."
      },
      "OnLabwareOffsetLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onLabware"
            ],
            "const": "onLabware",
            "title": "Kind",
            "default": "onLabware"
          },
          "labwareUri": {
            "type": "string",
            "title": "Labwareuri",
            "description": "The definition URI of a labware that a labware can be loaded onto."
          }
        },
        "type": "object",
        "required": [
          "labwareUri"
        ],
        "title": "OnLabwareOffsetLocationSequenceComponent",
        "description": "Offset location sequence component for a labware on another labware."
      },
      "OnModuleLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onModule"
            ],
            "const": "onModule",
            "title": "Kind",
            "default": "onModule"
          },
          "moduleId": {
            "type": "string",
            "title": "Moduleid"
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "OnModuleLocationSequenceComponent",
        "description": "Labware on a module."
      },
      "OnModuleOffsetLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "onModule"
            ],
            "const": "onModule",
            "title": "Kind",
            "default": "onModule"
          },
          "moduleModel": {
            "$ref": "#/components/schemas/ModuleModel",
            "description": "The model of a module that a labware can be loaded on to."
          }
        },
        "type": "object",
        "required": [
          "moduleModel"
        ],
        "title": "OnModuleOffsetLocationSequenceComponent",
        "description": "Offset location sequence component for a labware on a module."
      },
      "OpenLabwareLatch": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/openLabwareLatch"
            ],
            "const": "heaterShaker/openLabwareLatch",
            "title": "Commandtype",
            "default": "heaterShaker/openLabwareLatch"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/OpenLabwareLatchParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OpenLabwareLatchResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "OpenLabwareLatch",
        "description": "A command to open a Heater-Shaker's labware latch."
      },
      "OpenLabwareLatchCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/openLabwareLatch"
            ],
            "const": "heaterShaker/openLabwareLatch",
            "title": "Commandtype",
            "default": "heaterShaker/openLabwareLatch"
          },
          "params": {
            "$ref": "#/components/schemas/OpenLabwareLatchParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "OpenLabwareLatchCreate",
        "description": "A request to create a Heater-Shaker's open labware latch command."
      },
      "OpenLabwareLatchParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "OpenLabwareLatchParams",
        "description": "Input parameters to open a Heater-Shaker Module's labware latch."
      },
      "OpenLabwareLatchResult": {
        "properties": {
          "pipetteRetracted": {
            "type": "boolean",
            "title": "Pipetteretracted",
            "description": "Whether this command automatically retracted the pipettes before opening the latch, to avoid a potential collision."
          }
        },
        "type": "object",
        "required": [
          "pipetteRetracted"
        ],
        "title": "OpenLabwareLatchResult",
        "description": "Result data from opening a Heater-Shaker's labware latch."
      },
      "OverpressureError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "overpressure"
            ],
            "const": "overpressure",
            "title": "Errortype",
            "default": "overpressure"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "3006"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Pipette Overpressure"
          },
          "errorInfo": {
            "$ref": "#/components/schemas/ErrorLocationInfo"
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorInfo",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "OverpressureError",
        "description": "Returned when sensors detect an overpressure error while moving liquid.\n\nThe pipette plunger motion is stopped at the point of the error.\n\nThe next thing to move the plunger must account for the robot not having a valid\nestimate of its position. It should be a `home`, `unsafe/updatePositionEstimators`,\n`unsafe/dropTipInPlace`, or `unsafe/blowOutInPlace`."
      },
      "Parameters2": {
        "properties": {
          "format": {
            "type": "string",
            "enum": [
              "96Standard",
              "384Standard",
              "trough",
              "irregular",
              "trash"
            ],
            "title": "Format"
          },
          "quirks": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quirks"
          },
          "isTiprack": {
            "type": "boolean",
            "title": "Istiprack"
          },
          "tipLength": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiplength"
          },
          "tipOverlap": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Tipoverlap"
          },
          "loadName": {
            "type": "string",
            "pattern": "^[a-z0-9._]+$",
            "title": "Loadname"
          },
          "isMagneticModuleCompatible": {
            "type": "boolean",
            "title": "Ismagneticmodulecompatible"
          },
          "isDeckSlotCompatible": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Isdeckslotcompatible"
          },
          "magneticModuleEngageHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Magneticmoduleengageheight"
          }
        },
        "type": "object",
        "required": [
          "format",
          "isTiprack",
          "loadName",
          "isMagneticModuleCompatible"
        ],
        "title": "Parameters2"
      },
      "Parameters3": {
        "properties": {
          "format": {
            "type": "string",
            "enum": [
              "96Standard",
              "384Standard",
              "trough",
              "irregular",
              "trash"
            ],
            "title": "Format"
          },
          "quirks": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quirks"
          },
          "isTiprack": {
            "type": "boolean",
            "title": "Istiprack"
          },
          "tipLength": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiplength"
          },
          "tipOverlap": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Tipoverlap"
          },
          "loadName": {
            "type": "string",
            "pattern": "^[a-z0-9._]+$",
            "title": "Loadname"
          },
          "isMagneticModuleCompatible": {
            "type": "boolean",
            "title": "Ismagneticmodulecompatible"
          },
          "isDeckSlotCompatible": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Isdeckslotcompatible"
          },
          "magneticModuleEngageHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Magneticmoduleengageheight"
          }
        },
        "type": "object",
        "required": [
          "format",
          "isTiprack",
          "loadName",
          "isMagneticModuleCompatible"
        ],
        "title": "Parameters3"
      },
      "PendingAnalysis": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this analysis resource"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending"
            ],
            "const": "pending",
            "title": "Status",
            "description": "Status marking the analysis as pending",
            "default": "pending"
          },
          "runTimeParameters": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/NumberParameter"
                },
                {
                  "$ref": "#/components/schemas/EnumParameter"
                },
                {
                  "$ref": "#/components/schemas/BooleanParameter"
                },
                {
                  "$ref": "#/components/schemas/CSVParameter"
                }
              ]
            },
            "type": "array",
            "title": "Runtimeparameters",
            "description": "Run time parameters used during analysis. These are the parameters that are defined in the protocol, with values specified either in the protocol creation request or reanalysis request (whichever started this analysis), or default values from the protocol if none are specified in the request."
          }
        },
        "type": "object",
        "required": [
          "id"
        ],
        "title": "PendingAnalysis",
        "description": "A protocol analysis that is on-going."
      },
      "PickUpTip": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "pickUpTip"
            ],
            "const": "pickUpTip",
            "title": "Commandtype",
            "default": "pickUpTip"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/PickUpTipParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PickUpTipResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TipPhysicallyMissingError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "PickUpTip",
        "description": "Pick up tip command model."
      },
      "PickUpTipCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "pickUpTip"
            ],
            "const": "pickUpTip",
            "title": "Commandtype",
            "default": "pickUpTip"
          },
          "params": {
            "$ref": "#/components/schemas/PickUpTipParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "PickUpTipCreate",
        "description": "Pick up tip command creation request model."
      },
      "PickUpTipParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/PickUpTipWellLocation",
            "description": "Relative well location at which to pick up the tip."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "labwareId",
          "wellName"
        ],
        "title": "PickUpTipParams",
        "description": "Payload needed to move a pipette to a specific well."
      },
      "PickUpTipResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "tipVolume": {
            "type": "number",
            "minimum": 0,
            "title": "Tipvolume",
            "description": "Maximum volume of liquid that the picked up tip can hold, in L.",
            "default": 0
          },
          "tipLength": {
            "type": "number",
            "minimum": 0,
            "title": "Tiplength",
            "description": "The length of the tip in mm.",
            "default": 0
          },
          "tipDiameter": {
            "type": "number",
            "minimum": 0,
            "title": "Tipdiameter",
            "description": "The diameter of the tip in mm.",
            "default": 0
          }
        },
        "type": "object",
        "title": "PickUpTipResult",
        "description": "Result data from the execution of a PickUpTip."
      },
      "PickUpTipWellLocation": {
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/PickUpTipWellOrigin",
            "default": "top"
          },
          "offset": {
            "$ref": "#/components/schemas/WellOffset"
          }
        },
        "type": "object",
        "title": "PickUpTipWellLocation",
        "description": "A relative location in reference to a well's location.\n\nTo be used for picking up tips."
      },
      "PickUpTipWellOrigin": {
        "type": "string",
        "enum": [
          "top",
          "bottom",
          "center"
        ],
        "title": "PickUpTipWellOrigin",
        "description": "The origin of a PickUpTipWellLocation offset.\n\nProps:\n    TOP: the top-center of the well\n    BOTTOM: the bottom-center of the well\n    CENTER: the middle-center of the well"
      },
      "Pipette": {
        "properties": {
          "mount": {
            "type": "string",
            "title": "Mount",
            "description": "The mount this instrument is attached to."
          },
          "instrumentType": {
            "type": "string",
            "enum": [
              "pipette"
            ],
            "const": "pipette",
            "title": "Instrumenttype",
            "default": "pipette"
          },
          "instrumentModel": {
            "type": "string",
            "title": "Instrumentmodel"
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Instrument hardware serial number."
          },
          "subsystem": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SubSystem"
              },
              {
                "type": "null"
              }
            ],
            "description": "The subsystem corresponding to this instrument."
          },
          "ok": {
            "type": "boolean",
            "enum": [
              true
            ],
            "const": true,
            "title": "Ok",
            "description": "Whether this instrument is OK and ready to go"
          },
          "firmwareVersion": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Firmwareversion",
            "description": "The firmware version of this instrument (if applicable)"
          },
          "data": {
            "$ref": "#/components/schemas/PipetteData"
          },
          "instrumentName": {
            "type": "string",
            "enum": [
              "p10_single",
              "p10_multi",
              "p20_single_gen2",
              "p20_multi_gen2",
              "p50_single",
              "p50_multi",
              "p50_single_flex",
              "p50_multi_flex",
              "p300_single",
              "p300_multi",
              "p300_single_gen2",
              "p300_multi_gen2",
              "p1000_single",
              "p1000_single_gen2",
              "p1000_single_flex",
              "p1000_multi_flex",
              "p1000_multi_em_flex",
              "p1000_96",
              "p200_96"
            ],
            "title": "Instrumentname"
          },
          "state": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipetteState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "mount",
          "instrumentModel",
          "serialNumber",
          "ok",
          "data",
          "instrumentName"
        ],
        "title": "Pipette",
        "description": "Attached pipette info & configuration."
      },
      "PipetteData": {
        "properties": {
          "channels": {
            "type": "integer",
            "enum": [
              1,
              8,
              96
            ],
            "title": "Channels",
            "description": "Number of pipette channels."
          },
          "min_volume": {
            "type": "number",
            "title": "Min Volume",
            "description": "Minimum pipette volume."
          },
          "max_volume": {
            "type": "number",
            "title": "Max Volume",
            "description": "Maximum pipette volume."
          },
          "calibratedOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/InstrumentCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "Calibrated pipette offset."
          }
        },
        "type": "object",
        "required": [
          "channels",
          "min_volume",
          "max_volume"
        ],
        "title": "PipetteData",
        "description": "Data from attached pipette."
      },
      "PipetteNameType": {
        "type": "string",
        "enum": [
          "p10_single",
          "p10_multi",
          "p20_single_gen2",
          "p20_multi_gen2",
          "p50_single",
          "p50_multi",
          "p50_single_flex",
          "p50_multi_flex",
          "p300_single",
          "p300_multi",
          "p300_single_gen2",
          "p300_multi_gen2",
          "p1000_single",
          "p1000_single_gen2",
          "p1000_single_flex",
          "p1000_multi_flex",
          "p1000_multi_em_flex",
          "p1000_96",
          "p200_96"
        ],
        "title": "PipetteNameType",
        "description": "Pipette load name values."
      },
      "PipetteOffsetCalibration": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "pipette": {
            "type": "string",
            "title": "Pipette",
            "description": "The pipette ID"
          },
          "mount": {
            "type": "string",
            "title": "Mount",
            "description": "The pipette mount"
          },
          "offset": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Offset",
            "description": "The pipette offset vector"
          },
          "tiprack": {
            "type": "string",
            "title": "Tiprack",
            "description": "A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `tiprackUri` instead."
          },
          "tiprackUri": {
            "type": "string",
            "title": "Tiprackuri",
            "description": "The standard labware uri of the tiprack used in this calibration"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "title": "Lastmodified",
            "description": "When this calibration was last modified"
          },
          "source": {
            "$ref": "#/components/schemas/SourceType",
            "description": "The calibration source"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__shared_models__calibration__CalibrationStatus",
            "description": "The status of this calibration"
          }
        },
        "type": "object",
        "required": [
          "id",
          "pipette",
          "mount",
          "offset",
          "tiprack",
          "tiprackUri",
          "lastModified",
          "source",
          "status"
        ],
        "title": "PipetteOffsetCalibration",
        "description": "A model describing pipette calibration based on the mount and\nthe pipette's serial number"
      },
      "PipetteOffsetCalibrationCreateAttributes": {
        "properties": {
          "sessionType": {
            "type": "string",
            "enum": [
              "pipetteOffsetCalibration"
            ],
            "const": "pipetteOffsetCalibration",
            "title": "Sessiontype",
            "default": "pipetteOffsetCalibration"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "createParams"
        ],
        "title": "PipetteOffsetCalibrationCreateAttributes",
        "description": "Pipette offset calibration create request."
      },
      "PipetteOffsetCalibrationResponseAttributes": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Date and time that this session was created"
          },
          "details": {
            "$ref": "#/components/schemas/PipetteOffsetCalibrationSessionStatus"
          },
          "sessionType": {
            "type": "string",
            "enum": [
              "pipetteOffsetCalibration"
            ],
            "const": "pipetteOffsetCalibration",
            "title": "Sessiontype",
            "default": "pipetteOffsetCalibration"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "details",
          "createParams"
        ],
        "title": "PipetteOffsetCalibrationResponseAttributes",
        "description": "Response attributes of pipette offset calibration session."
      },
      "PipetteOffsetCalibrationSessionStatus": {
        "properties": {
          "instrument": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__helper_classes__AttachedPipette"
          },
          "currentStep": {
            "type": "string",
            "title": "Currentstep",
            "description": "Current step of pipette offset user flow"
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/RequiredLabware"
            },
            "type": "array",
            "title": "Labware"
          },
          "shouldPerformTipLength": {
            "type": "boolean",
            "title": "Shouldperformtiplength",
            "description": "Does tip length calibration data exist for this pipette and tip rack combination"
          },
          "supportedCommands": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supportedcommands",
            "description": "A list of supported commands for this user flow"
          },
          "nextSteps": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NextSteps"
              },
              {
                "type": "null"
              }
            ],
            "description": "Next Available Steps in Session"
          }
        },
        "type": "object",
        "required": [
          "instrument",
          "currentStep",
          "labware",
          "shouldPerformTipLength",
          "supportedCommands"
        ],
        "title": "PipetteOffsetCalibrationSessionStatus",
        "description": "The current status of a pipette offset calibration session.",
        "examples": [
          {
            "currentStep": "sessionStarted",
            "instrument": {
              "model": "p300_single_v1.5",
              "mount": "left",
              "name": "p300_single",
              "serial": "P3HS12123041",
              "tip_length": 51.7
            },
            "labware": [
              {
                "definition": {
                  "ordering": "the ordering section..."
                },
                "isTiprack": "true",
                "loadName": "tiprack_loadname",
                "namespace": "opentrons",
                "slot": "8",
                "version": "1"
              }
            ],
            "nextSteps": {
              "links": {
                "loadLabware": {
                  "params": {},
                  "url": ""
                }
              }
            },
            "shouldPerformTipLength": true
          }
        ]
      },
      "PipetteOffsetComparisonMap": {
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "IN_THRESHOLD",
              "OUTSIDE_THRESHOLD"
            ],
            "title": "Status",
            "description": "The status of this calibration type,dependent on the calibration beinginside or outside of the threshold"
          },
          "comparingHeight": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "height validation step"
          },
          "comparingPointOne": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "point 1 validation step"
          }
        },
        "type": "object",
        "required": [
          "status"
        ],
        "title": "PipetteOffsetComparisonMap"
      },
      "PipetteSettings": {
        "properties": {
          "info": {
            "$ref": "#/components/schemas/PipetteSettingsInfo"
          },
          "fields": {
            "$ref": "#/components/schemas/PipetteSettingsFields"
          }
        },
        "type": "object",
        "required": [
          "info",
          "fields"
        ],
        "title": "PipetteSettings"
      },
      "PipetteSettingsField": {
        "properties": {
          "units": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Units",
            "description": "The physical units this value is in (e.g. mm, uL)"
          },
          "type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PipetteSettingsFieldType"
              },
              {
                "type": "null"
              }
            ]
          },
          "min": {
            "type": "number",
            "title": "Min",
            "description": "The minimum acceptable value of the property"
          },
          "max": {
            "type": "number",
            "title": "Max",
            "description": "The maximum acceptable value of the property"
          },
          "default": {
            "type": "number",
            "title": "Default",
            "description": "The default value of the property"
          },
          "value": {
            "type": "number",
            "title": "Value",
            "description": "The current value of the property"
          }
        },
        "type": "object",
        "required": [
          "min",
          "max",
          "default",
          "value"
        ],
        "title": "PipetteSettingsField",
        "description": "A pipette config element identified by the property's name"
      },
      "PipetteSettingsFieldType": {
        "type": "string",
        "enum": [
          "float",
          "int"
        ],
        "title": "PipetteSettingsFieldType",
        "description": "The type of the property"
      },
      "PipetteSettingsFields": {
        "properties": {
          "quirks": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "boolean"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Quirks",
            "description": "Quirks are behavioral changes associated with pipettes. For instance, some models of pipette might need to run their drop tip behavior twice. Specific pipettes have which can then be enabled or disabled; quirks that are not originally defined as compatible with a specific kind of pipette cannot be added to an incompatible pipette. Because quirks are only defined as compatible for a pipette if they should be on, the default value for all quirks is true."
          },
          "top": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "bottom": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "blowout": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "dropTip": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "pickUpCurrent": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "pickUpDistance": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "pickUpIncrement": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "pickUpPresses": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "pickUpSpeed": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "plungerCurrent": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "dropTipCurrent": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "dropTipSpeed": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          },
          "tipLength": {
            "$ref": "#/components/schemas/PipetteSettingsField"
          }
        },
        "type": "object",
        "title": "PipetteSettingsFields",
        "description": "The fields of the pipette settings"
      },
      "PipetteSettingsInfo": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "A pipette name (e.g. \"p300_single\")"
          },
          "model": {
            "type": "string",
            "title": "Model",
            "description": "The exact pipette model (e.g. \"p300_single_v1.5\")"
          }
        },
        "type": "object",
        "required": [
          "name",
          "model"
        ],
        "title": "PipetteSettingsInfo",
        "description": "Metadata about this pipette"
      },
      "PipetteSettingsUpdate": {
        "properties": {
          "fields": {
            "anyOf": [
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/PipetteUpdateField"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Fields"
          }
        },
        "type": "object",
        "title": "PipetteSettingsUpdate"
      },
      "PipetteState": {
        "properties": {
          "tip_detected": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tip Detected",
            "description": "Physical state of the tip photointerrupter on the Flex. Null for OT-2"
          }
        },
        "type": "object",
        "title": "PipetteState",
        "description": "State from an attached pipette."
      },
      "PipetteUpdateField": {
        "properties": {
          "value": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Value",
            "description": "Must be a boolean if this is a quirk. The format if this is not a quirk. Must be between max and min for this property. Null means reset."
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "PipetteUpdateField"
      },
      "PipettesByMount": {
        "properties": {
          "left": {
            "$ref": "#/components/schemas/robot_server__service__legacy__models__pipettes__AttachedPipette"
          },
          "right": {
            "$ref": "#/components/schemas/robot_server__service__legacy__models__pipettes__AttachedPipette"
          }
        },
        "type": "object",
        "required": [
          "left",
          "right"
        ],
        "title": "PipettesByMount",
        "description": "The attached pipettes by mount",
        "example": {
          "left": {
            "id": "P3HS12123041",
            "model": "p300_single_v1.5",
            "mount_axis": "z",
            "name": "p300_single",
            "plunger_axis": "b",
            "tip_length": 51.7
          },
          "right": {
            "mount_axis": "a",
            "plunger_axis": "c"
          }
        }
      },
      "PlaceLabwareState": {
        "properties": {
          "labwareURI": {
            "type": "string",
            "title": "Labwareuri",
            "description": "The URI of the labware to place."
          },
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "The location the labware should be in."
          },
          "shouldPlaceDown": {
            "type": "boolean",
            "title": "Shouldplacedown",
            "description": "Whether the gripper should place down the labware."
          }
        },
        "type": "object",
        "required": [
          "labwareURI",
          "location",
          "shouldPlaceDown"
        ],
        "title": "PlaceLabwareState",
        "description": "Details the labware being placed by the gripper."
      },
      "PlatformState": {
        "type": "string",
        "enum": [
          "unknown",
          "extended",
          "retracted"
        ],
        "title": "PlatformState"
      },
      "Point": {
        "prefixItems": [
          {
            "type": "number",
            "title": "X",
            "default": 0
          },
          {
            "type": "number",
            "title": "Y",
            "default": 0
          },
          {
            "type": "number",
            "title": "Z",
            "default": 0
          }
        ],
        "type": "array",
        "maxItems": 3
      },
      "PositionReference": {
        "type": "string",
        "enum": [
          "well-bottom",
          "well-top",
          "well-center",
          "liquid-meniscus"
        ],
        "title": "PositionReference",
        "description": "Positional reference for liquid handling operations."
      },
      "PreSerializedCommandsNotAvailable": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "PreSerializedCommandsNotAvailable"
            ],
            "const": "PreSerializedCommandsNotAvailable",
            "title": "Id",
            "default": "PreSerializedCommandsNotAvailable"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Pre-Serialized commands not available."
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Pre-serialized commands are only available once a run has finished running."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "title": "PreSerializedCommandsNotAvailable",
        "description": "An error if one tries to fetch pre-serialized commands before they are written to the database."
      },
      "PrepareToAspirate": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "prepareToAspirate"
            ],
            "const": "prepareToAspirate",
            "title": "Commandtype",
            "default": "prepareToAspirate"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/PrepareToAspirateParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PrepareToAspirateResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "PrepareToAspirate",
        "description": "Prepare for aspirate command model."
      },
      "PrepareToAspirateCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "prepareToAspirate"
            ],
            "const": "prepareToAspirate",
            "title": "Commandtype",
            "default": "prepareToAspirate"
          },
          "params": {
            "$ref": "#/components/schemas/PrepareToAspirateParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "PrepareToAspirateCreate",
        "description": "Prepare for aspirate command creation request model."
      },
      "PrepareToAspirateParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "PrepareToAspirateParams",
        "description": "Parameters required to prepare a specific pipette for aspiration."
      },
      "PrepareToAspirateResult": {
        "properties": {},
        "type": "object",
        "title": "PrepareToAspirateResult",
        "description": "Result data from execution of an PrepareToAspirate command."
      },
      "PresentSubsystem": {
        "properties": {
          "name": {
            "$ref": "#/components/schemas/SubSystem",
            "description": "The name of a connected subsystem."
          },
          "ok": {
            "type": "boolean",
            "title": "Ok",
            "description": "Whether the subsystem is running, up to date, and in a normal state."
          },
          "current_fw_version": {
            "type": "string",
            "title": "Current Fw Version",
            "description": "The current version of firmware the subsystem is running."
          },
          "next_fw_version": {
            "type": "string",
            "title": "Next Fw Version",
            "description": "What firmware version a prospective update would leave the subsystem running."
          },
          "fw_update_needed": {
            "type": "boolean",
            "title": "Fw Update Needed",
            "description": "True if a client should begin an update for this subsystem."
          },
          "revision": {
            "type": "string",
            "title": "Revision",
            "description": "A descriptor of the hardware revision of the subsystem."
          }
        },
        "type": "object",
        "required": [
          "name",
          "ok",
          "current_fw_version",
          "next_fw_version",
          "fw_update_needed",
          "revision"
        ],
        "title": "PresentSubsystem",
        "description": "Model for the status of a subsystem."
      },
      "ProfileCycle": {
        "properties": {
          "steps": {
            "items": {
              "$ref": "#/components/schemas/ProfileStep"
            },
            "type": "array",
            "title": "Steps",
            "description": "Steps to repeat."
          },
          "repetitions": {
            "type": "integer",
            "title": "Repetitions",
            "description": "Number of times to repeat the steps."
          }
        },
        "type": "object",
        "required": [
          "steps",
          "repetitions"
        ],
        "title": "ProfileCycle",
        "description": "An individual cycle in a Thermocycler extended profile."
      },
      "ProfileStep": {
        "properties": {
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          },
          "holdSeconds": {
            "type": "number",
            "title": "Holdseconds",
            "description": "Time to hold target temperature in seconds."
          }
        },
        "type": "object",
        "required": [
          "celsius",
          "holdSeconds"
        ],
        "title": "ProfileStep",
        "description": "An individual step in a Thermocycler extended profile."
      },
      "Protocol": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A unique identifier for this protocol."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When this protocol was *uploaded.* (`metadata` may have information about when this protocol was *authored.*)"
          },
          "files": {
            "items": {
              "$ref": "#/components/schemas/ProtocolFile"
            },
            "type": "array",
            "title": "Files"
          },
          "protocolType": {
            "$ref": "#/components/schemas/ProtocolType",
            "description": "The type of protocol file (JSON or Python)."
          },
          "robotType": {
            "type": "string",
            "enum": [
              "OT-2 Standard",
              "OT-3 Standard"
            ],
            "title": "Robottype",
            "description": "The type of robot that this protocol can run on."
          },
          "metadata": {
            "$ref": "#/components/schemas/robot_server__protocols__protocol_models__Metadata"
          },
          "analyses": {
            "items": {},
            "type": "array",
            "title": "Analyses",
            "description": "This field was deprecated for performance reasons. It will always be returned as an empty list. Use `analysisSummaries` and `GET /protocols/:id/analyses` instead."
          },
          "analysisSummaries": {
            "items": {
              "$ref": "#/components/schemas/AnalysisSummary"
            },
            "type": "array",
            "title": "Analysissummaries",
            "description": "Summaries of any analyses run to check how this protocol is expected to run. For more detailed information, use `GET /protocols/:id/analyses`.\n\nReturned in order from the least-recently started analysis to the most-recently started analysis."
          },
          "key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key",
            "description": "An arbitrary client-defined string, set when this protocol was uploaded. See `POST /protocols`."
          },
          "protocolKind": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ProtocolKind"
              },
              {
                "type": "null"
              }
            ],
            "description": "The kind of protocol (standard or quick-transfer).The client provides this field when the protocol is uploaded. See `POST /protocols`."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "files",
          "protocolType",
          "robotType",
          "metadata",
          "analysisSummaries",
          "protocolKind"
        ],
        "title": "Protocol",
        "description": "A model representing an uploaded protocol resource."
      },
      "ProtocolFile": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The file's basename, including extension"
          },
          "role": {
            "$ref": "#/components/schemas/ProtocolFileRole",
            "description": "The file's role in the protocol."
          }
        },
        "type": "object",
        "required": [
          "name",
          "role"
        ],
        "title": "ProtocolFile",
        "description": "A file in a protocol."
      },
      "ProtocolFileRole": {
        "type": "string",
        "enum": [
          "main",
          "labware",
          "data"
        ],
        "title": "ProtocolFileRole",
        "description": "The purpose of a given file in a protocol.\n\nArgs:\n    MAIN: The protocol's main file. In a JSON protocol, this is will\n        be the JSON file. In a Python protocol, this is the file\n        that exports the main `run` method.\n    LABWARE: A labware definition file, loadable by a\n        Python file in the same protocol.\n    DATA: An arbitrary text or csv file for usage in `bundled_data`\n        for a Python protool"
      },
      "ProtocolFilesInvalid": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ProtocolFilesInvalid"
            ],
            "const": "ProtocolFilesInvalid",
            "title": "Id",
            "default": "ProtocolFilesInvalid"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol File(s) Invalid"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ProtocolFilesInvalid",
        "description": "An error returned when an uploaded protocol files are invalid."
      },
      "ProtocolKind": {
        "type": "string",
        "enum": [
          "standard",
          "quick-transfer"
        ],
        "title": "ProtocolKind",
        "description": "Kind of protocol, standard or quick-transfer."
      },
      "ProtocolLinks": {
        "properties": {
          "referencingRuns": {
            "items": {
              "$ref": "#/components/schemas/RunLink"
            },
            "type": "array",
            "title": "Referencingruns",
            "description": "Links to runs that reference the protocol, in order from the oldest run to the newest run."
          }
        },
        "type": "object",
        "required": [
          "referencingRuns"
        ],
        "title": "ProtocolLinks",
        "description": "Links returned along with a protocol resource."
      },
      "ProtocolNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ProtocolNotFound"
            ],
            "const": "ProtocolNotFound",
            "title": "Id",
            "default": "ProtocolNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ProtocolNotFound",
        "description": "An error returned when a given protocol cannot be found."
      },
      "ProtocolRobotTypeMismatch": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ProtocolRobotTypeMismatch"
            ],
            "const": "ProtocolRobotTypeMismatch",
            "title": "Id",
            "default": "ProtocolRobotTypeMismatch"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol For Different Robot Type"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ProtocolRobotTypeMismatch",
        "description": "An error returned when an uploaded protocol is for a different type of robot.\n\nFor example, if the protocol is for an OT-3, but this server is running on an OT-2."
      },
      "ProtocolRunIsActive": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ProtocolRunIsActive"
            ],
            "const": "ProtocolRunIsActive",
            "title": "Id",
            "default": "ProtocolRunIsActive"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol Run Is Active"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ProtocolRunIsActive",
        "description": "An error if one tries to create a maintenance run while a protocol run is active."
      },
      "ProtocolType": {
        "type": "string",
        "enum": [
          "json",
          "python"
        ],
        "title": "ProtocolType",
        "description": "Type of protocol, JSON or Python."
      },
      "ProtocolUsedByRun": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "ProtocolUsedByRun"
            ],
            "const": "ProtocolUsedByRun",
            "title": "Id",
            "default": "ProtocolUsedByRun"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Protocol Used by Run"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "ProtocolUsedByRun",
        "description": "An error returned when a protocol is used by a run and cannot be deleted."
      },
      "QuadrantNozzleLayoutConfiguration": {
        "properties": {
          "style": {
            "type": "string",
            "enum": [
              "QUADRANT"
            ],
            "const": "QUADRANT",
            "title": "Style",
            "default": "QUADRANT"
          },
          "primaryNozzle": {
            "type": "string",
            "enum": [
              "A1",
              "H1",
              "A12",
              "H12"
            ],
            "title": "Primarynozzle",
            "description": "The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle."
          },
          "frontRightNozzle": {
            "type": "string",
            "pattern": "[A-Z]\\d{1,2}",
            "title": "Frontrightnozzle",
            "description": "The front right nozzle in your configuration."
          },
          "backLeftNozzle": {
            "type": "string",
            "pattern": "[A-Z]\\d{1,2}",
            "title": "Backleftnozzle",
            "description": "The back left nozzle in your configuration."
          }
        },
        "type": "object",
        "required": [
          "primaryNozzle",
          "frontRightNozzle",
          "backLeftNozzle"
        ],
        "title": "QuadrantNozzleLayoutConfiguration",
        "description": "Information required for nozzle configurations of type QUADRANT."
      },
      "ReactionIfMatch": {
        "type": "string",
        "enum": [
          "failRun",
          "waitForRecovery",
          "assumeFalsePositiveAndContinue",
          "ignoreAndContinue"
        ],
        "title": "ReactionIfMatch",
        "description": "How to handle a matching error.\n\n* `\"failRun\"`: Fail the run.\n\n* `\"waitForRecovery\"`: Enter interactive error recovery mode. You can then\n  perform error recovery with `POST /runs/{id}/commands` and exit error\n  recovery mode with `POST /runs/{id}/actions`.\n\n* `\"assumeFalsePositiveAndContinue\"`: Continue the run without interruption, acting\n  as if the error was a false positive.\n\n  This is equivalent to doing `\"waitForRecovery\"`\n  and then sending `actionType: \"resume-from-recovery-assuming-false-positive\"`\n  to `POST /runs/{id}/actions`, except this requires no ongoing intervention from\n  the client.\n\n* `\"ignoreAndContinue\"`: Continue the run without interruption, accepting whatever\n  state the error left the robot in.\n\n  This is equivalent to doing `\"waitForRecovery\"`\n  and then sending `actionType: \"resume-from-recovery\"` to `POST /runs/{id}/actions`,\n  except this requires no ongoing intervention from the client.\n\n  This is probably not useful very often because it's likely to cause downstream\n  errorsimagine trying an `aspirate` command after a failed `pickUpTip` command.\n  This is provided for symmetry."
      },
      "ReadAbsorbance": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/read"
            ],
            "const": "absorbanceReader/read",
            "title": "Commandtype",
            "default": "absorbanceReader/read"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/ReadAbsorbanceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReadAbsorbanceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "ReadAbsorbance",
        "description": "A command to execute an Absorbance Reader measurement."
      },
      "ReadAbsorbanceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/read"
            ],
            "const": "absorbanceReader/read",
            "title": "Commandtype",
            "default": "absorbanceReader/read"
          },
          "params": {
            "$ref": "#/components/schemas/ReadAbsorbanceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "ReadAbsorbanceCreate",
        "description": "A request to execute an Absorbance Reader measurement."
      },
      "ReadAbsorbanceParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Absorbance Reader."
          },
          "fileName": {
            "type": "string",
            "title": "Filename",
            "description": "Optional file name to use when storing the results of a measurement."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "ReadAbsorbanceParams",
        "description": "Input parameters for an absorbance reading."
      },
      "ReadAbsorbanceResult": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "additionalProperties": {
                  "additionalProperties": {
                    "type": "number"
                  },
                  "type": "object"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Data",
            "description": "Absorbance data points per wavelength."
          },
          "fileIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Fileids",
            "description": "List of file IDs for files output as a result of a Read action."
          }
        },
        "type": "object",
        "required": [
          "data",
          "fileIds"
        ],
        "title": "ReadAbsorbanceResult",
        "description": "Result data from running an aborbance reading, returned as a dictionary map of wavelengths containing a map of values by well name (eg. {450: {\"A1\": 0.0, ...}})."
      },
      "RectangularWellDefinition2": {
        "properties": {
          "depth": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Depth"
          },
          "totalLiquidVolume": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Totalliquidvolume"
          },
          "x": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Z"
          },
          "geometryDefinitionId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Geometrydefinitionid"
          },
          "shape": {
            "type": "string",
            "enum": [
              "rectangular"
            ],
            "const": "rectangular",
            "title": "Shape"
          },
          "xDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Xdimension"
          },
          "yDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Ydimension"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "depth",
          "totalLiquidVolume",
          "x",
          "y",
          "z",
          "shape",
          "xDimension",
          "yDimension"
        ],
        "title": "RectangularWellDefinition2"
      },
      "RectangularWellDefinition3": {
        "properties": {
          "depth": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Depth"
          },
          "totalLiquidVolume": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Totalliquidvolume"
          },
          "x": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Z"
          },
          "geometryDefinitionId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Geometrydefinitionid"
          },
          "shape": {
            "type": "string",
            "enum": [
              "rectangular"
            ],
            "const": "rectangular",
            "title": "Shape"
          },
          "xDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Xdimension"
          },
          "yDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Ydimension"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "depth",
          "totalLiquidVolume",
          "x",
          "y",
          "z",
          "shape",
          "xDimension",
          "yDimension"
        ],
        "title": "RectangularWellDefinition3"
      },
      "ReloadLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "reloadLabware"
            ],
            "const": "reloadLabware",
            "title": "Commandtype",
            "default": "reloadLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/ReloadLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ReloadLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "ReloadLabware",
        "description": "Reload labware command resource model."
      },
      "ReloadLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "reloadLabware"
            ],
            "const": "reloadLabware",
            "title": "Commandtype",
            "default": "reloadLabware"
          },
          "params": {
            "$ref": "#/components/schemas/ReloadLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "ReloadLabwareCreate",
        "description": "Reload labware command creation request."
      },
      "ReloadLabwareParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The already-loaded labware instance to update."
          }
        },
        "type": "object",
        "required": [
          "labwareId"
        ],
        "title": "ReloadLabwareParams",
        "description": "Payload required to load a labware into a slot."
      },
      "ReloadLabwareResult": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The id of the labware."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locationsequence",
            "description": "The full location down to the deck on which this labware exists."
          },
          "offsetId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offsetid",
            "description": "An ID referencing the labware offset that will apply to this labware in this location."
          }
        },
        "type": "object",
        "required": [
          "labwareId"
        ],
        "title": "ReloadLabwareResult",
        "description": "Result data from the execution of a LoadLabware command."
      },
      "RequestData": {
        "properties": {
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "If provided, globally enables or disables error recovery mode.\n\nIf this is `true`, a run (see the `/runs` endpoints) will *potentially*\nenter recovery mode when an error happens, depending on the details of\nthe error and depending on `/runs/{runId}/errorRecoveryPolicy`.\n\nIf this is `false`, a run will just fail if it encounters an error.\n\nThe default is `true`. This currently only has an effect on Flex robots.\nOn OT-2s, error recovery is not supported.\n"
          }
        },
        "type": "object",
        "title": "RequestData",
        "description": "Request body data for `PATCH /errorRecovery/settings`."
      },
      "RequestModel_AnalysisRequest_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/AnalysisRequest",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[AnalysisRequest]"
      },
      "RequestModel_Annotated_Union_AirGapInPlaceCreate__AspirateCreate__AspirateWhileTrackingCreate__AspirateInPlaceCreate__CommentCreate__ConfigureForVolumeCreate__ConfigureNozzleLayoutCreate__CustomCreate__DispenseCreate__DispenseInPlaceCreate__DispenseWhileTrackingCreate__BlowOutCreate__BlowOutInPlaceCreate__DropTipCreate__DropTipInPlaceCreate__HomeCreate__RetractAxisCreate__LoadLabwareCreate__ReloadLabwareCreate__LoadLiquidCreate__LoadLiquidClassCreate__LoadModuleCreate__LoadPipetteCreate__LoadLidStackCreate__LoadLidCreate__MoveLabwareCreate__MoveRelativeCreate__MoveToCoordinatesCreate__MoveToWellCreate__MoveToAddressableAreaCreate__MoveToAddressableAreaForDropTipCreate__PrepareToAspirateCreate__WaitForResumeCreate__WaitForDurationCreate__PickUpTipCreate__SavePositionCreate__SetRailLightsCreate__TouchTipCreate__SetStatusBarCreate__VerifyTipPresenceCreate__GetTipPresenceCreate__GetNextTipCreate__LiquidProbeCreate__TryLiquidProbeCreate__EvotipSealPipetteCreate__EvotipDispenseCreate__EvotipUnsealPipetteCreate__WaitForTemperatureCreate__SetTargetTemperatureCreate__DeactivateHeaterCreate__SetAndWaitForShakeSpeedCreate__DeactivateShakerCreate__OpenLabwareLatchCreate__CloseLabwareLatchCreate__DisengageCreate__EngageCreate__SetTargetTemperatureCreate__WaitForTemperatureCreate__DeactivateTemperatureCreate__SetTargetBlockTemperatureCreate__WaitForBlockTemperatureCreate__SetTargetLidTemperatureCreate__WaitForLidTemperatureCreate__DeactivateBlockCreate__DeactivateLidCreate__OpenLidCreate__CloseLidCreate__RunProfileCreate__RunExtendedProfileCreate__CloseLidCreate__OpenLidCreate__InitializeCreate__ReadAbsorbanceCreate__RetrieveCreate__StoreCreate__SetStoredLabwareCreate__FillCreate__EmptyCreate__CalibrateGripperCreate__CalibratePipetteCreate__CalibrateModuleCreate__MoveToMaintenancePositionCreate__UnsafeBlowOutInPlaceCreate__UnsafeDropTipInPlaceCreate__UpdatePositionEstimatorsCreate__UnsafeEngageAxesCreate__UnsafeUngripLabwareCreate__UnsafePlaceLabwareCreate__MoveAxesRelativeCreate__MoveAxesToCreate__MoveToCreate__openGripperJawCreate__closeGripperJawCreate___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____": {
        "properties": {
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AirGapInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/AspirateCreate"
              },
              {
                "$ref": "#/components/schemas/AspirateWhileTrackingCreate"
              },
              {
                "$ref": "#/components/schemas/AspirateInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/CommentCreate"
              },
              {
                "$ref": "#/components/schemas/ConfigureForVolumeCreate"
              },
              {
                "$ref": "#/components/schemas/ConfigureNozzleLayoutCreate"
              },
              {
                "$ref": "#/components/schemas/CustomCreate"
              },
              {
                "$ref": "#/components/schemas/DispenseCreate"
              },
              {
                "$ref": "#/components/schemas/DispenseInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/DispenseWhileTrackingCreate"
              },
              {
                "$ref": "#/components/schemas/BlowOutCreate"
              },
              {
                "$ref": "#/components/schemas/BlowOutInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/DropTipCreate"
              },
              {
                "$ref": "#/components/schemas/DropTipInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/HomeCreate"
              },
              {
                "$ref": "#/components/schemas/RetractAxisCreate"
              },
              {
                "$ref": "#/components/schemas/LoadLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/ReloadLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/LoadLiquidCreate"
              },
              {
                "$ref": "#/components/schemas/LoadLiquidClassCreate"
              },
              {
                "$ref": "#/components/schemas/LoadModuleCreate"
              },
              {
                "$ref": "#/components/schemas/LoadPipetteCreate"
              },
              {
                "$ref": "#/components/schemas/LoadLidStackCreate"
              },
              {
                "$ref": "#/components/schemas/LoadLidCreate"
              },
              {
                "$ref": "#/components/schemas/MoveLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/MoveRelativeCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToCoordinatesCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToWellCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaForDropTipCreate"
              },
              {
                "$ref": "#/components/schemas/PrepareToAspirateCreate"
              },
              {
                "$ref": "#/components/schemas/WaitForResumeCreate"
              },
              {
                "$ref": "#/components/schemas/WaitForDurationCreate"
              },
              {
                "$ref": "#/components/schemas/PickUpTipCreate"
              },
              {
                "$ref": "#/components/schemas/SavePositionCreate"
              },
              {
                "$ref": "#/components/schemas/SetRailLightsCreate"
              },
              {
                "$ref": "#/components/schemas/TouchTipCreate"
              },
              {
                "$ref": "#/components/schemas/SetStatusBarCreate"
              },
              {
                "$ref": "#/components/schemas/VerifyTipPresenceCreate"
              },
              {
                "$ref": "#/components/schemas/GetTipPresenceCreate"
              },
              {
                "$ref": "#/components/schemas/GetNextTipCreate"
              },
              {
                "$ref": "#/components/schemas/LiquidProbeCreate"
              },
              {
                "$ref": "#/components/schemas/TryLiquidProbeCreate"
              },
              {
                "$ref": "#/components/schemas/EvotipSealPipetteCreate"
              },
              {
                "$ref": "#/components/schemas/EvotipDispenseCreate"
              },
              {
                "$ref": "#/components/schemas/EvotipUnsealPipetteCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateHeaterCreate"
              },
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeedCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateShakerCreate"
              },
              {
                "$ref": "#/components/schemas/OpenLabwareLatchCreate"
              },
              {
                "$ref": "#/components/schemas/CloseLabwareLatchCreate"
              },
              {
                "$ref": "#/components/schemas/DisengageCreate"
              },
              {
                "$ref": "#/components/schemas/EngageCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/WaitForBlockTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/SetTargetLidTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/WaitForLidTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateBlockCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidCreate"
              },
              {
                "$ref": "#/components/schemas/RunProfileCreate"
              },
              {
                "$ref": "#/components/schemas/RunExtendedProfileCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidCreate"
              },
              {
                "$ref": "#/components/schemas/InitializeCreate"
              },
              {
                "$ref": "#/components/schemas/ReadAbsorbanceCreate"
              },
              {
                "$ref": "#/components/schemas/RetrieveCreate"
              },
              {
                "$ref": "#/components/schemas/StoreCreate"
              },
              {
                "$ref": "#/components/schemas/SetStoredLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/FillCreate"
              },
              {
                "$ref": "#/components/schemas/EmptyCreate"
              },
              {
                "$ref": "#/components/schemas/CalibrateGripperCreate"
              },
              {
                "$ref": "#/components/schemas/CalibratePipetteCreate"
              },
              {
                "$ref": "#/components/schemas/CalibrateModuleCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToMaintenancePositionCreate"
              },
              {
                "$ref": "#/components/schemas/UnsafeBlowOutInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/UnsafeDropTipInPlaceCreate"
              },
              {
                "$ref": "#/components/schemas/UpdatePositionEstimatorsCreate"
              },
              {
                "$ref": "#/components/schemas/UnsafeEngageAxesCreate"
              },
              {
                "$ref": "#/components/schemas/UnsafeUngripLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/UnsafePlaceLabwareCreate"
              },
              {
                "$ref": "#/components/schemas/MoveAxesRelativeCreate"
              },
              {
                "$ref": "#/components/schemas/MoveAxesToCreate"
              },
              {
                "$ref": "#/components/schemas/MoveToCreate"
              },
              {
                "$ref": "#/components/schemas/openGripperJawCreate"
              },
              {
                "$ref": "#/components/schemas/closeGripperJawCreate"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'",
            "discriminator": {
              "propertyName": "commandType",
              "mapping": {
                "absorbanceReader/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidCreate",
                "absorbanceReader/initialize": "#/components/schemas/InitializeCreate",
                "absorbanceReader/openLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidCreate",
                "absorbanceReader/read": "#/components/schemas/ReadAbsorbanceCreate",
                "airGapInPlace": "#/components/schemas/AirGapInPlaceCreate",
                "aspirate": "#/components/schemas/AspirateCreate",
                "aspirateInPlace": "#/components/schemas/AspirateInPlaceCreate",
                "aspirateWhileTracking": "#/components/schemas/AspirateWhileTrackingCreate",
                "blowOutInPlace": "#/components/schemas/BlowOutInPlaceCreate",
                "blowout": "#/components/schemas/BlowOutCreate",
                "calibration/calibrateGripper": "#/components/schemas/CalibrateGripperCreate",
                "calibration/calibrateModule": "#/components/schemas/CalibrateModuleCreate",
                "calibration/calibratePipette": "#/components/schemas/CalibratePipetteCreate",
                "calibration/moveToMaintenancePosition": "#/components/schemas/MoveToMaintenancePositionCreate",
                "comment": "#/components/schemas/CommentCreate",
                "configureForVolume": "#/components/schemas/ConfigureForVolumeCreate",
                "configureNozzleLayout": "#/components/schemas/ConfigureNozzleLayoutCreate",
                "custom": "#/components/schemas/CustomCreate",
                "dispense": "#/components/schemas/DispenseCreate",
                "dispenseInPlace": "#/components/schemas/DispenseInPlaceCreate",
                "dispenseWhileTracking": "#/components/schemas/DispenseWhileTrackingCreate",
                "dropTip": "#/components/schemas/DropTipCreate",
                "dropTipInPlace": "#/components/schemas/DropTipInPlaceCreate",
                "evotipDispense": "#/components/schemas/EvotipDispenseCreate",
                "evotipSealPipette": "#/components/schemas/EvotipSealPipetteCreate",
                "evotipUnsealPipette": "#/components/schemas/EvotipUnsealPipetteCreate",
                "flexStacker/empty": "#/components/schemas/EmptyCreate",
                "flexStacker/fill": "#/components/schemas/FillCreate",
                "flexStacker/retrieve": "#/components/schemas/RetrieveCreate",
                "flexStacker/setStoredLabware": "#/components/schemas/SetStoredLabwareCreate",
                "flexStacker/store": "#/components/schemas/StoreCreate",
                "getNextTip": "#/components/schemas/GetNextTipCreate",
                "getTipPresence": "#/components/schemas/GetTipPresenceCreate",
                "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatchCreate",
                "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeaterCreate",
                "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShakerCreate",
                "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatchCreate",
                "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeedCreate",
                "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureCreate",
                "heaterShaker/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureCreate",
                "home": "#/components/schemas/HomeCreate",
                "liquidProbe": "#/components/schemas/LiquidProbeCreate",
                "loadLabware": "#/components/schemas/LoadLabwareCreate",
                "loadLid": "#/components/schemas/LoadLidCreate",
                "loadLidStack": "#/components/schemas/LoadLidStackCreate",
                "loadLiquid": "#/components/schemas/LoadLiquidCreate",
                "loadLiquidClass": "#/components/schemas/LoadLiquidClassCreate",
                "loadModule": "#/components/schemas/LoadModuleCreate",
                "loadPipette": "#/components/schemas/LoadPipetteCreate",
                "magneticModule/disengage": "#/components/schemas/DisengageCreate",
                "magneticModule/engage": "#/components/schemas/EngageCreate",
                "moveLabware": "#/components/schemas/MoveLabwareCreate",
                "moveRelative": "#/components/schemas/MoveRelativeCreate",
                "moveToAddressableArea": "#/components/schemas/MoveToAddressableAreaCreate",
                "moveToAddressableAreaForDropTip": "#/components/schemas/MoveToAddressableAreaForDropTipCreate",
                "moveToCoordinates": "#/components/schemas/MoveToCoordinatesCreate",
                "moveToWell": "#/components/schemas/MoveToWellCreate",
                "pause": "#/components/schemas/WaitForResumeCreate",
                "pickUpTip": "#/components/schemas/PickUpTipCreate",
                "prepareToAspirate": "#/components/schemas/PrepareToAspirateCreate",
                "reloadLabware": "#/components/schemas/ReloadLabwareCreate",
                "retractAxis": "#/components/schemas/RetractAxisCreate",
                "robot/closeGripperJaw": "#/components/schemas/closeGripperJawCreate",
                "robot/moveAxesRelative": "#/components/schemas/MoveAxesRelativeCreate",
                "robot/moveAxesTo": "#/components/schemas/MoveAxesToCreate",
                "robot/moveTo": "#/components/schemas/MoveToCreate",
                "robot/openGripperJaw": "#/components/schemas/openGripperJawCreate",
                "savePosition": "#/components/schemas/SavePositionCreate",
                "setRailLights": "#/components/schemas/SetRailLightsCreate",
                "setStatusBar": "#/components/schemas/SetStatusBarCreate",
                "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperatureCreate",
                "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureCreate",
                "temperatureModule/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureCreate",
                "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidCreate",
                "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlockCreate",
                "thermocycler/deactivateLid": "#/components/schemas/DeactivateLidCreate",
                "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidCreate",
                "thermocycler/runExtendedProfile": "#/components/schemas/RunExtendedProfileCreate",
                "thermocycler/runProfile": "#/components/schemas/RunProfileCreate",
                "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperatureCreate",
                "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperatureCreate",
                "thermocycler/waitForBlockTemperature": "#/components/schemas/WaitForBlockTemperatureCreate",
                "thermocycler/waitForLidTemperature": "#/components/schemas/WaitForLidTemperatureCreate",
                "touchTip": "#/components/schemas/TouchTipCreate",
                "tryLiquidProbe": "#/components/schemas/TryLiquidProbeCreate",
                "unsafe/blowOutInPlace": "#/components/schemas/UnsafeBlowOutInPlaceCreate",
                "unsafe/dropTipInPlace": "#/components/schemas/UnsafeDropTipInPlaceCreate",
                "unsafe/engageAxes": "#/components/schemas/UnsafeEngageAxesCreate",
                "unsafe/placeLabware": "#/components/schemas/UnsafePlaceLabwareCreate",
                "unsafe/ungripLabware": "#/components/schemas/UnsafeUngripLabwareCreate",
                "unsafe/updatePositionEstimators": "#/components/schemas/UpdatePositionEstimatorsCreate",
                "verifyTipPresence": "#/components/schemas/VerifyTipPresenceCreate",
                "waitForDuration": "#/components/schemas/WaitForDurationCreate",
                "waitForResume": "#/components/schemas/WaitForResumeCreate"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Annotated[Union[AirGapInPlaceCreate, AspirateCreate, AspirateWhileTrackingCreate, AspirateInPlaceCreate, CommentCreate, ConfigureForVolumeCreate, ConfigureNozzleLayoutCreate, CustomCreate, DispenseCreate, DispenseInPlaceCreate, DispenseWhileTrackingCreate, BlowOutCreate, BlowOutInPlaceCreate, DropTipCreate, DropTipInPlaceCreate, HomeCreate, RetractAxisCreate, LoadLabwareCreate, ReloadLabwareCreate, LoadLiquidCreate, LoadLiquidClassCreate, LoadModuleCreate, LoadPipetteCreate, LoadLidStackCreate, LoadLidCreate, MoveLabwareCreate, MoveRelativeCreate, MoveToCoordinatesCreate, MoveToWellCreate, MoveToAddressableAreaCreate, MoveToAddressableAreaForDropTipCreate, PrepareToAspirateCreate, WaitForResumeCreate, WaitForDurationCreate, PickUpTipCreate, SavePositionCreate, SetRailLightsCreate, TouchTipCreate, SetStatusBarCreate, VerifyTipPresenceCreate, GetTipPresenceCreate, GetNextTipCreate, LiquidProbeCreate, TryLiquidProbeCreate, EvotipSealPipetteCreate, EvotipDispenseCreate, EvotipUnsealPipetteCreate, WaitForTemperatureCreate, SetTargetTemperatureCreate, DeactivateHeaterCreate, SetAndWaitForShakeSpeedCreate, DeactivateShakerCreate, OpenLabwareLatchCreate, CloseLabwareLatchCreate, DisengageCreate, EngageCreate, SetTargetTemperatureCreate, WaitForTemperatureCreate, DeactivateTemperatureCreate, SetTargetBlockTemperatureCreate, WaitForBlockTemperatureCreate, SetTargetLidTemperatureCreate, WaitForLidTemperatureCreate, DeactivateBlockCreate, DeactivateLidCreate, OpenLidCreate, CloseLidCreate, RunProfileCreate, RunExtendedProfileCreate, CloseLidCreate, OpenLidCreate, InitializeCreate, ReadAbsorbanceCreate, RetrieveCreate, StoreCreate, SetStoredLabwareCreate, FillCreate, EmptyCreate, CalibrateGripperCreate, CalibratePipetteCreate, CalibrateModuleCreate, MoveToMaintenancePositionCreate, UnsafeBlowOutInPlaceCreate, UnsafeDropTipInPlaceCreate, UpdatePositionEstimatorsCreate, UnsafeEngageAxesCreate, UnsafeUngripLabwareCreate, UnsafePlaceLabwareCreate, MoveAxesRelativeCreate, MoveAxesToCreate, MoveToCreate, openGripperJawCreate, closeGripperJawCreate], FieldInfo(annotation=NoneType, required=True, discriminator='commandType')]]"
      },
      "RequestModel_Annotated_Union_HomeCreate__SetRailLightsCreate__SetStatusBarCreate__EngageCreate__DisengageCreate__SetTargetTemperatureCreate__DeactivateTemperatureCreate__SetTargetBlockTemperatureCreate__SetTargetLidTemperatureCreate__DeactivateBlockCreate__DeactivateLidCreate__OpenLidCreate__CloseLidCreate__SetTargetTemperatureCreate__SetAndWaitForShakeSpeedCreate__DeactivateHeaterCreate__DeactivateShakerCreate__OpenLabwareLatchCreate__CloseLabwareLatchCreate___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____": {
        "properties": {
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/HomeCreate"
              },
              {
                "$ref": "#/components/schemas/SetRailLightsCreate"
              },
              {
                "$ref": "#/components/schemas/SetStatusBarCreate"
              },
              {
                "$ref": "#/components/schemas/EngageCreate"
              },
              {
                "$ref": "#/components/schemas/DisengageCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/SetTargetLidTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateBlockCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidCreate"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureCreate"
              },
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeedCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateHeaterCreate"
              },
              {
                "$ref": "#/components/schemas/DeactivateShakerCreate"
              },
              {
                "$ref": "#/components/schemas/OpenLabwareLatchCreate"
              },
              {
                "$ref": "#/components/schemas/CloseLabwareLatchCreate"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'",
            "discriminator": {
              "propertyName": "commandType",
              "mapping": {
                "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatchCreate",
                "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeaterCreate",
                "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShakerCreate",
                "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatchCreate",
                "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeedCreate",
                "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureCreate",
                "home": "#/components/schemas/HomeCreate",
                "magneticModule/disengage": "#/components/schemas/DisengageCreate",
                "magneticModule/engage": "#/components/schemas/EngageCreate",
                "setRailLights": "#/components/schemas/SetRailLightsCreate",
                "setStatusBar": "#/components/schemas/SetStatusBarCreate",
                "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperatureCreate",
                "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureCreate",
                "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidCreate",
                "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlockCreate",
                "thermocycler/deactivateLid": "#/components/schemas/DeactivateLidCreate",
                "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidCreate",
                "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperatureCreate",
                "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperatureCreate"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Annotated[Union[HomeCreate, SetRailLightsCreate, SetStatusBarCreate, EngageCreate, DisengageCreate, SetTargetTemperatureCreate, DeactivateTemperatureCreate, SetTargetBlockTemperatureCreate, SetTargetLidTemperatureCreate, DeactivateBlockCreate, DeactivateLidCreate, OpenLidCreate, CloseLidCreate, SetTargetTemperatureCreate, SetAndWaitForShakeSpeedCreate, DeactivateHeaterCreate, DeactivateShakerCreate, OpenLabwareLatchCreate, CloseLabwareLatchCreate], FieldInfo(annotation=NoneType, required=True, discriminator='commandType')]]"
      },
      "RequestModel_Annotated_Union_LabwareDefinition2__LabwareDefinition3___Discriminator__": {
        "properties": {
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LabwareDefinition2"
              },
              {
                "$ref": "#/components/schemas/LabwareDefinition3"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'",
            "discriminator": {
              "propertyName": "schemaVersion",
              "mapping": {
                "2": "#/components/schemas/LabwareDefinition2",
                "3": "#/components/schemas/LabwareDefinition3"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Annotated[Union[LabwareDefinition2, LabwareDefinition3], Discriminator]]"
      },
      "RequestModel_DeckConfigurationRequest_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/DeckConfigurationRequest",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[DeckConfigurationRequest]"
      },
      "RequestModel_ErrorRecoveryPolicy_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/ErrorRecoveryPolicy",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[ErrorRecoveryPolicy]"
      },
      "RequestModel_MaintenanceRunCreate_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/MaintenanceRunCreate",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[MaintenanceRunCreate]"
      },
      "RequestModel_RequestData_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RequestData",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[RequestData]"
      },
      "RequestModel_RunActionCreate_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunActionCreate",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[RunActionCreate]"
      },
      "RequestModel_RunCreate_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunCreate",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[RunCreate]"
      },
      "RequestModel_RunUpdate_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunUpdate",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[RunUpdate]"
      },
      "RequestModel_SearchCreate_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/SearchCreate",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[SearchCreate]"
      },
      "RequestModel_SystemTimeAttributes_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/SystemTimeAttributes",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[SystemTimeAttributes]"
      },
      "RequestModel_Union_CalibrationCheckCreateAttributes__TipLengthCalibrationCreateAttributes__DeckCalibrationCreateAttributes__PipetteOffsetCalibrationCreateAttributes__": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CalibrationCheckCreateAttributes"
              },
              {
                "$ref": "#/components/schemas/TipLengthCalibrationCreateAttributes"
              },
              {
                "$ref": "#/components/schemas/DeckCalibrationCreateAttributes"
              },
              {
                "$ref": "#/components/schemas/PipetteOffsetCalibrationCreateAttributes"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Union[CalibrationCheckCreateAttributes, TipLengthCalibrationCreateAttributes, DeckCalibrationCreateAttributes, PipetteOffsetCalibrationCreateAttributes]]"
      },
      "RequestModel_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate__list_Union_LabwareOffsetCreate__LegacyLabwareOffsetCreate____": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LabwareOffsetCreate"
              },
              {
                "$ref": "#/components/schemas/LegacyLabwareOffsetCreate"
              },
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LabwareOffsetCreate"
                    },
                    {
                      "$ref": "#/components/schemas/LegacyLabwareOffsetCreate"
                    }
                  ]
                },
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Union[LabwareOffsetCreate, LegacyLabwareOffsetCreate, list[Union[LabwareOffsetCreate, LegacyLabwareOffsetCreate]]]]"
      },
      "RequestModel_Union_SessionCommandRequest_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition___EmptyModel__EmptyModel___SessionCommandRequest_Literal_load_labware___LoadLabwareCreate__LoadLabwareResult___SessionCommandRequest_Literal_load_pipette___LoadPipetteCreate__LoadPipetteResult___SessionCommandRequest_Literal_aspirate___AspirateCreate__AspirateResult___SessionCommandRequest_Literal_dispense___DispenseCreate__DispenseResult___SessionCommandRequest_Literal_pick_up_tip___PickUpTipCreate__PickUpTipResult___SessionCommandRequest_Literal_drop_tip___DropTipCreate__DropTipResult___SessionCommandRequest_Literal_jog___JogPosition__EmptyModel___SessionCommandRequest_Literal_set_has_calibration_block___SetHasCalibrationBlockRequestData__EmptyModel___SessionCommandRequest_Literal_load_labware___LoadLabwareByDefinitionRequestData__EmptyModel___": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition__EmptyModel_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_load_labware__LoadLabwareCreate_LoadLabwareResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_load_pipette__LoadPipetteCreate_LoadPipetteResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_aspirate__AspirateCreate_AspirateResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_dispense__DispenseCreate_DispenseResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_pick_up_tip__PickUpTipCreate_PickUpTipResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_drop_tip__DropTipCreate_DropTipResult_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_jog__JogPosition_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_set_has_calibration_block__SetHasCalibrationBlockRequestData_EmptyModel_"
              },
              {
                "$ref": "#/components/schemas/SessionCommandRequest_Literal_load_labware__LoadLabwareByDefinitionRequestData_EmptyModel_"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Union[SessionCommandRequest[Literal[<ProtocolCommand.start_run: 'protocol.startRun'>, <ProtocolCommand.start_simulate: 'protocol.startSimulate'>, <ProtocolCommand.cancel: 'protocol.cancel'>, <ProtocolCommand.pause: 'protocol.pause'>, <ProtocolCommand.resume: 'protocol.resume'>, <CalibrationCommand.move_to_tip_rack: 'calibration.moveToTipRack'>, <CalibrationCommand.move_to_point_one: 'calibration.moveToPointOne'>, <CalibrationCommand.move_to_deck: 'calibration.moveToDeck'>, <CalibrationCommand.move_to_reference_point: 'calibration.moveToReferencePoint'>, <CalibrationCommand.pick_up_tip: 'calibration.pickUpTip'>, <CalibrationCommand.confirm_tip_attached: 'calibration.confirmTip'>, <CalibrationCommand.invalidate_tip: 'calibration.invalidateTip'>, <CalibrationCommand.save_offset: 'calibration.saveOffset'>, <CalibrationCommand.exit: 'calibration.exitSession'>, <CalibrationCommand.invalidate_last_action: 'calibration.invalidateLastAction'>, <DeckCalibrationCommand.move_to_point_two: 'calibration.deck.moveToPointTwo'>, <DeckCalibrationCommand.move_to_point_three: 'calibration.deck.moveToPointThree'>, <CheckCalibrationCommand.compare_point: 'calibration.check.comparePoint'>, <CheckCalibrationCommand.switch_pipette: 'calibration.check.switchPipette'>, <CheckCalibrationCommand.return_tip: 'calibration.check.returnTip'>, <CheckCalibrationCommand.transition: 'calibration.check.transition'>], EmptyModel, EmptyModel], SessionCommandRequest[Literal[<EquipmentCommand.load_labware: 'equipment.loadLabware'>], LoadLabwareCreate, LoadLabwareResult], SessionCommandRequest[Literal[<EquipmentCommand.load_pipette: 'equipment.loadPipette'>], LoadPipetteCreate, LoadPipetteResult], SessionCommandRequest[Literal[<PipetteCommand.aspirate: 'pipette.aspirate'>], AspirateCreate, AspirateResult], SessionCommandRequest[Literal[<PipetteCommand.dispense: 'pipette.dispense'>], DispenseCreate, DispenseResult], SessionCommandRequest[Literal[<PipetteCommand.pick_up_tip: 'pipette.pickUpTip'>], PickUpTipCreate, PickUpTipResult], SessionCommandRequest[Literal[<PipetteCommand.drop_tip: 'pipette.dropTip'>], DropTipCreate, DropTipResult], SessionCommandRequest[Literal[<CalibrationCommand.jog: 'calibration.jog'>], JogPosition, EmptyModel], SessionCommandRequest[Literal[<CalibrationCommand.set_has_calibration_block: 'calibration.setHasCalibrationBlock'>], SetHasCalibrationBlockRequestData, EmptyModel], SessionCommandRequest[Literal[<CalibrationCommand.load_labware: 'calibration.loadLabware'>], LoadLabwareByDefinitionRequestData, EmptyModel]]]"
      },
      "RequestModel_Union_StoredLabwareOffsetCreate__list_StoredLabwareOffsetCreate___": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StoredLabwareOffsetCreate"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/StoredLabwareOffsetCreate"
                },
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[Union[StoredLabwareOffsetCreate, list[StoredLabwareOffsetCreate]]]"
      },
      "RequestModel_dict_str__object__": {
        "properties": {
          "data": {
            "type": "object",
            "title": "Data",
            "description": "the documents 'primary data'"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "RequestModel[dict[str, object]]"
      },
      "RequiredLabware": {
        "properties": {
          "slot": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "title": "Slot"
          },
          "loadName": {
            "type": "string",
            "title": "Loadname"
          },
          "namespace": {
            "type": "string",
            "title": "Namespace"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "isTiprack": {
            "type": "boolean",
            "title": "Istiprack"
          },
          "definition": {
            "type": "object",
            "title": "Definition"
          }
        },
        "type": "object",
        "required": [
          "slot",
          "loadName",
          "namespace",
          "version",
          "isTiprack",
          "definition"
        ],
        "title": "RequiredLabware",
        "description": "A model that describes a single labware required for performing a\ncalibration action."
      },
      "ResetOptionId": {
        "type": "string",
        "enum": [
          "bootScripts",
          "deckCalibration",
          "deckConfiguration",
          "pipetteOffsetCalibrations",
          "gripperOffsetCalibrations",
          "tipLengthCalibrations",
          "runsHistory",
          "onDeviceDisplay",
          "moduleCalibration",
          "authorizedKeys"
        ],
        "title": "ResetOptionId",
        "description": "The available reset options"
      },
      "ResourceLink": {
        "properties": {
          "href": {
            "type": "string",
            "title": "Href",
            "description": "The links URL"
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "Metadata about the link"
          }
        },
        "type": "object",
        "required": [
          "href"
        ],
        "title": "ResourceLink",
        "description": "https://jsonapi.org/format/#document-links"
      },
      "ResponseData": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether error recovery mode is globally enabled.\nSee `PATCH /errorRecovery/settings`.\n"
          }
        },
        "type": "object",
        "required": [
          "enabled"
        ],
        "title": "ResponseData",
        "description": "Response body data from the `/errorRecovery/settings` endpoints."
      },
      "RetractAspirate": {
        "properties": {
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for retract after aspirate."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for retract after aspirate."
          },
          "speed": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Speed",
            "description": "Speed of retraction, in millimeters per second."
          },
          "airGapByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Airgapbyvolume",
            "description": "Settings for air gap keyed by target aspiration volume."
          },
          "touchTip": {
            "$ref": "#/components/schemas/TouchTipProperties",
            "description": "Touch tip settings for retract after aspirate."
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay settings for retract after aspirate."
          }
        },
        "type": "object",
        "required": [
          "positionReference",
          "offset",
          "speed",
          "airGapByVolume",
          "touchTip",
          "delay"
        ],
        "title": "RetractAspirate",
        "description": "Shared properties for the retract function after aspiration."
      },
      "RetractAxis": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "retractAxis"
            ],
            "const": "retractAxis",
            "title": "Commandtype",
            "default": "retractAxis"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/RetractAxisParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RetractAxisResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "RetractAxis",
        "description": "Command to retract the specified axis to its home position."
      },
      "RetractAxisCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "retractAxis"
            ],
            "const": "retractAxis",
            "title": "Commandtype",
            "default": "retractAxis"
          },
          "params": {
            "$ref": "#/components/schemas/RetractAxisParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "RetractAxisCreate",
        "description": "Data to create a Retract Axis command."
      },
      "RetractAxisParams": {
        "properties": {
          "axis": {
            "$ref": "#/components/schemas/MotorAxis",
            "description": "Axis to retract to its home position as quickly as safely possible. The difference between retracting an axis and homing an axis using the home command is that a home will always probe the limit switch and will work as the first motion command a robot will need to execute; On the other hand, retraction will rely on this previously determined  home position to move to it as fast as safely possible. So on the Flex, it will move (fast) the axis to the previously recorded home position and on the OT2, it will move (fast) the axis a safe distance from the previously recorded home position, and then slowly approach the limit switch."
          }
        },
        "type": "object",
        "required": [
          "axis"
        ],
        "title": "RetractAxisParams",
        "description": "Payload required for a Retract Axis command."
      },
      "RetractAxisResult": {
        "properties": {},
        "type": "object",
        "title": "RetractAxisResult",
        "description": "Result data from the execution of a Rectract Axis command."
      },
      "RetractDispense": {
        "properties": {
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for retract after dispense."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for retract after dispense."
          },
          "speed": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Speed",
            "description": "Speed of retraction, in millimeters per second."
          },
          "airGapByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Airgapbyvolume",
            "description": "Settings for air gap keyed by target aspiration volume."
          },
          "blowout": {
            "$ref": "#/components/schemas/BlowoutProperties",
            "description": "Blowout properties for retract after dispense."
          },
          "touchTip": {
            "$ref": "#/components/schemas/TouchTipProperties",
            "description": "Touch tip settings for retract after dispense."
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay settings for retract after dispense."
          }
        },
        "type": "object",
        "required": [
          "positionReference",
          "offset",
          "speed",
          "airGapByVolume",
          "blowout",
          "touchTip",
          "delay"
        ],
        "title": "RetractDispense",
        "description": "Shared properties for the retract function after dispense."
      },
      "Retrieve": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/retrieve"
            ],
            "const": "flexStacker/retrieve",
            "title": "Commandtype",
            "default": "flexStacker/retrieve"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/RetrieveParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RetrieveResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Retrieve",
        "description": "A command to retrieve a labware from a Flex Stacker."
      },
      "RetrieveCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/retrieve"
            ],
            "const": "flexStacker/retrieve",
            "title": "Commandtype",
            "default": "flexStacker/retrieve"
          },
          "params": {
            "$ref": "#/components/schemas/RetrieveParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "RetrieveCreate",
        "description": "A request to execute a Flex Stacker retrieve command."
      },
      "RetrieveParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Flex Stacker."
          },
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "An optional ID to assign to this labware. If None, an ID will be generated."
          },
          "displayName": {
            "type": "string",
            "title": "Displayname",
            "description": "An optional user-specified display name or label for this labware."
          },
          "adapterId": {
            "type": "string",
            "title": "Adapterid",
            "description": "An optional ID to assign to an adapter. If None, an ID will be generated."
          },
          "lidId": {
            "type": "string",
            "title": "Lidid",
            "description": "An optional ID to assign to a lid. If None, an ID will be generated."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "RetrieveParams",
        "description": "Input parameters for a labware retrieval command."
      },
      "RetrieveResult": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "The labware ID of the primary retrieved labware."
          },
          "adapterId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterid",
            "description": "The optional Adapter Labware ID of the adapter under a primary labware."
          },
          "lidId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidid",
            "description": "The optional Lid Labware ID of the lid on a primary labware."
          },
          "primaryLocationSequence": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/InStackerHopperLocation"
                }
              ]
            },
            "type": "array",
            "title": "Primarylocationsequence",
            "description": "The origin location of the primary labware."
          },
          "lidLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlocationsequence",
            "description": "The origin location of the adapter labware under a primary labware."
          },
          "adapterLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlocationsequence",
            "description": "The origin location of the lid labware on a primary labware."
          },
          "primaryLabwareURI": {
            "type": "string",
            "title": "Primarylabwareuri",
            "description": "The labware definition URI of the primary labware."
          },
          "adapterLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwareuri",
            "description": "The labware definition URI of the adapter labware."
          },
          "lidLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwareuri",
            "description": "The labware definition URI of the lid labware."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "primaryLocationSequence",
          "primaryLabwareURI"
        ],
        "title": "RetrieveResult",
        "description": "Result data from a labware retrieval command."
      },
      "RobotHomeTarget": {
        "properties": {
          "target": {
            "$ref": "#/components/schemas/HomeTarget",
            "description": "What to home. Robot means to home all axes; pipette, only that pipette's carriage and pipette axes"
          },
          "mount": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Mount"
              },
              {
                "type": "null"
              }
            ],
            "description": "Which mount to home, if target is pipette (required in that case)"
          }
        },
        "type": "object",
        "required": [
          "target"
        ],
        "title": "RobotHomeTarget",
        "description": "Parameters for the home",
        "examples": [
          {
            "target": "robot"
          },
          {
            "mount": "right",
            "target": "pipette"
          }
        ]
      },
      "RobotLightState": {
        "properties": {
          "on": {
            "type": "boolean",
            "title": "On",
            "description": "The light state"
          }
        },
        "type": "object",
        "required": [
          "on"
        ],
        "title": "RobotLightState",
        "description": "Whether a light is (or should be turned) on or off"
      },
      "RobotMoveTarget": {
        "properties": {
          "target": {
            "$ref": "#/components/schemas/MotionTarget"
          },
          "point": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "maxItems": 3,
            "minItems": 3,
            "title": "Point",
            "description": "A point in deck coordinates (x, y, z)"
          },
          "mount": {
            "$ref": "#/components/schemas/Mount",
            "description": "Which mount to move"
          },
          "model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model",
            "description": "A pipette model that matches the pipette attached to the specified mount. Required if target is pipette"
          }
        },
        "type": "object",
        "required": [
          "target",
          "point",
          "mount"
        ],
        "title": "RobotMoveTarget",
        "examples": [
          {
            "mount": "left",
            "point": [
              100,
              100,
              80
            ],
            "target": "mount"
          },
          {
            "model": "p300_single",
            "mount": "right",
            "point": [
              25,
              25,
              50
            ],
            "target": "pipette"
          }
        ]
      },
      "RobotPositions": {
        "properties": {
          "change_pipette": {
            "$ref": "#/components/schemas/ChangePipette"
          },
          "attach_tip": {
            "$ref": "#/components/schemas/AttachTip"
          }
        },
        "type": "object",
        "required": [
          "change_pipette",
          "attach_tip"
        ],
        "title": "RobotPositions"
      },
      "RobotPositionsResponse": {
        "properties": {
          "positions": {
            "$ref": "#/components/schemas/RobotPositions"
          }
        },
        "type": "object",
        "required": [
          "positions"
        ],
        "title": "RobotPositionsResponse",
        "example": {
          "positions": {
            "attach_tip": {
              "point": [
                200,
                90,
                150
              ],
              "target": "pipette"
            },
            "change_pipette": {
              "left": [
                325,
                40,
                30
              ],
              "right": [
                65,
                40,
                30
              ],
              "target": "mount"
            }
          }
        }
      },
      "RoundedCuboidSegment": {
        "properties": {
          "shape": {
            "type": "string",
            "enum": [
              "roundedcuboid"
            ],
            "const": "roundedcuboid",
            "title": "Shape"
          },
          "bottomCrossSection": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "circular"
                ],
                "const": "circular"
              },
              {
                "type": "string",
                "enum": [
                  "rectangular"
                ],
                "const": "rectangular"
              }
            ],
            "title": "Bottomcrosssection"
          },
          "circleDiameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Circlediameter"
          },
          "rectangleXDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Rectanglexdimension"
          },
          "rectangleYDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Rectangleydimension"
          },
          "topHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topheight"
          },
          "bottomHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomheight"
          },
          "xCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Xcount",
            "default": 1
          },
          "yCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Ycount",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "shape",
          "bottomCrossSection",
          "circleDiameter",
          "rectangleXDimension",
          "rectangleYDimension",
          "topHeight",
          "bottomHeight"
        ],
        "title": "RoundedCuboidSegment"
      },
      "RowNozzleLayoutConfiguration": {
        "properties": {
          "style": {
            "type": "string",
            "enum": [
              "ROW"
            ],
            "const": "ROW",
            "title": "Style",
            "default": "ROW"
          },
          "primaryNozzle": {
            "type": "string",
            "enum": [
              "A1",
              "H1",
              "A12",
              "H12"
            ],
            "title": "Primarynozzle",
            "description": "The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle."
          }
        },
        "type": "object",
        "required": [
          "primaryNozzle"
        ],
        "title": "RowNozzleLayoutConfiguration",
        "description": "Minimum information required for a new nozzle configuration."
      },
      "Run": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique run identifier."
          },
          "ok": {
            "type": "boolean",
            "enum": [
              true
            ],
            "const": true,
            "title": "Ok",
            "default": true
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the run was created"
          },
          "status": {
            "$ref": "#/components/schemas/EngineStatus",
            "description": "Execution status of the run"
          },
          "current": {
            "type": "boolean",
            "title": "Current",
            "description": "Whether this run is currently controlling the robot. There can be, at most, one current run."
          },
          "actions": {
            "items": {
              "$ref": "#/components/schemas/RunAction"
            },
            "type": "array",
            "title": "Actions",
            "description": "Client-initiated run control actions, ordered oldest to newest."
          },
          "errors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Errors",
            "description": "The run's fatal error, if there was one. For historical reasons, this is an array, but it won't have more than one element."
          },
          "hasEverEnteredErrorRecovery": {
            "type": "boolean",
            "title": "Haseverenterederrorrecovery",
            "description": "Whether the run has entered error recovery."
          },
          "pipettes": {
            "items": {
              "$ref": "#/components/schemas/LoadedPipette"
            },
            "type": "array",
            "title": "Pipettes",
            "description": "Pipettes that have been loaded into the run."
          },
          "modules": {
            "items": {
              "$ref": "#/components/schemas/LoadedModule"
            },
            "type": "array",
            "title": "Modules",
            "description": "Modules that have been loaded into the run."
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/LoadedLabware"
            },
            "type": "array",
            "title": "Labware",
            "description": "Labware that has been loaded into the run."
          },
          "liquids": {
            "items": {
              "$ref": "#/components/schemas/Liquid"
            },
            "type": "array",
            "title": "Liquids",
            "description": "Liquids loaded to the run."
          },
          "liquidClasses": {
            "items": {
              "$ref": "#/components/schemas/LiquidClassRecordWithId"
            },
            "type": "array",
            "title": "Liquidclasses",
            "description": "Liquid classes loaded to the run."
          },
          "labwareOffsets": {
            "items": {
              "$ref": "#/components/schemas/LabwareOffset"
            },
            "type": "array",
            "title": "Labwareoffsets",
            "description": "Labware offsets to apply as labware are loaded."
          },
          "runTimeParameters": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/NumberParameter"
                },
                {
                  "$ref": "#/components/schemas/EnumParameter"
                },
                {
                  "$ref": "#/components/schemas/BooleanParameter"
                },
                {
                  "$ref": "#/components/schemas/CSVParameter"
                }
              ]
            },
            "type": "array",
            "title": "Runtimeparameters",
            "description": "Run time parameters used during the run. These are the parameters that are defined in the protocol, with values specified either in the run creation request or default values from the protocol if none are specified in the request."
          },
          "outputFileIds": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Outputfileids",
            "description": "File IDs of files output during a protocol run."
          },
          "protocolId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Protocolid",
            "description": "Protocol resource being run, if any. If not present, the run may still be used to execute protocol commands over HTTP."
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Run completed at timestamp."
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Run started at timestamp."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "status",
          "current",
          "actions",
          "errors",
          "hasEverEnteredErrorRecovery",
          "pipettes",
          "modules",
          "labware",
          "liquids",
          "liquidClasses",
          "labwareOffsets",
          "outputFileIds"
        ],
        "title": "Run",
        "description": "Run resource model."
      },
      "RunAction": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A unique identifier to reference the command."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the command was created."
          },
          "actionType": {
            "$ref": "#/components/schemas/RunActionType"
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "actionType"
        ],
        "title": "RunAction",
        "description": "Run control action model.\n\nA RunAction resource represents a client-provided command to\nthe run in order to control the execution of the run itself.\n\nThis is different than a protocol command, which represents an individual\nrobotic procedure to execute as part of a protocol."
      },
      "RunActionCreate": {
        "properties": {
          "actionType": {
            "$ref": "#/components/schemas/RunActionType"
          }
        },
        "type": "object",
        "required": [
          "actionType"
        ],
        "title": "RunActionCreate",
        "description": "Request model for new control action creation."
      },
      "RunActionNotAllowed": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunActionNotAllowed"
            ],
            "const": "RunActionNotAllowed",
            "title": "Id",
            "default": "RunActionNotAllowed"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Action Not Allowed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunActionNotAllowed",
        "description": "An error if one tries to issue an unsupported run action."
      },
      "RunActionType": {
        "type": "string",
        "enum": [
          "play",
          "pause",
          "stop",
          "resume-from-recovery",
          "resume-from-recovery-assuming-false-positive"
        ],
        "title": "RunActionType",
        "description": "The type of the run control action, which determines behavior.\n\n* `\"play\"`: Start the run, or resume it after it's been paused.\n\n* `\"pause\"`: Pause the run.\n\n* `\"stop\"`: Stop (cancel) the run.\n\n* `\"resume-from-recovery\"`: Resume normal protocol execution after the run was in\n  error recovery mode. Continue from however the last command left the robot.\n\n* `\"resume-from-recovery-assuming-false-positive\"`: Resume normal protocol execution\n  after the run was in error recovery mode. Act as if the underlying error was a\n  false positive.\n\nTo see the difference between `\"resume-from-recovery\"` and\n`\"resume-from-recovery-assuming-false-positive\"`, suppose we've just entered error\nrecovery mode after a `commandType: \"pickUpTip\"` command failed with an\n`errorType: \"tipPhysicallyMissing\"` error. That normally leaves the robot thinking\nit has no tip attached. If you use `\"resume-from-recovery\"`, the robot will run\nthe next protocol command from that state, acting as if there's no tip attached.\n(This may cause another error, if the next command needs a tip.)\nWhereas if you use `\"resume-from-recovery-assuming-false-positive\"`,\nthe robot will try to nullify the error, thereby acting as if it *does* have a tip\nattached.\n\nGenerally:\n\n* If you've tried to recover from the error by sending your own `intent: \"fixit\"`\n  commands to `POST /runs/{id}/commands`, use `\"resume-from-recovery\"`. It's your\n  responsibility to ensure your `POST`ed commands leave the robot in a good-enough\n  state to continue with the protocol.\n\n* Otherwise, use `\"resume-from-recovery-assuming-false-positive\"`.\n\nDo not combine `intent: \"fixit\"` commands with\n`\"resume-from-recovery-assuming-false-positive\"`the robot's built-in\nfalse-positive recovery may compete with your own."
      },
      "RunActive": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunActive"
            ],
            "const": "RunActive",
            "title": "Id",
            "default": "RunActive"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Active"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "There is an active run. Close the current run to issue commands via POST /commands."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4001"
          }
        },
        "type": "object",
        "title": "RunActive",
        "description": "An error returned if there is a run active.\n\nIf there is a run active, you cannot issue stateless commands."
      },
      "RunAlreadyActive": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunAlreadyActive"
            ],
            "const": "RunAlreadyActive",
            "title": "Id",
            "default": "RunAlreadyActive"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Already Active"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4001"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunAlreadyActive",
        "description": "An error if one tries to create a new run while one is already active."
      },
      "RunCommandSummary": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique command identifier."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol."
          },
          "commandType": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "airGapInPlace"
                ],
                "const": "airGapInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "aspirate"
                ],
                "const": "aspirate"
              },
              {
                "type": "string",
                "enum": [
                  "aspirateWhileTracking"
                ],
                "const": "aspirateWhileTracking"
              },
              {
                "type": "string",
                "enum": [
                  "aspirateInPlace"
                ],
                "const": "aspirateInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "comment"
                ],
                "const": "comment"
              },
              {
                "type": "string",
                "enum": [
                  "configureForVolume"
                ],
                "const": "configureForVolume"
              },
              {
                "type": "string",
                "enum": [
                  "configureNozzleLayout"
                ],
                "const": "configureNozzleLayout"
              },
              {
                "type": "string",
                "enum": [
                  "custom"
                ],
                "const": "custom"
              },
              {
                "type": "string",
                "enum": [
                  "dispense"
                ],
                "const": "dispense"
              },
              {
                "type": "string",
                "enum": [
                  "dispenseInPlace"
                ],
                "const": "dispenseInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "dispenseWhileTracking"
                ],
                "const": "dispenseWhileTracking"
              },
              {
                "type": "string",
                "enum": [
                  "blowout"
                ],
                "const": "blowout"
              },
              {
                "type": "string",
                "enum": [
                  "blowOutInPlace"
                ],
                "const": "blowOutInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "dropTip"
                ],
                "const": "dropTip"
              },
              {
                "type": "string",
                "enum": [
                  "dropTipInPlace"
                ],
                "const": "dropTipInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "home"
                ],
                "const": "home"
              },
              {
                "type": "string",
                "enum": [
                  "retractAxis"
                ],
                "const": "retractAxis"
              },
              {
                "type": "string",
                "enum": [
                  "loadLabware"
                ],
                "const": "loadLabware"
              },
              {
                "type": "string",
                "enum": [
                  "reloadLabware"
                ],
                "const": "reloadLabware"
              },
              {
                "type": "string",
                "enum": [
                  "loadLiquid"
                ],
                "const": "loadLiquid"
              },
              {
                "type": "string",
                "enum": [
                  "loadLiquidClass"
                ],
                "const": "loadLiquidClass"
              },
              {
                "type": "string",
                "enum": [
                  "loadModule"
                ],
                "const": "loadModule"
              },
              {
                "type": "string",
                "enum": [
                  "loadPipette"
                ],
                "const": "loadPipette"
              },
              {
                "type": "string",
                "enum": [
                  "loadLidStack"
                ],
                "const": "loadLidStack"
              },
              {
                "type": "string",
                "enum": [
                  "loadLid"
                ],
                "const": "loadLid"
              },
              {
                "type": "string",
                "enum": [
                  "moveLabware"
                ],
                "const": "moveLabware"
              },
              {
                "type": "string",
                "enum": [
                  "moveRelative"
                ],
                "const": "moveRelative"
              },
              {
                "type": "string",
                "enum": [
                  "moveToCoordinates"
                ],
                "const": "moveToCoordinates"
              },
              {
                "type": "string",
                "enum": [
                  "moveToWell"
                ],
                "const": "moveToWell"
              },
              {
                "type": "string",
                "enum": [
                  "moveToAddressableArea"
                ],
                "const": "moveToAddressableArea"
              },
              {
                "type": "string",
                "enum": [
                  "moveToAddressableAreaForDropTip"
                ],
                "const": "moveToAddressableAreaForDropTip"
              },
              {
                "type": "string",
                "enum": [
                  "prepareToAspirate"
                ],
                "const": "prepareToAspirate"
              },
              {
                "type": "string",
                "enum": [
                  "waitForResume",
                  "pause"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "waitForDuration"
                ],
                "const": "waitForDuration"
              },
              {
                "type": "string",
                "enum": [
                  "pickUpTip"
                ],
                "const": "pickUpTip"
              },
              {
                "type": "string",
                "enum": [
                  "savePosition"
                ],
                "const": "savePosition"
              },
              {
                "type": "string",
                "enum": [
                  "setRailLights"
                ],
                "const": "setRailLights"
              },
              {
                "type": "string",
                "enum": [
                  "touchTip"
                ],
                "const": "touchTip"
              },
              {
                "type": "string",
                "enum": [
                  "setStatusBar"
                ],
                "const": "setStatusBar"
              },
              {
                "type": "string",
                "enum": [
                  "verifyTipPresence"
                ],
                "const": "verifyTipPresence"
              },
              {
                "type": "string",
                "enum": [
                  "getTipPresence"
                ],
                "const": "getTipPresence"
              },
              {
                "type": "string",
                "enum": [
                  "getNextTip"
                ],
                "const": "getNextTip"
              },
              {
                "type": "string",
                "enum": [
                  "liquidProbe"
                ],
                "const": "liquidProbe"
              },
              {
                "type": "string",
                "enum": [
                  "tryLiquidProbe"
                ],
                "const": "tryLiquidProbe"
              },
              {
                "type": "string",
                "enum": [
                  "evotipSealPipette"
                ],
                "const": "evotipSealPipette"
              },
              {
                "type": "string",
                "enum": [
                  "evotipDispense"
                ],
                "const": "evotipDispense"
              },
              {
                "type": "string",
                "enum": [
                  "evotipUnsealPipette"
                ],
                "const": "evotipUnsealPipette"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/waitForTemperature"
                ],
                "const": "heaterShaker/waitForTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/setTargetTemperature"
                ],
                "const": "heaterShaker/setTargetTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/deactivateHeater"
                ],
                "const": "heaterShaker/deactivateHeater"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/setAndWaitForShakeSpeed"
                ],
                "const": "heaterShaker/setAndWaitForShakeSpeed"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/deactivateShaker"
                ],
                "const": "heaterShaker/deactivateShaker"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/openLabwareLatch"
                ],
                "const": "heaterShaker/openLabwareLatch"
              },
              {
                "type": "string",
                "enum": [
                  "heaterShaker/closeLabwareLatch"
                ],
                "const": "heaterShaker/closeLabwareLatch"
              },
              {
                "type": "string",
                "enum": [
                  "magneticModule/disengage"
                ],
                "const": "magneticModule/disengage"
              },
              {
                "type": "string",
                "enum": [
                  "magneticModule/engage"
                ],
                "const": "magneticModule/engage"
              },
              {
                "type": "string",
                "enum": [
                  "temperatureModule/setTargetTemperature"
                ],
                "const": "temperatureModule/setTargetTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "temperatureModule/waitForTemperature"
                ],
                "const": "temperatureModule/waitForTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "temperatureModule/deactivate"
                ],
                "const": "temperatureModule/deactivate"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/setTargetBlockTemperature"
                ],
                "const": "thermocycler/setTargetBlockTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/waitForBlockTemperature"
                ],
                "const": "thermocycler/waitForBlockTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/setTargetLidTemperature"
                ],
                "const": "thermocycler/setTargetLidTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/waitForLidTemperature"
                ],
                "const": "thermocycler/waitForLidTemperature"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/deactivateBlock"
                ],
                "const": "thermocycler/deactivateBlock"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/deactivateLid"
                ],
                "const": "thermocycler/deactivateLid"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/openLid"
                ],
                "const": "thermocycler/openLid"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/closeLid"
                ],
                "const": "thermocycler/closeLid"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/runProfile"
                ],
                "const": "thermocycler/runProfile"
              },
              {
                "type": "string",
                "enum": [
                  "thermocycler/runExtendedProfile"
                ],
                "const": "thermocycler/runExtendedProfile"
              },
              {
                "type": "string",
                "enum": [
                  "absorbanceReader/closeLid"
                ],
                "const": "absorbanceReader/closeLid"
              },
              {
                "type": "string",
                "enum": [
                  "absorbanceReader/openLid"
                ],
                "const": "absorbanceReader/openLid"
              },
              {
                "type": "string",
                "enum": [
                  "absorbanceReader/initialize"
                ],
                "const": "absorbanceReader/initialize"
              },
              {
                "type": "string",
                "enum": [
                  "absorbanceReader/read"
                ],
                "const": "absorbanceReader/read"
              },
              {
                "type": "string",
                "enum": [
                  "flexStacker/retrieve"
                ],
                "const": "flexStacker/retrieve"
              },
              {
                "type": "string",
                "enum": [
                  "flexStacker/store"
                ],
                "const": "flexStacker/store"
              },
              {
                "type": "string",
                "enum": [
                  "flexStacker/setStoredLabware"
                ],
                "const": "flexStacker/setStoredLabware"
              },
              {
                "type": "string",
                "enum": [
                  "flexStacker/fill"
                ],
                "const": "flexStacker/fill"
              },
              {
                "type": "string",
                "enum": [
                  "flexStacker/empty"
                ],
                "const": "flexStacker/empty"
              },
              {
                "type": "string",
                "enum": [
                  "calibration/calibrateGripper"
                ],
                "const": "calibration/calibrateGripper"
              },
              {
                "type": "string",
                "enum": [
                  "calibration/calibratePipette"
                ],
                "const": "calibration/calibratePipette"
              },
              {
                "type": "string",
                "enum": [
                  "calibration/calibrateModule"
                ],
                "const": "calibration/calibrateModule"
              },
              {
                "type": "string",
                "enum": [
                  "calibration/moveToMaintenancePosition"
                ],
                "const": "calibration/moveToMaintenancePosition"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/blowOutInPlace"
                ],
                "const": "unsafe/blowOutInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/dropTipInPlace"
                ],
                "const": "unsafe/dropTipInPlace"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/updatePositionEstimators"
                ],
                "const": "unsafe/updatePositionEstimators"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/engageAxes"
                ],
                "const": "unsafe/engageAxes"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/ungripLabware"
                ],
                "const": "unsafe/ungripLabware"
              },
              {
                "type": "string",
                "enum": [
                  "unsafe/placeLabware"
                ],
                "const": "unsafe/placeLabware"
              },
              {
                "type": "string",
                "enum": [
                  "robot/moveAxesRelative"
                ],
                "const": "robot/moveAxesRelative"
              },
              {
                "type": "string",
                "enum": [
                  "robot/moveAxesTo"
                ],
                "const": "robot/moveAxesTo"
              },
              {
                "type": "string",
                "enum": [
                  "robot/moveTo"
                ],
                "const": "robot/moveTo"
              },
              {
                "type": "string",
                "enum": [
                  "robot/openGripperJaw"
                ],
                "const": "robot/openGripperJaw"
              },
              {
                "type": "string",
                "enum": [
                  "robot/closeGripperJaw"
                ],
                "const": "robot/closeGripperJaw"
              }
            ],
            "title": "Commandtype",
            "description": "Specific type of command."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Execution status of the command."
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Error occurrence, if status is 'failed'"
          },
          "params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AirGapInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/AspirateParams"
              },
              {
                "$ref": "#/components/schemas/AspirateWhileTrackingParams"
              },
              {
                "$ref": "#/components/schemas/AspirateInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/CommentParams"
              },
              {
                "$ref": "#/components/schemas/ConfigureForVolumeParams"
              },
              {
                "$ref": "#/components/schemas/ConfigureNozzleLayoutParams"
              },
              {
                "$ref": "#/components/schemas/CustomParams"
              },
              {
                "$ref": "#/components/schemas/DispenseParams"
              },
              {
                "$ref": "#/components/schemas/DispenseInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/DispenseWhileTrackingParams"
              },
              {
                "$ref": "#/components/schemas/BlowOutParams"
              },
              {
                "$ref": "#/components/schemas/BlowOutInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/DropTipParams"
              },
              {
                "$ref": "#/components/schemas/DropTipInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/HomeParams"
              },
              {
                "$ref": "#/components/schemas/RetractAxisParams"
              },
              {
                "$ref": "#/components/schemas/LoadLabwareParams"
              },
              {
                "$ref": "#/components/schemas/LoadLidStackParams"
              },
              {
                "$ref": "#/components/schemas/LoadLidParams"
              },
              {
                "$ref": "#/components/schemas/ReloadLabwareParams"
              },
              {
                "$ref": "#/components/schemas/LoadLiquidParams"
              },
              {
                "$ref": "#/components/schemas/LoadLiquidClassParams"
              },
              {
                "$ref": "#/components/schemas/LoadModuleParams"
              },
              {
                "$ref": "#/components/schemas/LoadPipetteParams"
              },
              {
                "$ref": "#/components/schemas/MoveLabwareParams"
              },
              {
                "$ref": "#/components/schemas/MoveRelativeParams"
              },
              {
                "$ref": "#/components/schemas/MoveToCoordinatesParams"
              },
              {
                "$ref": "#/components/schemas/MoveToWellParams"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaParams"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaForDropTipParams"
              },
              {
                "$ref": "#/components/schemas/PrepareToAspirateParams"
              },
              {
                "$ref": "#/components/schemas/WaitForResumeParams"
              },
              {
                "$ref": "#/components/schemas/WaitForDurationParams"
              },
              {
                "$ref": "#/components/schemas/PickUpTipParams"
              },
              {
                "$ref": "#/components/schemas/SavePositionParams"
              },
              {
                "$ref": "#/components/schemas/SetRailLightsParams"
              },
              {
                "$ref": "#/components/schemas/TouchTipParams"
              },
              {
                "$ref": "#/components/schemas/SetStatusBarParams"
              },
              {
                "$ref": "#/components/schemas/VerifyTipPresenceParams"
              },
              {
                "$ref": "#/components/schemas/GetTipPresenceParams"
              },
              {
                "$ref": "#/components/schemas/GetNextTipParams"
              },
              {
                "$ref": "#/components/schemas/LiquidProbeParams"
              },
              {
                "$ref": "#/components/schemas/TryLiquidProbeParams"
              },
              {
                "$ref": "#/components/schemas/EvotipSealPipetteParams"
              },
              {
                "$ref": "#/components/schemas/EvotipDispenseParams"
              },
              {
                "$ref": "#/components/schemas/EvotipUnsealPipetteParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/DeactivateHeaterParams"
              },
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeedParams"
              },
              {
                "$ref": "#/components/schemas/DeactivateShakerParams"
              },
              {
                "$ref": "#/components/schemas/OpenLabwareLatchParams"
              },
              {
                "$ref": "#/components/schemas/CloseLabwareLatchParams"
              },
              {
                "$ref": "#/components/schemas/DisengageParams"
              },
              {
                "$ref": "#/components/schemas/EngageParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/DeactivateTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/WaitForBlockTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/SetTargetLidTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/WaitForLidTemperatureParams"
              },
              {
                "$ref": "#/components/schemas/DeactivateBlockParams"
              },
              {
                "$ref": "#/components/schemas/DeactivateLidParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidParams"
              },
              {
                "$ref": "#/components/schemas/RunProfileParams"
              },
              {
                "$ref": "#/components/schemas/RunExtendedProfileParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidParams"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidParams"
              },
              {
                "$ref": "#/components/schemas/InitializeParams"
              },
              {
                "$ref": "#/components/schemas/ReadAbsorbanceParams"
              },
              {
                "$ref": "#/components/schemas/RetrieveParams"
              },
              {
                "$ref": "#/components/schemas/StoreParams"
              },
              {
                "$ref": "#/components/schemas/SetStoredLabwareParams"
              },
              {
                "$ref": "#/components/schemas/FillParams"
              },
              {
                "$ref": "#/components/schemas/EmptyParams"
              },
              {
                "$ref": "#/components/schemas/CalibrateGripperParams"
              },
              {
                "$ref": "#/components/schemas/CalibratePipetteParams"
              },
              {
                "$ref": "#/components/schemas/CalibrateModuleParams"
              },
              {
                "$ref": "#/components/schemas/MoveToMaintenancePositionParams"
              },
              {
                "$ref": "#/components/schemas/UnsafeBlowOutInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/UnsafeDropTipInPlaceParams"
              },
              {
                "$ref": "#/components/schemas/UpdatePositionEstimatorsParams"
              },
              {
                "$ref": "#/components/schemas/UnsafeEngageAxesParams"
              },
              {
                "$ref": "#/components/schemas/UnsafeUngripLabwareParams"
              },
              {
                "$ref": "#/components/schemas/UnsafePlaceLabwareParams"
              },
              {
                "$ref": "#/components/schemas/MoveAxesRelativeParams"
              },
              {
                "$ref": "#/components/schemas/MoveAxesToParams"
              },
              {
                "$ref": "#/components/schemas/MoveToParams"
              },
              {
                "$ref": "#/components/schemas/openGripperJawParams"
              },
              {
                "$ref": "#/components/schemas/closeGripperJawParams"
              }
            ],
            "title": "Params",
            "description": "Command execution parameters."
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "Why this command was added to the run."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Notes pertaining to this command."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "key",
          "commandType",
          "createdAt",
          "status",
          "params"
        ],
        "title": "RunCommandSummary",
        "description": "A stripped down model of a full Command for usage in a Run response."
      },
      "RunCreate": {
        "properties": {
          "protocolId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Protocolid",
            "description": "Protocol resource ID that this run will be using, if applicable."
          },
          "labwareOffsets": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LegacyLabwareOffsetCreate"
                },
                {
                  "$ref": "#/components/schemas/LabwareOffsetCreate"
                }
              ]
            },
            "type": "array",
            "title": "Labwareoffsets",
            "description": "Labware offsets to apply as labware are loaded."
          },
          "runTimeParameterValues": {
            "anyOf": [
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Runtimeparametervalues",
            "description": "Key-value pairs of run-time parameters defined in a protocol."
          },
          "runTimeParameterFiles": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Runtimeparameterfiles",
            "description": "Key-fileId pairs of CSV run-time parameters defined in a run."
          }
        },
        "type": "object",
        "title": "RunCreate",
        "description": "Create request data for a new run."
      },
      "RunCurrentState": {
        "properties": {
          "estopEngaged": {
            "type": "boolean",
            "title": "Estopengaged"
          },
          "activeNozzleLayouts": {
            "additionalProperties": {
              "$ref": "#/components/schemas/ActiveNozzleLayout"
            },
            "type": "object",
            "title": "Activenozzlelayouts"
          },
          "tipStates": {
            "additionalProperties": {
              "$ref": "#/components/schemas/TipState"
            },
            "type": "object",
            "title": "Tipstates"
          },
          "placeLabwareState": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PlaceLabwareState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "estopEngaged",
          "activeNozzleLayouts",
          "tipStates",
          "placeLabwareState"
        ],
        "title": "RunCurrentState",
        "description": "Current details about a run."
      },
      "RunDataError": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunDataError"
            ],
            "const": "RunDataError",
            "title": "Id",
            "default": "RunDataError"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A short, human readable name for this type of error",
            "default": "Run Data Error"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunDataError",
        "description": "A model for an error loading a run."
      },
      "RunExtendedProfile": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/runExtendedProfile"
            ],
            "const": "thermocycler/runExtendedProfile",
            "title": "Commandtype",
            "default": "thermocycler/runExtendedProfile"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/RunExtendedProfileParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RunExtendedProfileResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "RunExtendedProfile",
        "description": "A command to execute a Thermocycler profile run."
      },
      "RunExtendedProfileCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/runExtendedProfile"
            ],
            "const": "thermocycler/runExtendedProfile",
            "title": "Commandtype",
            "default": "thermocycler/runExtendedProfile"
          },
          "params": {
            "$ref": "#/components/schemas/RunExtendedProfileParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "RunExtendedProfileCreate",
        "description": "A request to execute a Thermocycler profile run."
      },
      "RunExtendedProfileParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          },
          "profileElements": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ProfileStep"
                },
                {
                  "$ref": "#/components/schemas/ProfileCycle"
                }
              ]
            },
            "type": "array",
            "title": "Profileelements",
            "description": "Elements of the profile. Each can be either a step or a cycle."
          },
          "blockMaxVolumeUl": {
            "type": "number",
            "title": "Blockmaxvolumeul",
            "description": "Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "profileElements"
        ],
        "title": "RunExtendedProfileParams",
        "description": "Input parameters for an individual Thermocycler profile step."
      },
      "RunExtendedProfileResult": {
        "properties": {},
        "type": "object",
        "title": "RunExtendedProfileResult",
        "description": "Result data from running a Thermocycler profile."
      },
      "RunLink": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The run's id"
          },
          "href": {
            "type": "string",
            "title": "Href",
            "description": "The run's URL"
          }
        },
        "type": "object",
        "required": [
          "id",
          "href"
        ],
        "title": "RunLink",
        "description": "Link to a run resource."
      },
      "RunProfile": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/runProfile"
            ],
            "const": "thermocycler/runProfile",
            "title": "Commandtype",
            "default": "thermocycler/runProfile"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/RunProfileParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RunProfileResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "RunProfile",
        "description": "A command to execute a Thermocycler profile run."
      },
      "RunProfileCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/runProfile"
            ],
            "const": "thermocycler/runProfile",
            "title": "Commandtype",
            "default": "thermocycler/runProfile"
          },
          "params": {
            "$ref": "#/components/schemas/RunProfileParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "RunProfileCreate",
        "description": "A request to execute a Thermocycler profile run."
      },
      "RunProfileParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          },
          "profile": {
            "items": {
              "$ref": "#/components/schemas/RunProfileStepParams"
            },
            "type": "array",
            "title": "Profile",
            "description": "Array of profile steps with target temperature and temperature hold time."
          },
          "blockMaxVolumeUl": {
            "type": "number",
            "title": "Blockmaxvolumeul",
            "description": "Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "profile"
        ],
        "title": "RunProfileParams",
        "description": "Input parameters to run a Thermocycler profile."
      },
      "RunProfileResult": {
        "properties": {},
        "type": "object",
        "title": "RunProfileResult",
        "description": "Result data from running a Thermocycler profile."
      },
      "RunProfileStepParams": {
        "properties": {
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          },
          "holdSeconds": {
            "type": "number",
            "title": "Holdseconds",
            "description": "Time to hold target temperature at in seconds."
          }
        },
        "type": "object",
        "required": [
          "celsius",
          "holdSeconds"
        ],
        "title": "RunProfileStepParams",
        "description": "Input parameters for an individual Thermocycler profile step."
      },
      "RunStopped": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunStopped"
            ],
            "const": "RunStopped",
            "title": "Id",
            "default": "RunStopped"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Stopped"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunStopped",
        "description": "An error if one tries to modify a stopped run."
      },
      "RunUpdate": {
        "properties": {
          "current": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current",
            "description": "Whether this run is currently controlling the robot. Setting `current` to `false` will deactivate the run."
          }
        },
        "type": "object",
        "title": "RunUpdate",
        "description": "Update request data for an existing run."
      },
      "SavePosition": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "savePosition"
            ],
            "const": "savePosition",
            "title": "Commandtype",
            "default": "savePosition"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SavePositionParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SavePositionResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SavePosition",
        "description": "Save Position command model."
      },
      "SavePositionCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "savePosition"
            ],
            "const": "savePosition",
            "title": "Commandtype",
            "default": "savePosition"
          },
          "params": {
            "$ref": "#/components/schemas/SavePositionParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SavePositionCreate",
        "description": "Save position command creation request model."
      },
      "SavePositionParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Unique identifier of the pipette in question."
          },
          "positionId": {
            "type": "string",
            "title": "Positionid",
            "description": "An optional ID to assign to this command instance. Auto-assigned if not defined."
          },
          "failOnNotHomed": {
            "type": "boolean",
            "title": "Failonnothomed",
            "description": "Require all axes to be homed before saving position."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "SavePositionParams",
        "description": "Payload needed to save a pipette's current position."
      },
      "SavePositionResult": {
        "properties": {
          "positionId": {
            "type": "string",
            "title": "Positionid",
            "description": "An ID to reference this position in subsequent requests."
          },
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space."
          }
        },
        "type": "object",
        "required": [
          "positionId",
          "position"
        ],
        "title": "SavePositionResult",
        "description": "Result data from executing a savePosition."
      },
      "SearchCreate": {
        "properties": {
          "filters": {
            "items": {
              "$ref": "#/components/schemas/SearchFilter"
            },
            "type": "array",
            "title": "Filters",
            "description": "A list of filters to search by.\n\nA result is returned if it passes any of these filters\n(in other words, these filters are OR'd together).\nIf this list is empty, no results are returned.\n"
          }
        },
        "type": "object",
        "required": [
          "filters"
        ],
        "title": "SearchCreate",
        "description": "A search query for labware offsets."
      },
      "SearchFilter": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Return only results having this exact `id`. Omit to accept any `id`.",
            "default": 1
          },
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "Return only results having this exact `definitionUri`. Omit to accept any `definitionUri`.",
            "default": 1
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "kind",
                    "mapping": {
                      "onAddressableArea": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent",
                      "onLabware": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent",
                      "onModule": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    }
                  }
                },
                "type": "array",
                "minItems": 1
              },
              {
                "type": "string",
                "enum": [
                  "anyLocation"
                ],
                "const": "anyLocation"
              }
            ],
            "title": "Locationsequence",
            "description": "Return only results having this exact `locationSequence`. Omit to accept any `locationSequence`.",
            "default": 1
          },
          "mostRecentOnly": {
            "type": "boolean",
            "title": "Mostrecentonly",
            "description": "If `true`, this filter returns only the most recently-added result of all that matched it. Otherwise, it returns all of them.",
            "default": false
          }
        },
        "type": "object",
        "title": "SearchFilter"
      },
      "SecondOrderCommandAnnotation": {
        "properties": {
          "commandKeys": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Commandkeys",
            "description": "Command keys to which this annotation applies"
          },
          "annotationType": {
            "type": "string",
            "enum": [
              "secondOrderCommand"
            ],
            "const": "secondOrderCommand",
            "title": "Annotationtype",
            "default": "secondOrderCommand"
          },
          "params": {
            "type": "object",
            "title": "Params",
            "description": "Key value pairs of the parameters passed to the second order command that this annotates."
          },
          "machineReadableName": {
            "type": "string",
            "title": "Machinereadablename",
            "description": "The name of the second order command in the form that the generating software refers to it"
          },
          "userSpecifiedName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Userspecifiedname",
            "description": "The optional user-specified name of the second order command"
          },
          "userSpecifiedDescription": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Userspecifieddescription",
            "description": "The optional user-specified description of the second order command"
          }
        },
        "type": "object",
        "required": [
          "commandKeys",
          "params",
          "machineReadableName"
        ],
        "title": "SecondOrderCommandAnnotation",
        "description": "Annotates a group of atomic commands which were the direct result of a second order command.\n\nExamples of second order commands would be transfer, consolidate, mix, etc."
      },
      "SerialCommand": {
        "properties": {
          "command_type": {
            "type": "string",
            "title": "Command Type",
            "description": "The name of the module function to call"
          },
          "args": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Args",
            "description": "The ordered args list for the call"
          }
        },
        "type": "object",
        "required": [
          "command_type"
        ],
        "title": "SerialCommand",
        "description": "The serialized module call",
        "examples": [
          {
            "args": [
              60
            ],
            "command_type": "set_Temperature"
          }
        ]
      },
      "SerialCommandResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A human readable string"
          },
          "returnValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Returnvalue",
            "description": "The return value from the call"
          }
        },
        "type": "object",
        "required": [
          "message"
        ],
        "title": "SerialCommandResponse",
        "description": "\"The result of a successful call",
        "examples": [
          {
            "message": "Success"
          }
        ]
      },
      "SessionCommandRequest_Literal_aspirate__AspirateCreate_AspirateResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "pipette.aspirate"
            ],
            "const": "pipette.aspirate",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/AspirateCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<PipetteCommand.aspirate: 'pipette.aspirate'>], AspirateCreate, AspirateResult]"
      },
      "SessionCommandRequest_Literal_dispense__DispenseCreate_DispenseResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "pipette.dispense"
            ],
            "const": "pipette.dispense",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/DispenseCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<PipetteCommand.dispense: 'pipette.dispense'>], DispenseCreate, DispenseResult]"
      },
      "SessionCommandRequest_Literal_drop_tip__DropTipCreate_DropTipResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "pipette.dropTip"
            ],
            "const": "pipette.dropTip",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/DropTipCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<PipetteCommand.drop_tip: 'pipette.dropTip'>], DropTipCreate, DropTipResult]"
      },
      "SessionCommandRequest_Literal_jog__JogPosition_EmptyModel_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "calibration.jog"
            ],
            "const": "calibration.jog",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/JogPosition",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<CalibrationCommand.jog: 'calibration.jog'>], JogPosition, EmptyModel]"
      },
      "SessionCommandRequest_Literal_load_labware__LoadLabwareByDefinitionRequestData_EmptyModel_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "calibration.loadLabware"
            ],
            "const": "calibration.loadLabware",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/LoadLabwareByDefinitionRequestData",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<CalibrationCommand.load_labware: 'calibration.loadLabware'>], LoadLabwareByDefinitionRequestData, EmptyModel]"
      },
      "SessionCommandRequest_Literal_load_labware__LoadLabwareCreate_LoadLabwareResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "equipment.loadLabware"
            ],
            "const": "equipment.loadLabware",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/LoadLabwareCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<EquipmentCommand.load_labware: 'equipment.loadLabware'>], LoadLabwareCreate, LoadLabwareResult]"
      },
      "SessionCommandRequest_Literal_load_pipette__LoadPipetteCreate_LoadPipetteResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "equipment.loadPipette"
            ],
            "const": "equipment.loadPipette",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/LoadPipetteCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<EquipmentCommand.load_pipette: 'equipment.loadPipette'>], LoadPipetteCreate, LoadPipetteResult]"
      },
      "SessionCommandRequest_Literal_pick_up_tip__PickUpTipCreate_PickUpTipResult_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "pipette.pickUpTip"
            ],
            "const": "pipette.pickUpTip",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/PickUpTipCreate",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<PipetteCommand.pick_up_tip: 'pipette.pickUpTip'>], PickUpTipCreate, PickUpTipResult]"
      },
      "SessionCommandRequest_Literal_set_has_calibration_block__SetHasCalibrationBlockRequestData_EmptyModel_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "calibration.setHasCalibrationBlock"
            ],
            "const": "calibration.setHasCalibrationBlock",
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/SetHasCalibrationBlockRequestData",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<CalibrationCommand.set_has_calibration_block: 'calibration.setHasCalibrationBlock'>], SetHasCalibrationBlockRequestData, EmptyModel]"
      },
      "SessionCommandRequest_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition__EmptyModel_EmptyModel_": {
        "properties": {
          "command": {
            "type": "string",
            "enum": [
              "protocol.startRun",
              "protocol.startSimulate",
              "protocol.cancel",
              "protocol.pause",
              "protocol.resume",
              "calibration.moveToTipRack",
              "calibration.moveToPointOne",
              "calibration.moveToDeck",
              "calibration.moveToReferencePoint",
              "calibration.pickUpTip",
              "calibration.confirmTip",
              "calibration.invalidateTip",
              "calibration.saveOffset",
              "calibration.exitSession",
              "calibration.invalidateLastAction",
              "calibration.deck.moveToPointTwo",
              "calibration.deck.moveToPointThree",
              "calibration.check.comparePoint",
              "calibration.check.switchPipette",
              "calibration.check.returnTip",
              "calibration.check.transition"
            ],
            "title": "Command",
            "description": "The command description"
          },
          "data": {
            "$ref": "#/components/schemas/EmptyModel",
            "description": "The command data"
          }
        },
        "type": "object",
        "required": [
          "command",
          "data"
        ],
        "title": "SessionCommandRequest[Literal[<ProtocolCommand.start_run: 'protocol.startRun'>, <ProtocolCommand.start_simulate: 'protocol.startSimulate'>, <ProtocolCommand.cancel: 'protocol.cancel'>, <ProtocolCommand.pause: 'protocol.pause'>, <ProtocolCommand.resume: 'protocol.resume'>, <CalibrationCommand.move_to_tip_rack: 'calibration.moveToTipRack'>, <CalibrationCommand.move_to_point_one: 'calibration.moveToPointOne'>, <CalibrationCommand.move_to_deck: 'calibration.moveToDeck'>, <CalibrationCommand.move_to_reference_point: 'calibration.moveToReferencePoint'>, <CalibrationCommand.pick_up_tip: 'calibration.pickUpTip'>, <CalibrationCommand.confirm_tip_attached: 'calibration.confirmTip'>, <CalibrationCommand.invalidate_tip: 'calibration.invalidateTip'>, <CalibrationCommand.save_offset: 'calibration.saveOffset'>, <CalibrationCommand.exit: 'calibration.exitSession'>, <CalibrationCommand.invalidate_last_action: 'calibration.invalidateLastAction'>, <DeckCalibrationCommand.move_to_point_two: 'calibration.deck.moveToPointTwo'>, <DeckCalibrationCommand.move_to_point_three: 'calibration.deck.moveToPointThree'>, <CheckCalibrationCommand.compare_point: 'calibration.check.comparePoint'>, <CheckCalibrationCommand.switch_pipette: 'calibration.check.switchPipette'>, <CheckCalibrationCommand.return_tip: 'calibration.check.returnTip'>, <CheckCalibrationCommand.transition: 'calibration.check.transition'>], EmptyModel, EmptyModel]"
      },
      "SessionCommandResponse_Literal_aspirate__AspirateCreate_AspirateResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "pipette.aspirate"
            ],
            "const": "pipette.aspirate",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/AspirateCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AspirateResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<PipetteCommand.aspirate: 'pipette.aspirate'>], AspirateCreate, AspirateResult]"
      },
      "SessionCommandResponse_Literal_dispense__DispenseCreate_DispenseResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "pipette.dispense"
            ],
            "const": "pipette.dispense",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/DispenseCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DispenseResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<PipetteCommand.dispense: 'pipette.dispense'>], DispenseCreate, DispenseResult]"
      },
      "SessionCommandResponse_Literal_drop_tip__DropTipCreate_DropTipResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "pipette.dropTip"
            ],
            "const": "pipette.dropTip",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/DropTipCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DropTipResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<PipetteCommand.drop_tip: 'pipette.dropTip'>], DropTipCreate, DropTipResult]"
      },
      "SessionCommandResponse_Literal_jog__JogPosition_EmptyModel_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "calibration.jog"
            ],
            "const": "calibration.jog",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/JogPosition"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmptyModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<CalibrationCommand.jog: 'calibration.jog'>], JogPosition, EmptyModel]"
      },
      "SessionCommandResponse_Literal_load_labware__LoadLabwareByDefinitionRequestData_EmptyModel_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "calibration.loadLabware"
            ],
            "const": "calibration.loadLabware",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/LoadLabwareByDefinitionRequestData"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmptyModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<CalibrationCommand.load_labware: 'calibration.loadLabware'>], LoadLabwareByDefinitionRequestData, EmptyModel]"
      },
      "SessionCommandResponse_Literal_load_labware__LoadLabwareCreate_LoadLabwareResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "equipment.loadLabware"
            ],
            "const": "equipment.loadLabware",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/LoadLabwareCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<EquipmentCommand.load_labware: 'equipment.loadLabware'>], LoadLabwareCreate, LoadLabwareResult]"
      },
      "SessionCommandResponse_Literal_load_pipette__LoadPipetteCreate_LoadPipetteResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "equipment.loadPipette"
            ],
            "const": "equipment.loadPipette",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/LoadPipetteCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LoadPipetteResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<EquipmentCommand.load_pipette: 'equipment.loadPipette'>], LoadPipetteCreate, LoadPipetteResult]"
      },
      "SessionCommandResponse_Literal_pick_up_tip__PickUpTipCreate_PickUpTipResult_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "pipette.pickUpTip"
            ],
            "const": "pipette.pickUpTip",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/PickUpTipCreate"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PickUpTipResult"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<PipetteCommand.pick_up_tip: 'pipette.pickUpTip'>], PickUpTipCreate, PickUpTipResult]"
      },
      "SessionCommandResponse_Literal_set_has_calibration_block__SetHasCalibrationBlockRequestData_EmptyModel_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "calibration.setHasCalibrationBlock"
            ],
            "const": "calibration.setHasCalibrationBlock",
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/SetHasCalibrationBlockRequestData"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmptyModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<CalibrationCommand.set_has_calibration_block: 'calibration.setHasCalibrationBlock'>], SetHasCalibrationBlockRequestData, EmptyModel]"
      },
      "SessionCommandResponse_Literal_start_run_start_simulate_cancel_pause_resume_move_to_tip_rack_move_to_point_one_move_to_deck_move_to_reference_point_pick_up_tip_confirm_tip_attached_invalidate_tip_save_offset_exit_invalidate_last_action_move_to_point_two_move_to_point_three_compare_point_switch_pipette_return_tip_transition__EmptyModel_EmptyModel_": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "command": {
            "type": "string",
            "enum": [
              "protocol.startRun",
              "protocol.startSimulate",
              "protocol.cancel",
              "protocol.pause",
              "protocol.resume",
              "calibration.moveToTipRack",
              "calibration.moveToPointOne",
              "calibration.moveToDeck",
              "calibration.moveToReferencePoint",
              "calibration.pickUpTip",
              "calibration.confirmTip",
              "calibration.invalidateTip",
              "calibration.saveOffset",
              "calibration.exitSession",
              "calibration.invalidateLastAction",
              "calibration.deck.moveToPointTwo",
              "calibration.deck.moveToPointThree",
              "calibration.check.comparePoint",
              "calibration.check.switchPipette",
              "calibration.check.returnTip",
              "calibration.check.transition"
            ],
            "title": "Command"
          },
          "data": {
            "$ref": "#/components/schemas/EmptyModel"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__session__models__command__CommandStatus"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmptyModel"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "id",
          "command",
          "data",
          "status"
        ],
        "title": "SessionCommandResponse[Literal[<ProtocolCommand.start_run: 'protocol.startRun'>, <ProtocolCommand.start_simulate: 'protocol.startSimulate'>, <ProtocolCommand.cancel: 'protocol.cancel'>, <ProtocolCommand.pause: 'protocol.pause'>, <ProtocolCommand.resume: 'protocol.resume'>, <CalibrationCommand.move_to_tip_rack: 'calibration.moveToTipRack'>, <CalibrationCommand.move_to_point_one: 'calibration.moveToPointOne'>, <CalibrationCommand.move_to_deck: 'calibration.moveToDeck'>, <CalibrationCommand.move_to_reference_point: 'calibration.moveToReferencePoint'>, <CalibrationCommand.pick_up_tip: 'calibration.pickUpTip'>, <CalibrationCommand.confirm_tip_attached: 'calibration.confirmTip'>, <CalibrationCommand.invalidate_tip: 'calibration.invalidateTip'>, <CalibrationCommand.save_offset: 'calibration.saveOffset'>, <CalibrationCommand.exit: 'calibration.exitSession'>, <CalibrationCommand.invalidate_last_action: 'calibration.invalidateLastAction'>, <DeckCalibrationCommand.move_to_point_two: 'calibration.deck.moveToPointTwo'>, <DeckCalibrationCommand.move_to_point_three: 'calibration.deck.moveToPointThree'>, <CheckCalibrationCommand.compare_point: 'calibration.check.comparePoint'>, <CheckCalibrationCommand.switch_pipette: 'calibration.check.switchPipette'>, <CheckCalibrationCommand.return_tip: 'calibration.check.returnTip'>, <CheckCalibrationCommand.transition: 'calibration.check.transition'>], EmptyModel, EmptyModel]"
      },
      "SessionType": {
        "type": "string",
        "enum": [
          "calibrationCheck",
          "tipLengthCalibration",
          "deckCalibration",
          "pipetteOffsetCalibration"
        ],
        "title": "SessionType",
        "description": "The available session types"
      },
      "SetAndWaitForShakeSpeed": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/setAndWaitForShakeSpeed"
            ],
            "const": "heaterShaker/setAndWaitForShakeSpeed",
            "title": "Commandtype",
            "default": "heaterShaker/setAndWaitForShakeSpeed"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetAndWaitForShakeSpeedParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeedResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetAndWaitForShakeSpeed",
        "description": "A command to set and wait for a Heater-Shaker's shake speed."
      },
      "SetAndWaitForShakeSpeedCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/setAndWaitForShakeSpeed"
            ],
            "const": "heaterShaker/setAndWaitForShakeSpeed",
            "title": "Commandtype",
            "default": "heaterShaker/setAndWaitForShakeSpeed"
          },
          "params": {
            "$ref": "#/components/schemas/SetAndWaitForShakeSpeedParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetAndWaitForShakeSpeedCreate",
        "description": "A request to create a Heater-Shaker's set and wait for shake speed command."
      },
      "SetAndWaitForShakeSpeedParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          },
          "rpm": {
            "type": "number",
            "title": "Rpm",
            "description": "Target speed in rotations per minute."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "rpm"
        ],
        "title": "SetAndWaitForShakeSpeedParams",
        "description": "Input parameters to set and wait for a shake speed for a Heater-Shaker Module."
      },
      "SetAndWaitForShakeSpeedResult": {
        "properties": {
          "pipetteRetracted": {
            "type": "boolean",
            "title": "Pipetteretracted",
            "description": "Whether this command automatically retracted the pipettes before starting the shake, to avoid a potential collision."
          }
        },
        "type": "object",
        "required": [
          "pipetteRetracted"
        ],
        "title": "SetAndWaitForShakeSpeedResult",
        "description": "Result data from setting and waiting for a Heater-Shaker's shake speed."
      },
      "SetHasCalibrationBlockRequestData": {
        "properties": {
          "hasBlock": {
            "type": "boolean",
            "title": "Hasblock",
            "description": "whether or not there is a calibration block present"
          }
        },
        "type": "object",
        "required": [
          "hasBlock"
        ],
        "title": "SetHasCalibrationBlockRequestData"
      },
      "SetRailLights": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "setRailLights"
            ],
            "const": "setRailLights",
            "title": "Commandtype",
            "default": "setRailLights"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetRailLightsParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetRailLightsResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetRailLights",
        "description": "setRailLights command model."
      },
      "SetRailLightsCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "setRailLights"
            ],
            "const": "setRailLights",
            "title": "Commandtype",
            "default": "setRailLights"
          },
          "params": {
            "$ref": "#/components/schemas/SetRailLightsParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetRailLightsCreate",
        "description": "setRailLights command request model."
      },
      "SetRailLightsParams": {
        "properties": {
          "on": {
            "type": "boolean",
            "title": "On",
            "description": "The field that determines if the light is turned off or on."
          }
        },
        "type": "object",
        "required": [
          "on"
        ],
        "title": "SetRailLightsParams",
        "description": "Payload required to set the rail lights on or off."
      },
      "SetRailLightsResult": {
        "properties": {},
        "type": "object",
        "title": "SetRailLightsResult",
        "description": "Result data from the execution of a setRailLights command."
      },
      "SetStatusBar": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "setStatusBar"
            ],
            "const": "setStatusBar",
            "title": "Commandtype",
            "default": "setStatusBar"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetStatusBarParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetStatusBarResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetStatusBar",
        "description": "setStatusBar command model."
      },
      "SetStatusBarCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "setStatusBar"
            ],
            "const": "setStatusBar",
            "title": "Commandtype",
            "default": "setStatusBar"
          },
          "params": {
            "$ref": "#/components/schemas/SetStatusBarParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetStatusBarCreate",
        "description": "setStatusBar command request model."
      },
      "SetStatusBarParams": {
        "properties": {
          "animation": {
            "$ref": "#/components/schemas/StatusBarAnimation",
            "description": "The animation that should be executed on the status bar."
          }
        },
        "type": "object",
        "required": [
          "animation"
        ],
        "title": "SetStatusBarParams",
        "description": "Payload required to set the status bar to run an animation."
      },
      "SetStatusBarResult": {
        "properties": {},
        "type": "object",
        "title": "SetStatusBarResult",
        "description": "Result data from the execution of a SetStatusBar command."
      },
      "SetStoredLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/setStoredLabware"
            ],
            "const": "flexStacker/setStoredLabware",
            "title": "Commandtype",
            "default": "flexStacker/setStoredLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetStoredLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetStoredLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetStoredLabware",
        "description": "A command to setstoredlabware the Flex Stacker."
      },
      "SetStoredLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/setStoredLabware"
            ],
            "const": "flexStacker/setStoredLabware",
            "title": "Commandtype",
            "default": "flexStacker/setStoredLabware"
          },
          "params": {
            "$ref": "#/components/schemas/SetStoredLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetStoredLabwareCreate",
        "description": "A request to execute a Flex Stacker SetStoredLabware command."
      },
      "SetStoredLabwareParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Flex Stacker."
          },
          "primaryLabware": {
            "$ref": "#/components/schemas/StackerStoredLabwareDetails",
            "description": "The details of the primary labware (i.e. not the lid or adapter, if any) stored in the stacker."
          },
          "lidLabware": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StackerStoredLabwareDetails"
              },
              {
                "type": "null"
              }
            ],
            "description": "The details of the lid on the primary labware, if any."
          },
          "adapterLabware": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StackerStoredLabwareDetails"
              },
              {
                "type": "null"
              }
            ],
            "description": "The details of the adapter under the primary labware, if any."
          },
          "initialCount": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Initialcount",
            "description": "The number of labware that should be initially stored in the stacker. This number will be silently clamped to the maximum number of labware that will fit; do not rely on the parameter to know how many labware are in the stacker."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "primaryLabware"
        ],
        "title": "SetStoredLabwareParams",
        "description": "Input parameters for a setStoredLabware command."
      },
      "SetStoredLabwareResult": {
        "properties": {
          "primaryLabwareDefinition": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LabwareDefinition2"
              },
              {
                "$ref": "#/components/schemas/LabwareDefinition3"
              }
            ],
            "title": "Primarylabwaredefinition",
            "description": "The definition of the primary labware.",
            "discriminator": {
              "propertyName": "schemaVersion",
              "mapping": {
                "2": "#/components/schemas/LabwareDefinition2",
                "3": "#/components/schemas/LabwareDefinition3"
              }
            }
          },
          "lidLabwareDefinition": {
            "anyOf": [
              {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/LabwareDefinition2"
                  },
                  {
                    "$ref": "#/components/schemas/LabwareDefinition3"
                  }
                ],
                "discriminator": {
                  "propertyName": "schemaVersion",
                  "mapping": {
                    "2": "#/components/schemas/LabwareDefinition2",
                    "3": "#/components/schemas/LabwareDefinition3"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwaredefinition",
            "description": "The definition of the lid on the primary labware, if any."
          },
          "adapterLabwareDefinition": {
            "anyOf": [
              {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/LabwareDefinition2"
                  },
                  {
                    "$ref": "#/components/schemas/LabwareDefinition3"
                  }
                ],
                "discriminator": {
                  "propertyName": "schemaVersion",
                  "mapping": {
                    "2": "#/components/schemas/LabwareDefinition2",
                    "3": "#/components/schemas/LabwareDefinition3"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwaredefinition",
            "description": "The definition of the adapter under the primary labware, if any."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "The number of labware loaded into the stacker labware pool."
          }
        },
        "type": "object",
        "required": [
          "primaryLabwareDefinition",
          "lidLabwareDefinition",
          "adapterLabwareDefinition",
          "count"
        ],
        "title": "SetStoredLabwareResult",
        "description": "Result data from a setstoredlabware command."
      },
      "SetTargetBlockTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/setTargetBlockTemperature"
            ],
            "const": "thermocycler/setTargetBlockTemperature",
            "title": "Commandtype",
            "default": "thermocycler/setTargetBlockTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetTargetBlockTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetTargetBlockTemperature",
        "description": "A command to set a Thermocycler's target block temperature."
      },
      "SetTargetBlockTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/setTargetBlockTemperature"
            ],
            "const": "thermocycler/setTargetBlockTemperature",
            "title": "Commandtype",
            "default": "thermocycler/setTargetBlockTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/SetTargetBlockTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetTargetBlockTemperatureCreate",
        "description": "A request to create a Thermocycler's set block temperature command."
      },
      "SetTargetBlockTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          },
          "blockMaxVolumeUl": {
            "type": "number",
            "title": "Blockmaxvolumeul",
            "description": "Amount of liquid in uL of the most-full well in labware loaded onto the thermocycler."
          },
          "holdTimeSeconds": {
            "type": "number",
            "title": "Holdtimeseconds",
            "description": "Amount of time, in seconds, to hold the temperature for. If specified, a waitForBlockTemperature command will block until the given hold time has elapsed."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "celsius"
        ],
        "title": "SetTargetBlockTemperatureParams",
        "description": "Input parameters to set a Thermocycler's target block temperature."
      },
      "SetTargetBlockTemperatureResult": {
        "properties": {
          "targetBlockTemperature": {
            "type": "number",
            "title": "Targetblocktemperature",
            "description": "The target block temperature that was set after validation."
          }
        },
        "type": "object",
        "required": [
          "targetBlockTemperature"
        ],
        "title": "SetTargetBlockTemperatureResult",
        "description": "Result data from setting a Thermocycler's target block temperature."
      },
      "SetTargetLidTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/setTargetLidTemperature"
            ],
            "const": "thermocycler/setTargetLidTemperature",
            "title": "Commandtype",
            "default": "thermocycler/setTargetLidTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/SetTargetLidTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SetTargetLidTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetTargetLidTemperature",
        "description": "A command to set a Thermocycler's target lid temperature."
      },
      "SetTargetLidTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/setTargetLidTemperature"
            ],
            "const": "thermocycler/setTargetLidTemperature",
            "title": "Commandtype",
            "default": "thermocycler/setTargetLidTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/SetTargetLidTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetTargetLidTemperatureCreate",
        "description": "A request to create a Thermocycler's set lid temperature command."
      },
      "SetTargetLidTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "celsius"
        ],
        "title": "SetTargetLidTemperatureParams",
        "description": "Input parameters to set a Thermocycler's target lid temperature."
      },
      "SetTargetLidTemperatureResult": {
        "properties": {
          "targetLidTemperature": {
            "type": "number",
            "title": "Targetlidtemperature",
            "description": "The target lid temperature that was set after validation."
          }
        },
        "type": "object",
        "required": [
          "targetLidTemperature"
        ],
        "title": "SetTargetLidTemperatureResult",
        "description": "Result data from setting a Thermocycler's target lid temperature."
      },
      "SetupCommandNotAllowed": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "SetupCommandNotAllowed"
            ],
            "const": "SetupCommandNotAllowed",
            "title": "Id",
            "default": "SetupCommandNotAllowed"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Setup Command Not Allowed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "SetupCommandNotAllowed",
        "description": "An error if a given run setup command is not allowed."
      },
      "SimpleBody_Annotated_Union_AirGapInPlace__Aspirate__AspirateInPlace__AspirateWhileTracking__Comment__Custom__Dispense__DispenseInPlace__DispenseWhileTracking__BlowOut__BlowOutInPlace__ConfigureForVolume__ConfigureNozzleLayout__DropTip__DropTipInPlace__Home__RetractAxis__LoadLabware__ReloadLabware__LoadLiquid__LoadLiquidClass__LoadModule__LoadPipette__LoadLidStack__LoadLid__MoveLabware__MoveRelative__MoveToCoordinates__MoveToWell__MoveToAddressableArea__MoveToAddressableAreaForDropTip__PrepareToAspirate__WaitForResume__WaitForDuration__PickUpTip__SavePosition__SetRailLights__TouchTip__SetStatusBar__VerifyTipPresence__GetTipPresence__GetNextTip__LiquidProbe__TryLiquidProbe__EvotipSealPipette__EvotipDispense__EvotipUnsealPipette__WaitForTemperature__SetTargetTemperature__DeactivateHeater__SetAndWaitForShakeSpeed__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch__Disengage__Engage__SetTargetTemperature__WaitForTemperature__DeactivateTemperature__SetTargetBlockTemperature__WaitForBlockTemperature__SetTargetLidTemperature__WaitForLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__RunProfile__RunExtendedProfile__CloseLid__OpenLid__Initialize__ReadAbsorbance__Retrieve__Store__SetStoredLabware__Fill__Empty__CalibrateGripper__CalibratePipette__CalibrateModule__MoveToMaintenancePosition__UnsafeBlowOutInPlace__UnsafeDropTipInPlace__UpdatePositionEstimators__UnsafeEngageAxes__UnsafeUngripLabware__UnsafePlaceLabware__MoveTo__MoveAxesRelative__MoveAxesTo__openGripperJaw__closeGripperJaw___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____": {
        "properties": {
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AirGapInPlace"
              },
              {
                "$ref": "#/components/schemas/Aspirate"
              },
              {
                "$ref": "#/components/schemas/AspirateInPlace"
              },
              {
                "$ref": "#/components/schemas/AspirateWhileTracking"
              },
              {
                "$ref": "#/components/schemas/Comment"
              },
              {
                "$ref": "#/components/schemas/Custom"
              },
              {
                "$ref": "#/components/schemas/Dispense"
              },
              {
                "$ref": "#/components/schemas/DispenseInPlace"
              },
              {
                "$ref": "#/components/schemas/DispenseWhileTracking"
              },
              {
                "$ref": "#/components/schemas/BlowOut"
              },
              {
                "$ref": "#/components/schemas/BlowOutInPlace"
              },
              {
                "$ref": "#/components/schemas/ConfigureForVolume"
              },
              {
                "$ref": "#/components/schemas/ConfigureNozzleLayout"
              },
              {
                "$ref": "#/components/schemas/DropTip"
              },
              {
                "$ref": "#/components/schemas/DropTipInPlace"
              },
              {
                "$ref": "#/components/schemas/Home"
              },
              {
                "$ref": "#/components/schemas/RetractAxis"
              },
              {
                "$ref": "#/components/schemas/LoadLabware"
              },
              {
                "$ref": "#/components/schemas/ReloadLabware"
              },
              {
                "$ref": "#/components/schemas/LoadLiquid"
              },
              {
                "$ref": "#/components/schemas/LoadLiquidClass"
              },
              {
                "$ref": "#/components/schemas/LoadModule"
              },
              {
                "$ref": "#/components/schemas/LoadPipette"
              },
              {
                "$ref": "#/components/schemas/LoadLidStack"
              },
              {
                "$ref": "#/components/schemas/LoadLid"
              },
              {
                "$ref": "#/components/schemas/MoveLabware"
              },
              {
                "$ref": "#/components/schemas/MoveRelative"
              },
              {
                "$ref": "#/components/schemas/MoveToCoordinates"
              },
              {
                "$ref": "#/components/schemas/MoveToWell"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableArea"
              },
              {
                "$ref": "#/components/schemas/MoveToAddressableAreaForDropTip"
              },
              {
                "$ref": "#/components/schemas/PrepareToAspirate"
              },
              {
                "$ref": "#/components/schemas/WaitForResume"
              },
              {
                "$ref": "#/components/schemas/WaitForDuration"
              },
              {
                "$ref": "#/components/schemas/PickUpTip"
              },
              {
                "$ref": "#/components/schemas/SavePosition"
              },
              {
                "$ref": "#/components/schemas/SetRailLights"
              },
              {
                "$ref": "#/components/schemas/TouchTip"
              },
              {
                "$ref": "#/components/schemas/SetStatusBar"
              },
              {
                "$ref": "#/components/schemas/VerifyTipPresence"
              },
              {
                "$ref": "#/components/schemas/GetTipPresence"
              },
              {
                "$ref": "#/components/schemas/GetNextTip"
              },
              {
                "$ref": "#/components/schemas/LiquidProbe"
              },
              {
                "$ref": "#/components/schemas/TryLiquidProbe"
              },
              {
                "$ref": "#/components/schemas/EvotipSealPipette"
              },
              {
                "$ref": "#/components/schemas/EvotipDispense"
              },
              {
                "$ref": "#/components/schemas/EvotipUnsealPipette"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperature"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature"
              },
              {
                "$ref": "#/components/schemas/DeactivateHeater"
              },
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeed"
              },
              {
                "$ref": "#/components/schemas/DeactivateShaker"
              },
              {
                "$ref": "#/components/schemas/OpenLabwareLatch"
              },
              {
                "$ref": "#/components/schemas/CloseLabwareLatch"
              },
              {
                "$ref": "#/components/schemas/Disengage"
              },
              {
                "$ref": "#/components/schemas/Engage"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperature"
              },
              {
                "$ref": "#/components/schemas/DeactivateTemperature"
              },
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperature"
              },
              {
                "$ref": "#/components/schemas/WaitForBlockTemperature"
              },
              {
                "$ref": "#/components/schemas/SetTargetLidTemperature"
              },
              {
                "$ref": "#/components/schemas/WaitForLidTemperature"
              },
              {
                "$ref": "#/components/schemas/DeactivateBlock"
              },
              {
                "$ref": "#/components/schemas/DeactivateLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid"
              },
              {
                "$ref": "#/components/schemas/RunProfile"
              },
              {
                "$ref": "#/components/schemas/RunExtendedProfile"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLid"
              },
              {
                "$ref": "#/components/schemas/Initialize"
              },
              {
                "$ref": "#/components/schemas/ReadAbsorbance"
              },
              {
                "$ref": "#/components/schemas/Retrieve"
              },
              {
                "$ref": "#/components/schemas/Store"
              },
              {
                "$ref": "#/components/schemas/SetStoredLabware"
              },
              {
                "$ref": "#/components/schemas/Fill"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "$ref": "#/components/schemas/CalibrateGripper"
              },
              {
                "$ref": "#/components/schemas/CalibratePipette"
              },
              {
                "$ref": "#/components/schemas/CalibrateModule"
              },
              {
                "$ref": "#/components/schemas/MoveToMaintenancePosition"
              },
              {
                "$ref": "#/components/schemas/UnsafeBlowOutInPlace"
              },
              {
                "$ref": "#/components/schemas/UnsafeDropTipInPlace"
              },
              {
                "$ref": "#/components/schemas/UpdatePositionEstimators"
              },
              {
                "$ref": "#/components/schemas/UnsafeEngageAxes"
              },
              {
                "$ref": "#/components/schemas/UnsafeUngripLabware"
              },
              {
                "$ref": "#/components/schemas/UnsafePlaceLabware"
              },
              {
                "$ref": "#/components/schemas/MoveTo"
              },
              {
                "$ref": "#/components/schemas/MoveAxesRelative"
              },
              {
                "$ref": "#/components/schemas/MoveAxesTo"
              },
              {
                "$ref": "#/components/schemas/openGripperJaw"
              },
              {
                "$ref": "#/components/schemas/closeGripperJaw"
              }
            ],
            "title": "Data",
            "description": "The documents primary data",
            "discriminator": {
              "propertyName": "commandType",
              "mapping": {
                "absorbanceReader/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLid",
                "absorbanceReader/initialize": "#/components/schemas/Initialize",
                "absorbanceReader/openLid": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLid",
                "absorbanceReader/read": "#/components/schemas/ReadAbsorbance",
                "airGapInPlace": "#/components/schemas/AirGapInPlace",
                "aspirate": "#/components/schemas/Aspirate",
                "aspirateInPlace": "#/components/schemas/AspirateInPlace",
                "aspirateWhileTracking": "#/components/schemas/AspirateWhileTracking",
                "blowOutInPlace": "#/components/schemas/BlowOutInPlace",
                "blowout": "#/components/schemas/BlowOut",
                "calibration/calibrateGripper": "#/components/schemas/CalibrateGripper",
                "calibration/calibrateModule": "#/components/schemas/CalibrateModule",
                "calibration/calibratePipette": "#/components/schemas/CalibratePipette",
                "calibration/moveToMaintenancePosition": "#/components/schemas/MoveToMaintenancePosition",
                "comment": "#/components/schemas/Comment",
                "configureForVolume": "#/components/schemas/ConfigureForVolume",
                "configureNozzleLayout": "#/components/schemas/ConfigureNozzleLayout",
                "custom": "#/components/schemas/Custom",
                "dispense": "#/components/schemas/Dispense",
                "dispenseInPlace": "#/components/schemas/DispenseInPlace",
                "dispenseWhileTracking": "#/components/schemas/DispenseWhileTracking",
                "dropTip": "#/components/schemas/DropTip",
                "dropTipInPlace": "#/components/schemas/DropTipInPlace",
                "evotipDispense": "#/components/schemas/EvotipDispense",
                "evotipSealPipette": "#/components/schemas/EvotipSealPipette",
                "evotipUnsealPipette": "#/components/schemas/EvotipUnsealPipette",
                "flexStacker/empty": "#/components/schemas/Empty",
                "flexStacker/fill": "#/components/schemas/Fill",
                "flexStacker/retrieve": "#/components/schemas/Retrieve",
                "flexStacker/setStoredLabware": "#/components/schemas/SetStoredLabware",
                "flexStacker/store": "#/components/schemas/Store",
                "getNextTip": "#/components/schemas/GetNextTip",
                "getTipPresence": "#/components/schemas/GetTipPresence",
                "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatch",
                "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeater",
                "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShaker",
                "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatch",
                "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeed",
                "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature",
                "heaterShaker/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperature",
                "home": "#/components/schemas/Home",
                "liquidProbe": "#/components/schemas/LiquidProbe",
                "loadLabware": "#/components/schemas/LoadLabware",
                "loadLid": "#/components/schemas/LoadLid",
                "loadLidStack": "#/components/schemas/LoadLidStack",
                "loadLiquid": "#/components/schemas/LoadLiquid",
                "loadLiquidClass": "#/components/schemas/LoadLiquidClass",
                "loadModule": "#/components/schemas/LoadModule",
                "loadPipette": "#/components/schemas/LoadPipette",
                "magneticModule/disengage": "#/components/schemas/Disengage",
                "magneticModule/engage": "#/components/schemas/Engage",
                "moveLabware": "#/components/schemas/MoveLabware",
                "moveRelative": "#/components/schemas/MoveRelative",
                "moveToAddressableArea": "#/components/schemas/MoveToAddressableArea",
                "moveToAddressableAreaForDropTip": "#/components/schemas/MoveToAddressableAreaForDropTip",
                "moveToCoordinates": "#/components/schemas/MoveToCoordinates",
                "moveToWell": "#/components/schemas/MoveToWell",
                "pause": "#/components/schemas/WaitForResume",
                "pickUpTip": "#/components/schemas/PickUpTip",
                "prepareToAspirate": "#/components/schemas/PrepareToAspirate",
                "reloadLabware": "#/components/schemas/ReloadLabware",
                "retractAxis": "#/components/schemas/RetractAxis",
                "robot/closeGripperJaw": "#/components/schemas/closeGripperJaw",
                "robot/moveAxesRelative": "#/components/schemas/MoveAxesRelative",
                "robot/moveAxesTo": "#/components/schemas/MoveAxesTo",
                "robot/moveTo": "#/components/schemas/MoveTo",
                "robot/openGripperJaw": "#/components/schemas/openGripperJaw",
                "savePosition": "#/components/schemas/SavePosition",
                "setRailLights": "#/components/schemas/SetRailLights",
                "setStatusBar": "#/components/schemas/SetStatusBar",
                "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperature",
                "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature",
                "temperatureModule/waitForTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperature",
                "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid",
                "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlock",
                "thermocycler/deactivateLid": "#/components/schemas/DeactivateLid",
                "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid",
                "thermocycler/runExtendedProfile": "#/components/schemas/RunExtendedProfile",
                "thermocycler/runProfile": "#/components/schemas/RunProfile",
                "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperature",
                "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperature",
                "thermocycler/waitForBlockTemperature": "#/components/schemas/WaitForBlockTemperature",
                "thermocycler/waitForLidTemperature": "#/components/schemas/WaitForLidTemperature",
                "touchTip": "#/components/schemas/TouchTip",
                "tryLiquidProbe": "#/components/schemas/TryLiquidProbe",
                "unsafe/blowOutInPlace": "#/components/schemas/UnsafeBlowOutInPlace",
                "unsafe/dropTipInPlace": "#/components/schemas/UnsafeDropTipInPlace",
                "unsafe/engageAxes": "#/components/schemas/UnsafeEngageAxes",
                "unsafe/placeLabware": "#/components/schemas/UnsafePlaceLabware",
                "unsafe/ungripLabware": "#/components/schemas/UnsafeUngripLabware",
                "unsafe/updatePositionEstimators": "#/components/schemas/UpdatePositionEstimators",
                "verifyTipPresence": "#/components/schemas/VerifyTipPresence",
                "waitForDuration": "#/components/schemas/WaitForDuration",
                "waitForResume": "#/components/schemas/WaitForResume"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Annotated[Union[AirGapInPlace, Aspirate, AspirateInPlace, AspirateWhileTracking, Comment, Custom, Dispense, DispenseInPlace, DispenseWhileTracking, BlowOut, BlowOutInPlace, ConfigureForVolume, ConfigureNozzleLayout, DropTip, DropTipInPlace, Home, RetractAxis, LoadLabware, ReloadLabware, LoadLiquid, LoadLiquidClass, LoadModule, LoadPipette, LoadLidStack, LoadLid, MoveLabware, MoveRelative, MoveToCoordinates, MoveToWell, MoveToAddressableArea, MoveToAddressableAreaForDropTip, PrepareToAspirate, WaitForResume, WaitForDuration, PickUpTip, SavePosition, SetRailLights, TouchTip, SetStatusBar, VerifyTipPresence, GetTipPresence, GetNextTip, LiquidProbe, TryLiquidProbe, EvotipSealPipette, EvotipDispense, EvotipUnsealPipette, WaitForTemperature, SetTargetTemperature, DeactivateHeater, SetAndWaitForShakeSpeed, DeactivateShaker, OpenLabwareLatch, CloseLabwareLatch, Disengage, Engage, SetTargetTemperature, WaitForTemperature, DeactivateTemperature, SetTargetBlockTemperature, WaitForBlockTemperature, SetTargetLidTemperature, WaitForLidTemperature, DeactivateBlock, DeactivateLid, OpenLid, CloseLid, RunProfile, RunExtendedProfile, CloseLid, OpenLid, Initialize, ReadAbsorbance, Retrieve, Store, SetStoredLabware, Fill, Empty, CalibrateGripper, CalibratePipette, CalibrateModule, MoveToMaintenancePosition, UnsafeBlowOutInPlace, UnsafeDropTipInPlace, UpdatePositionEstimators, UnsafeEngageAxes, UnsafeUngripLabware, UnsafePlaceLabware, MoveTo, MoveAxesRelative, MoveAxesTo, openGripperJaw, closeGripperJaw], FieldInfo(annotation=NoneType, required=True, discriminator='commandType')]]"
      },
      "SimpleBody_Annotated_Union_Home__SetRailLights__SetStatusBar__Engage__Disengage__SetTargetTemperature__DeactivateTemperature__SetTargetBlockTemperature__SetTargetLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__SetTargetTemperature__SetAndWaitForShakeSpeed__DeactivateHeater__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____": {
        "properties": {
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Home"
              },
              {
                "$ref": "#/components/schemas/SetRailLights"
              },
              {
                "$ref": "#/components/schemas/SetStatusBar"
              },
              {
                "$ref": "#/components/schemas/Engage"
              },
              {
                "$ref": "#/components/schemas/Disengage"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature"
              },
              {
                "$ref": "#/components/schemas/DeactivateTemperature"
              },
              {
                "$ref": "#/components/schemas/SetTargetBlockTemperature"
              },
              {
                "$ref": "#/components/schemas/SetTargetLidTemperature"
              },
              {
                "$ref": "#/components/schemas/DeactivateBlock"
              },
              {
                "$ref": "#/components/schemas/DeactivateLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid"
              },
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature"
              },
              {
                "$ref": "#/components/schemas/SetAndWaitForShakeSpeed"
              },
              {
                "$ref": "#/components/schemas/DeactivateHeater"
              },
              {
                "$ref": "#/components/schemas/DeactivateShaker"
              },
              {
                "$ref": "#/components/schemas/OpenLabwareLatch"
              },
              {
                "$ref": "#/components/schemas/CloseLabwareLatch"
              }
            ],
            "title": "Data",
            "description": "The documents primary data",
            "discriminator": {
              "propertyName": "commandType",
              "mapping": {
                "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatch",
                "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeater",
                "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShaker",
                "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatch",
                "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeed",
                "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature",
                "home": "#/components/schemas/Home",
                "magneticModule/disengage": "#/components/schemas/Disengage",
                "magneticModule/engage": "#/components/schemas/Engage",
                "setRailLights": "#/components/schemas/SetRailLights",
                "setStatusBar": "#/components/schemas/SetStatusBar",
                "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperature",
                "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature",
                "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid",
                "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlock",
                "thermocycler/deactivateLid": "#/components/schemas/DeactivateLid",
                "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid",
                "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperature",
                "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperature"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Annotated[Union[Home, SetRailLights, SetStatusBar, Engage, Disengage, SetTargetTemperature, DeactivateTemperature, SetTargetBlockTemperature, SetTargetLidTemperature, DeactivateBlock, DeactivateLid, OpenLid, CloseLid, SetTargetTemperature, SetAndWaitForShakeSpeed, DeactivateHeater, DeactivateShaker, OpenLabwareLatch, CloseLabwareLatch], FieldInfo(annotation=NoneType, required=True, discriminator='commandType')]]"
      },
      "SimpleBody_DataFile_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/DataFile",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[DataFile]"
      },
      "SimpleBody_DeckConfigurationResponse_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/DeckConfigurationResponse",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[DeckConfigurationResponse]"
      },
      "SimpleBody_DoorStatusModel_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/DoorStatusModel",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[DoorStatusModel]"
      },
      "SimpleBody_ErrorRecoveryPolicy_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/ErrorRecoveryPolicy",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[ErrorRecoveryPolicy]"
      },
      "SimpleBody_EstopStatusModel_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/EstopStatusModel",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[EstopStatusModel]"
      },
      "SimpleBody_LabwareDefinitionSummary_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/LabwareDefinitionSummary",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[LabwareDefinitionSummary]"
      },
      "SimpleBody_MaintenanceRun_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/MaintenanceRun",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[MaintenanceRun]"
      },
      "SimpleBody_PresentSubsystem_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/PresentSubsystem",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[PresentSubsystem]"
      },
      "SimpleBody_Protocol_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/Protocol",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Protocol]"
      },
      "SimpleBody_ResponseData_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/ResponseData",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[ResponseData]"
      },
      "SimpleBody_RunAction_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/RunAction",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[RunAction]"
      },
      "SimpleBody_Run_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/Run",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Run]"
      },
      "SimpleBody_StoredLabwareOffset_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/StoredLabwareOffset",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[StoredLabwareOffset]"
      },
      "SimpleBody_Union_LabwareOffset__list_LabwareOffset___": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LabwareOffset"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/LabwareOffset"
                },
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Union[LabwareOffset, list[LabwareOffset]]]"
      },
      "SimpleBody_Union_PendingAnalysis__CompletedAnalysis__": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PendingAnalysis"
              },
              {
                "$ref": "#/components/schemas/CompletedAnalysis"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Union[PendingAnalysis, CompletedAnalysis]]"
      },
      "SimpleBody_Union_Run__BadRun__": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Run"
              },
              {
                "$ref": "#/components/schemas/BadRun"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Union[Run, BadRun]]"
      },
      "SimpleBody_Union_StoredLabwareOffset__list_StoredLabwareOffset___": {
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StoredLabwareOffset"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/StoredLabwareOffset"
                },
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[Union[StoredLabwareOffset, list[StoredLabwareOffset]]]"
      },
      "SimpleBody_UpdateProgressData_": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/UpdateProgressData",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[UpdateProgressData]"
      },
      "SimpleBody_dict_str__object__": {
        "properties": {
          "data": {
            "type": "object",
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[dict[str, object]]"
      },
      "SimpleBody_list_Annotated_Union_LabwareDefinition2__LabwareDefinition3___Discriminator___": {
        "properties": {
          "data": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/LabwareDefinition2"
                },
                {
                  "$ref": "#/components/schemas/LabwareDefinition3"
                }
              ],
              "discriminator": {
                "propertyName": "schemaVersion",
                "mapping": {
                  "2": "#/components/schemas/LabwareDefinition2",
                  "3": "#/components/schemas/LabwareDefinition3"
                }
              }
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimpleBody[list[Annotated[Union[LabwareDefinition2, LabwareDefinition3], Discriminator]]]"
      },
      "SimpleEmptyBody": {
        "properties": {},
        "type": "object",
        "title": "SimpleEmptyBody",
        "description": "A response that returns no data and no links."
      },
      "SimpleMultiBody_AnalysisSummary_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/AnalysisSummary"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[AnalysisSummary]"
      },
      "SimpleMultiBody_Annotated_Union_Home__SetRailLights__SetStatusBar__Engage__Disengage__SetTargetTemperature__DeactivateTemperature__SetTargetBlockTemperature__SetTargetLidTemperature__DeactivateBlock__DeactivateLid__OpenLid__CloseLid__SetTargetTemperature__SetAndWaitForShakeSpeed__DeactivateHeater__DeactivateShaker__OpenLabwareLatch__CloseLabwareLatch___FieldInfo_annotation_NoneType__required_True__discriminator__commandType____": {
        "properties": {
          "data": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Home"
                },
                {
                  "$ref": "#/components/schemas/SetRailLights"
                },
                {
                  "$ref": "#/components/schemas/SetStatusBar"
                },
                {
                  "$ref": "#/components/schemas/Engage"
                },
                {
                  "$ref": "#/components/schemas/Disengage"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature"
                },
                {
                  "$ref": "#/components/schemas/DeactivateTemperature"
                },
                {
                  "$ref": "#/components/schemas/SetTargetBlockTemperature"
                },
                {
                  "$ref": "#/components/schemas/SetTargetLidTemperature"
                },
                {
                  "$ref": "#/components/schemas/DeactivateBlock"
                },
                {
                  "$ref": "#/components/schemas/DeactivateLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid"
                },
                {
                  "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature"
                },
                {
                  "$ref": "#/components/schemas/SetAndWaitForShakeSpeed"
                },
                {
                  "$ref": "#/components/schemas/DeactivateHeater"
                },
                {
                  "$ref": "#/components/schemas/DeactivateShaker"
                },
                {
                  "$ref": "#/components/schemas/OpenLabwareLatch"
                },
                {
                  "$ref": "#/components/schemas/CloseLabwareLatch"
                }
              ],
              "discriminator": {
                "propertyName": "commandType",
                "mapping": {
                  "heaterShaker/closeLabwareLatch": "#/components/schemas/CloseLabwareLatch",
                  "heaterShaker/deactivateHeater": "#/components/schemas/DeactivateHeater",
                  "heaterShaker/deactivateShaker": "#/components/schemas/DeactivateShaker",
                  "heaterShaker/openLabwareLatch": "#/components/schemas/OpenLabwareLatch",
                  "heaterShaker/setAndWaitForShakeSpeed": "#/components/schemas/SetAndWaitForShakeSpeed",
                  "heaterShaker/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature",
                  "home": "#/components/schemas/Home",
                  "magneticModule/disengage": "#/components/schemas/Disengage",
                  "magneticModule/engage": "#/components/schemas/Engage",
                  "setRailLights": "#/components/schemas/SetRailLights",
                  "setStatusBar": "#/components/schemas/SetStatusBar",
                  "temperatureModule/deactivate": "#/components/schemas/DeactivateTemperature",
                  "temperatureModule/setTargetTemperature": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature",
                  "thermocycler/closeLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid",
                  "thermocycler/deactivateBlock": "#/components/schemas/DeactivateBlock",
                  "thermocycler/deactivateLid": "#/components/schemas/DeactivateLid",
                  "thermocycler/openLid": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid",
                  "thermocycler/setTargetBlockTemperature": "#/components/schemas/SetTargetBlockTemperature",
                  "thermocycler/setTargetLidTemperature": "#/components/schemas/SetTargetLidTemperature"
                }
              }
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[Annotated[Union[Home, SetRailLights, SetStatusBar, Engage, Disengage, SetTargetTemperature, DeactivateTemperature, SetTargetBlockTemperature, SetTargetLidTemperature, DeactivateBlock, DeactivateLid, OpenLid, CloseLid, SetTargetTemperature, SetAndWaitForShakeSpeed, DeactivateHeater, DeactivateShaker, OpenLabwareLatch, CloseLabwareLatch], FieldInfo(annotation=NoneType, required=True, discriminator='commandType')]]"
      },
      "SimpleMultiBody_DataFile_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/DataFile"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[DataFile]"
      },
      "SimpleMultiBody_ErrorOccurrence_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[ErrorOccurrence]"
      },
      "SimpleMultiBody_PresentSubsystem_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/PresentSubsystem"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[PresentSubsystem]"
      },
      "SimpleMultiBody_Protocol_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/Protocol"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[Protocol]"
      },
      "SimpleMultiBody_StoredLabwareOffset_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/StoredLabwareOffset"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[StoredLabwareOffset]"
      },
      "SimpleMultiBody_Union_PendingAnalysis__CompletedAnalysis__": {
        "properties": {
          "data": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/PendingAnalysis"
                },
                {
                  "$ref": "#/components/schemas/CompletedAnalysis"
                }
              ]
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[Union[PendingAnalysis, CompletedAnalysis]]"
      },
      "SimpleMultiBody_Union_Pipette__Gripper__BadPipette__BadGripper__": {
        "properties": {
          "data": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Pipette"
                },
                {
                  "$ref": "#/components/schemas/Gripper"
                },
                {
                  "$ref": "#/components/schemas/BadPipette"
                },
                {
                  "$ref": "#/components/schemas/BadGripper"
                }
              ]
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[Union[Pipette, Gripper, BadPipette, BadGripper]]"
      },
      "SimpleMultiBody_Union_TemperatureModule__MagneticModule__ThermocyclerModule__HeaterShakerModule__AbsorbanceReaderModule__FlexStackerModule__": {
        "properties": {
          "data": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TemperatureModule"
                },
                {
                  "$ref": "#/components/schemas/MagneticModule"
                },
                {
                  "$ref": "#/components/schemas/ThermocyclerModule"
                },
                {
                  "$ref": "#/components/schemas/HeaterShakerModule"
                },
                {
                  "$ref": "#/components/schemas/AbsorbanceReaderModule"
                },
                {
                  "$ref": "#/components/schemas/FlexStackerModule"
                }
              ]
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[Union[TemperatureModule, MagneticModule, ThermocyclerModule, HeaterShakerModule, AbsorbanceReaderModule, FlexStackerModule]]"
      },
      "SimpleMultiBody_UpdateProgressData_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/UpdateProgressData"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[UpdateProgressData]"
      },
      "SimpleMultiBody_UpdateProgressSummary_": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/UpdateProgressSummary"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[UpdateProgressSummary]"
      },
      "SimpleMultiBody_str_": {
        "properties": {
          "data": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Data",
            "description": "The documents primary data"
          },
          "meta": {
            "$ref": "#/components/schemas/MultiBodyMeta",
            "description": "Metadata about the collection response."
          }
        },
        "type": "object",
        "required": [
          "data",
          "meta"
        ],
        "title": "SimpleMultiBody[str]"
      },
      "SimulatedProbeResult": {
        "properties": {
          "operations_after_probe": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Operations After Probe",
            "default": []
          },
          "net_liquid_exchanged_after_probe": {
            "type": "number",
            "title": "Net Liquid Exchanged After Probe",
            "default": 0
          }
        },
        "type": "object",
        "title": "SimulatedProbeResult",
        "description": "A sentinel value to substitute for the resulting volume/height of a liquid probe during simulation."
      },
      "SingleDispenseProperties": {
        "properties": {
          "submerge": {
            "$ref": "#/components/schemas/Submerge",
            "description": "Submerge settings for single dispense."
          },
          "retract": {
            "$ref": "#/components/schemas/RetractDispense",
            "description": "Pipette retract settings after a single dispense."
          },
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for single dispense."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for single dispense."
          },
          "flowRateByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Flowratebyvolume",
            "description": "Settings for flow rate keyed by target dispense volume."
          },
          "correctionByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Correctionbyvolume",
            "description": "Settings for volume correction keyed by by target dispense volume, representing additional volume the plunger should move to accurately hit target volume."
          },
          "mix": {
            "$ref": "#/components/schemas/MixProperties",
            "description": "Mixing settings for after a dispense"
          },
          "pushOutByVolume": {
            "items": {
              "prefixItems": [
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                },
                {
                  "anyOf": [
                    {
                      "type": "integer",
                      "minimum": 0
                    },
                    {
                      "type": "number",
                      "minimum": 0
                    }
                  ]
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Pushoutbyvolume",
            "description": "Settings for pushout keyed by target dispense volume."
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay after dispense, in seconds."
          }
        },
        "type": "object",
        "required": [
          "submerge",
          "retract",
          "positionReference",
          "offset",
          "flowRateByVolume",
          "correctionByVolume",
          "mix",
          "pushOutByVolume",
          "delay"
        ],
        "title": "SingleDispenseProperties",
        "description": "Properties specific to the single-dispense function."
      },
      "SingleNozzleLayoutConfiguration": {
        "properties": {
          "style": {
            "type": "string",
            "enum": [
              "SINGLE"
            ],
            "const": "SINGLE",
            "title": "Style",
            "default": "SINGLE"
          },
          "primaryNozzle": {
            "type": "string",
            "enum": [
              "A1",
              "H1",
              "A12",
              "H12"
            ],
            "title": "Primarynozzle",
            "description": "The primary nozzle to use in the layout configuration. This nozzle will update the critical point of the current pipette. For now, this is also the back left corner of your rectangle."
          }
        },
        "type": "object",
        "required": [
          "primaryNozzle"
        ],
        "title": "SingleNozzleLayoutConfiguration",
        "description": "Minimum information required for a new nozzle configuration."
      },
      "SourceType": {
        "type": "string",
        "enum": [
          "default",
          "factory",
          "user",
          "calibration_check",
          "legacy",
          "unknown"
        ],
        "title": "SourceType",
        "description": "Calibration source type"
      },
      "SpeedStatus": {
        "type": "string",
        "enum": [
          "holding at target",
          "speeding up",
          "slowing down",
          "idle",
          "error"
        ],
        "title": "SpeedStatus"
      },
      "SphericalSegment": {
        "properties": {
          "shape": {
            "type": "string",
            "enum": [
              "spherical"
            ],
            "const": "spherical",
            "title": "Shape"
          },
          "radiusOfCurvature": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Radiusofcurvature"
          },
          "topHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topheight"
          },
          "bottomHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomheight"
          },
          "xCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Xcount",
            "default": 1
          },
          "yCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Ycount",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "shape",
          "radiusOfCurvature",
          "topHeight",
          "bottomHeight"
        ],
        "title": "SphericalSegment"
      },
      "SquaredConeSegment": {
        "properties": {
          "shape": {
            "type": "string",
            "enum": [
              "squaredcone"
            ],
            "const": "squaredcone",
            "title": "Shape"
          },
          "bottomCrossSection": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "circular"
                ],
                "const": "circular"
              },
              {
                "type": "string",
                "enum": [
                  "rectangular"
                ],
                "const": "rectangular"
              }
            ],
            "title": "Bottomcrosssection"
          },
          "circleDiameter": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Circlediameter"
          },
          "rectangleXDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Rectanglexdimension"
          },
          "rectangleYDimension": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Rectangleydimension"
          },
          "topHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Topheight"
          },
          "bottomHeight": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Bottomheight"
          },
          "xCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Xcount",
            "default": 1
          },
          "yCount": {
            "type": "integer",
            "minimum": 0,
            "title": "Ycount",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "shape",
          "bottomCrossSection",
          "circleDiameter",
          "rectangleXDimension",
          "rectangleYDimension",
          "topHeight",
          "bottomHeight"
        ],
        "title": "SquaredConeSegment"
      },
      "StackerAxisState": {
        "type": "string",
        "enum": [
          "unknown",
          "extended",
          "retracted"
        ],
        "title": "StackerAxisState"
      },
      "StackerFillEmptyStrategy": {
        "type": "string",
        "enum": [
          "manualWithPause",
          "logical"
        ],
        "title": "StackerFillEmptyStrategy",
        "description": "Strategy to use for filling or emptying a stacker."
      },
      "StackerStoredLabwareDetails": {
        "properties": {
          "loadName": {
            "type": "string",
            "title": "Loadname",
            "description": "Name used to reference the definition of this labware."
          },
          "namespace": {
            "type": "string",
            "title": "Namespace",
            "description": "Namespace of the definition of this labware."
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version of the definition of this labware."
          }
        },
        "type": "object",
        "required": [
          "loadName",
          "namespace",
          "version"
        ],
        "title": "StackerStoredLabwareDetails",
        "description": "The parameters defining a labware to be stored in the stacker."
      },
      "StallOrCollisionError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "stallOrCollision"
            ],
            "const": "stallOrCollision",
            "title": "Errortype",
            "default": "stallOrCollision"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "2003"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Stall or Collision Detected"
          },
          "errorInfo": {
            "type": "object",
            "title": "Errorinfo",
            "description": "Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n",
            "default": {}
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "StallOrCollisionError",
        "description": "Returned when the machine detects that axis encoders are reading a different position than expected.\n\nAll axes are stopped at the point where the error was encountered.\n\nThe next thing to move the machine must account for the robot not having a valid estimate\nof its position. It should be a `home` or `unsafe/updatePositionEstimators`."
      },
      "StatusBarAnimation": {
        "type": "string",
        "enum": [
          "idle",
          "confirm",
          "updating",
          "disco",
          "off"
        ],
        "title": "StatusBarAnimation",
        "description": "Status Bar animation options."
      },
      "Store": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/store"
            ],
            "const": "flexStacker/store",
            "title": "Commandtype",
            "default": "flexStacker/store"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/StoreParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StoreResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "Store",
        "description": "A command to store a labware in a Flex Stacker."
      },
      "StoreCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "flexStacker/store"
            ],
            "const": "flexStacker/store",
            "title": "Commandtype",
            "default": "flexStacker/store"
          },
          "params": {
            "$ref": "#/components/schemas/StoreParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "StoreCreate",
        "description": "A request to execute a Flex Stacker store command."
      },
      "StoreParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the flex stacker."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "StoreParams",
        "description": "Input parameters for a labware storage command."
      },
      "StoreResult": {
        "properties": {
          "eventualDestinationLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Eventualdestinationlocationsequence",
            "description": "The full location in which all labware moved by this command will eventually reside."
          },
          "primaryOriginLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Primaryoriginlocationsequence",
            "description": "The origin location of the primary labware."
          },
          "primaryLabwareId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Primarylabwareid",
            "description": "The primary labware in the stack that was stored."
          },
          "adapterOriginLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapteroriginlocationsequence",
            "description": "The origin location of the adapter labware, if any."
          },
          "adapterLabwareId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwareid",
            "description": "The adapter in the stack that was stored, if any."
          },
          "lidOriginLocationSequence": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/InStackerHopperLocation"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidoriginlocationsequence",
            "description": "The origin location of the lid labware, if any."
          },
          "lidLabwareId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwareid",
            "description": "The lid in the stack that was stored, if any."
          },
          "primaryLabwareURI": {
            "type": "string",
            "title": "Primarylabwareuri",
            "description": "The labware definition URI of the primary labware."
          },
          "adapterLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Adapterlabwareuri",
            "description": "The labware definition URI of the adapter labware."
          },
          "lidLabwareURI": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidlabwareuri",
            "description": "The labware definition URI of the lid labware."
          }
        },
        "type": "object",
        "required": [
          "primaryLabwareURI"
        ],
        "title": "StoreResult",
        "description": "Result data from a labware storage command."
      },
      "StoredLabwareOffset": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique labware offset record identifier."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When this labware offset was added."
          },
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The URI for the labware's definition."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/UnknownLabwareOffsetLocationSequenceComponent"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "kind",
                    "mapping": {
                      "onAddressableArea": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent",
                      "onLabware": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent",
                      "onModule": "#/components/schemas/OnModuleOffsetLocationSequenceComponent",
                      "unknown": "#/components/schemas/UnknownLabwareOffsetLocationSequenceComponent"
                    }
                  }
                },
                "type": "array"
              },
              {
                "type": "string",
                "enum": [
                  "anyLocation"
                ],
                "const": "anyLocation"
              }
            ],
            "minLength": 1,
            "title": "Locationsequence",
            "description": "Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location."
          },
          "vector": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "The offset applied to matching labware."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "definitionUri",
          "locationSequence",
          "vector"
        ],
        "title": "StoredLabwareOffset",
        "description": "An offset that the robot adds to a pipette's position when it moves to labware."
      },
      "StoredLabwareOffsetCreate": {
        "properties": {
          "definitionUri": {
            "type": "string",
            "title": "Definitionuri",
            "description": "The URI for the labware's definition."
          },
          "locationSequence": {
            "anyOf": [
              {
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    },
                    {
                      "$ref": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "kind",
                    "mapping": {
                      "onAddressableArea": "#/components/schemas/OnAddressableAreaOffsetLocationSequenceComponent",
                      "onLabware": "#/components/schemas/OnLabwareOffsetLocationSequenceComponent",
                      "onModule": "#/components/schemas/OnModuleOffsetLocationSequenceComponent"
                    }
                  }
                },
                "type": "array"
              },
              {
                "type": "string",
                "enum": [
                  "anyLocation"
                ],
                "const": "anyLocation"
              }
            ],
            "minLength": 1,
            "title": "Locationsequence",
            "description": "Where the labware is located on the robot. The special value `anyLocation` means this offset applies to any labware with a matching `definitionUri`, regardless of its location."
          },
          "vector": {
            "$ref": "#/components/schemas/LabwareOffsetVector",
            "description": "The offset applied to matching labware."
          }
        },
        "type": "object",
        "required": [
          "definitionUri",
          "locationSequence",
          "vector"
        ],
        "title": "StoredLabwareOffsetCreate",
        "description": "Create an offset for storage."
      },
      "SubSystem": {
        "type": "string",
        "enum": [
          "gantry_x",
          "gantry_y",
          "head",
          "pipette_left",
          "pipette_right",
          "gripper",
          "rear_panel",
          "hepa_uv",
          "motor_controller_board"
        ],
        "title": "SubSystem",
        "description": "Specific hardware elements of the robot system.\n\nOnly certain subsystems might be valid for a certain robot, and not all subsystems\nmight be attached at any given time. In general, specific subsystems should only\nbe provided if general queries indicate that they are present."
      },
      "Submerge": {
        "properties": {
          "positionReference": {
            "$ref": "#/components/schemas/PositionReference",
            "description": "Position reference for submerge."
          },
          "offset": {
            "$ref": "#/components/schemas/Coordinate",
            "description": "Relative offset for submerge."
          },
          "speed": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "number",
                "minimum": 0
              }
            ],
            "title": "Speed",
            "description": "Speed of submerging, in millimeters per second."
          },
          "delay": {
            "$ref": "#/components/schemas/DelayProperties",
            "description": "Delay settings for submerge."
          }
        },
        "type": "object",
        "required": [
          "positionReference",
          "offset",
          "speed",
          "delay"
        ],
        "title": "Submerge",
        "description": "Shared properties for the submerge function before aspiration or dispense."
      },
      "SubsystemNotPresent": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "SubsystemNotPresent"
            ],
            "const": "SubsystemNotPresent",
            "title": "Id",
            "default": "SubsystemNotPresent"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Subsystem Not Present"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "SubsystemNotPresent",
        "description": "An error if a subsystem that is not present is requested."
      },
      "SystemTimeAttributes": {
        "properties": {
          "systemTime": {
            "type": "string",
            "format": "date-time",
            "title": "Systemtime"
          }
        },
        "type": "object",
        "required": [
          "systemTime"
        ],
        "title": "SystemTimeAttributes",
        "description": "System time attributes common to requests and responses."
      },
      "SystemTimeResponseAttributes": {
        "properties": {
          "systemTime": {
            "type": "string",
            "format": "date-time",
            "title": "Systemtime"
          },
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          }
        },
        "type": "object",
        "required": [
          "systemTime",
          "id"
        ],
        "title": "SystemTimeResponseAttributes",
        "description": "System time response model attributes."
      },
      "TemperatureModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "temperatureModuleType"
            ],
            "const": "temperatureModuleType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "temperatureModuleV1",
              "temperatureModuleV2"
            ],
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/TemperatureModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "TemperatureModule",
        "description": "An attached Temperature Module."
      },
      "TemperatureModuleData": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/TemperatureStatus"
          },
          "currentTemperature": {
            "type": "number",
            "title": "Currenttemperature",
            "description": "The module's current temperature, in degrees Celsius."
          },
          "targetTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Targettemperature",
            "description": "The module's target temperature, if set, in degrees Celsius."
          }
        },
        "type": "object",
        "required": [
          "status",
          "currentTemperature",
          "targetTemperature"
        ],
        "title": "TemperatureModuleData",
        "description": "Live data from an attached Temperature Module."
      },
      "TemperatureStatus": {
        "type": "string",
        "enum": [
          "holding at target",
          "cooling",
          "heating",
          "idle",
          "error"
        ],
        "title": "TemperatureStatus"
      },
      "ThermocyclerLidStatus": {
        "type": "string",
        "enum": [
          "unknown",
          "closed",
          "in_between",
          "open",
          "max"
        ],
        "title": "ThermocyclerLidStatus",
        "description": "Thermocycler lid status."
      },
      "ThermocyclerModule": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique module identifier for use in requests to /modules and /commands."
          },
          "serialNumber": {
            "type": "string",
            "title": "Serialnumber",
            "description": "Device serial number."
          },
          "firmwareVersion": {
            "type": "string",
            "title": "Firmwareversion",
            "description": "Device firmware version."
          },
          "hardwareRevision": {
            "type": "string",
            "title": "Hardwarerevision",
            "description": "Device hardware revision."
          },
          "hasAvailableUpdate": {
            "type": "boolean",
            "title": "Hasavailableupdate",
            "description": "Whether a firmware update is available."
          },
          "moduleType": {
            "type": "string",
            "enum": [
              "thermocyclerModuleType"
            ],
            "const": "thermocyclerModuleType",
            "title": "Moduletype"
          },
          "moduleModel": {
            "type": "string",
            "enum": [
              "thermocyclerModuleV1",
              "thermocyclerModuleV2"
            ],
            "title": "Modulemodel"
          },
          "moduleOffset": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ModuleCalibrationData"
              },
              {
                "type": "null"
              }
            ],
            "description": "The calibrated module offset."
          },
          "compatibleWithRobot": {
            "type": "boolean",
            "title": "Compatiblewithrobot",
            "description": "Whether the detected module is compatible with this robot."
          },
          "data": {
            "$ref": "#/components/schemas/ThermocyclerModuleData"
          },
          "usbPort": {
            "$ref": "#/components/schemas/UsbPort"
          }
        },
        "type": "object",
        "required": [
          "id",
          "serialNumber",
          "firmwareVersion",
          "hardwareRevision",
          "hasAvailableUpdate",
          "moduleType",
          "moduleModel",
          "compatibleWithRobot",
          "data",
          "usbPort"
        ],
        "title": "ThermocyclerModule",
        "description": "An attached Thermocycler Module."
      },
      "ThermocyclerModuleData": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/TemperatureStatus",
            "description": "The current heating status of the thermocycler block."
          },
          "currentTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Currenttemperature",
            "description": "The current temperature of the thermocycler block, if known, in degrees Celsius."
          },
          "targetTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Targettemperature",
            "description": "The target temperature of the thermocycler block, if set, in degrees Celsius."
          },
          "lidStatus": {
            "$ref": "#/components/schemas/ThermocyclerLidStatus",
            "description": "The current lid status of the thermocycler."
          },
          "lidTemperatureStatus": {
            "$ref": "#/components/schemas/TemperatureStatus",
            "description": "The current heating status of the lid."
          },
          "lidTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidtemperature",
            "description": "The current temperature of the lid, if known, in degrees Celsius."
          },
          "lidTargetTemperature": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lidtargettemperature",
            "description": "The target temperature of the lid, if set, in degrees Celsius."
          },
          "holdTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Holdtime",
            "description": "The time left in the current hold step, if any, in seconds."
          },
          "rampRate": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ramprate",
            "description": "The current ramp rate for the thermocycler block, if set, in degrees Celsius per second."
          },
          "currentCycleIndex": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Currentcycleindex",
            "description": "The index of the current cycle within the current sequence, if a cycle is running."
          },
          "totalCycleCount": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Totalcyclecount",
            "description": "The total number of cycles within the current sequence, if a cycle is running."
          },
          "currentStepIndex": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Currentstepindex",
            "description": "The index of the current step within the current step, if a cycle is running."
          },
          "totalStepCount": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Totalstepcount",
            "description": "The total number of steps within the current cycle, if a cycle is running."
          }
        },
        "type": "object",
        "required": [
          "status",
          "currentTemperature",
          "targetTemperature",
          "lidStatus",
          "lidTemperatureStatus",
          "lidTemperature",
          "lidTargetTemperature",
          "holdTime",
          "rampRate",
          "currentCycleIndex",
          "totalCycleCount",
          "currentStepIndex",
          "totalStepCount"
        ],
        "title": "ThermocyclerModuleData",
        "description": "Live data from an attached Thermocycler Module."
      },
      "TipCalibrationSessionStatus": {
        "properties": {
          "instrument": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__helper_classes__AttachedPipette"
          },
          "currentStep": {
            "type": "string",
            "title": "Currentstep",
            "description": "Current step of tip calibration user flow"
          },
          "nextSteps": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NextSteps"
              },
              {
                "type": "null"
              }
            ],
            "description": "Next Available Steps in Session"
          },
          "labware": {
            "items": {
              "$ref": "#/components/schemas/RequiredLabware"
            },
            "type": "array",
            "title": "Labware"
          },
          "supportedCommands": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supportedcommands",
            "description": "A list of supported commands for this user flow"
          }
        },
        "type": "object",
        "required": [
          "instrument",
          "currentStep",
          "labware",
          "supportedCommands"
        ],
        "title": "TipCalibrationSessionStatus",
        "description": "The current status of a tip length calibration session.",
        "examples": [
          {
            "currentStep": "sessionStarted",
            "instrument": {
              "model": "p300_single_v1.5",
              "mount": "left",
              "name": "p300_single",
              "serial": "P3HS12123041",
              "tip_length": 51.7
            },
            "labware": [
              {
                "definition": {
                  "ordering": "the ordering section..."
                },
                "isTiprack": "true",
                "loadName": "tiprack_loadname",
                "namespace": "opentrons",
                "slot": "8",
                "version": "1"
              },
              {
                "definition": {
                  "ordering": "the ordering section..."
                },
                "isTiprack": "false",
                "loadName": "cal_block_loadname",
                "namespace": "opentrons",
                "slot": "3",
                "version": "1"
              }
            ],
            "nextSteps": {
              "links": {
                "loadLabware": {
                  "params": {},
                  "url": ""
                }
              }
            }
          }
        ]
      },
      "TipComparisonMap": {
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "IN_THRESHOLD",
              "OUTSIDE_THRESHOLD"
            ],
            "title": "Status",
            "description": "The status of this calibration type,dependent on the calibration beinginside or outside of the threshold"
          },
          "comparingTip": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComparisonStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "tip validation step"
          }
        },
        "type": "object",
        "required": [
          "status"
        ],
        "title": "TipComparisonMap"
      },
      "TipData": {
        "properties": {
          "value": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Value",
            "description": "The tip length of a labware"
          },
          "lastModified": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastmodified",
            "description": "When this calibration was last modified"
          }
        },
        "type": "object",
        "required": [
          "value",
          "lastModified"
        ],
        "title": "TipData",
        "description": "A model for tip length calibration data"
      },
      "TipLengthCalibration": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "tipLength": {
            "type": "number",
            "title": "Tiplength",
            "description": "The tip length value in mm"
          },
          "tiprack": {
            "type": "string",
            "title": "Tiprack",
            "description": "A hash of the labware definition of the tip rack that was used in this calibration. This is deprecated because it was prone to bugs where semantically identical definitions had different hashes. Use `uri` instead.",
            "deprecated": true
          },
          "pipette": {
            "type": "string",
            "title": "Pipette",
            "description": "The pipette ID"
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "title": "Lastmodified",
            "description": "When this calibration was last modified"
          },
          "source": {
            "$ref": "#/components/schemas/SourceType",
            "description": "The calibration source"
          },
          "status": {
            "$ref": "#/components/schemas/robot_server__service__shared_models__calibration__CalibrationStatus",
            "description": "The status of this calibration"
          },
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "The uri of the tiprack"
          }
        },
        "type": "object",
        "required": [
          "id",
          "tipLength",
          "tiprack",
          "pipette",
          "lastModified",
          "source",
          "status",
          "uri"
        ],
        "title": "TipLengthCalibration",
        "description": "A model describing tip length calibration"
      },
      "TipLengthCalibrationCreateAttributes": {
        "properties": {
          "sessionType": {
            "type": "string",
            "enum": [
              "tipLengthCalibration"
            ],
            "const": "tipLengthCalibration",
            "title": "Sessiontype",
            "default": "tipLengthCalibration"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "createParams"
        ],
        "title": "TipLengthCalibrationCreateAttributes",
        "description": "The tip length calibration create request."
      },
      "TipLengthCalibrationResponseAttributes": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the resource object."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Date and time that this session was created"
          },
          "details": {
            "$ref": "#/components/schemas/TipCalibrationSessionStatus"
          },
          "sessionType": {
            "type": "string",
            "enum": [
              "tipLengthCalibration"
            ],
            "const": "tipLengthCalibration",
            "title": "Sessiontype",
            "default": "tipLengthCalibration"
          },
          "createParams": {
            "$ref": "#/components/schemas/robot_server__robot__calibration__models__SessionCreateParams"
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "details",
          "createParams"
        ],
        "title": "TipLengthCalibrationResponseAttributes",
        "description": "Response attributes of tip length calibration session."
      },
      "TipPhysicallyAttachedError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "tipPhysicallyAttached"
            ],
            "const": "tipPhysicallyAttached",
            "title": "Errortype",
            "default": "tipPhysicallyAttached"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "3004"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Tip Drop Failed"
          },
          "errorInfo": {
            "$ref": "#/components/schemas/ErrorLocationInfo"
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorInfo",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "TipPhysicallyAttachedError",
        "description": "Returned when sensors determine that a tip remains on the pipette after a drop attempt.\n\nThe pipette will act as if the tip was not dropped. So, you won't be able to pick\nup a new tip without dropping the current one, and movement commands will assume\nthere is a tip hanging off the bottom of the pipette."
      },
      "TipPhysicallyMissingError": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this error occurrence."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the error occurred."
          },
          "isDefined": {
            "type": "boolean",
            "title": "Isdefined",
            "default": true
          },
          "errorType": {
            "type": "string",
            "enum": [
              "tipPhysicallyMissing"
            ],
            "const": "tipPhysicallyMissing",
            "title": "Errortype",
            "default": "tipPhysicallyMissing"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "3003"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "No Tip Detected"
          },
          "errorInfo": {
            "type": "object",
            "title": "Errorinfo",
            "description": "Specific structured details about the error that may be useful for\ndetermining what happened.\n\nThis might contain the same information as `detail` in a more structured form.\nIt might also contain additional information that was too verbose or technical\nto put in `detail`.\n\nIf `isDefined` is `true`, this object may have guaranteed contents, depending\non `errorType`. If `isDefined` is `false`, you should not rely on any\nparticular contents.\n",
            "default": {}
          },
          "wrappedErrors": {
            "items": {
              "$ref": "#/components/schemas/ErrorOccurrence"
            },
            "type": "array",
            "title": "Wrappederrors",
            "description": "Errors that may have caused this one.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "errorCode",
          "wrappedErrors",
          "errorInfo"
        ],
        "title": "TipPhysicallyMissingError",
        "description": "Returned when sensors determine that no tip was physically picked up.\n\nThat space in the tip rack is marked internally as not having any tip,\nas if the tip were consumed by a pickup.\n\nThe pipette will act as if no tip was picked up. So, you won't be able to aspirate\nanything, and movement commands will assume there is no tip hanging off the bottom\nof the pipette."
      },
      "TipPickUpParams": {
        "properties": {
          "prepDistance": {
            "type": "number",
            "title": "Prepdistance",
            "description": "The distance to move down to fit the tips on.",
            "default": 0
          },
          "pressDistance": {
            "type": "number",
            "title": "Pressdistance",
            "description": "The distance to press on tips.",
            "default": 0
          },
          "ejectorPushMm": {
            "type": "number",
            "title": "Ejectorpushmm",
            "description": "The distance to back off to ensure that the tip presence sensors are not triggered.",
            "default": 0
          }
        },
        "type": "object",
        "title": "TipPickUpParams",
        "description": "Payload used to specify press-tip parameters for a seal command."
      },
      "TipPresenceStatus": {
        "type": "string",
        "enum": [
          "present",
          "absent",
          "unknown"
        ],
        "title": "TipPresenceStatus",
        "description": "Tip presence status reported by a pipette."
      },
      "TipState": {
        "properties": {
          "hasTip": {
            "type": "boolean",
            "title": "Hastip"
          }
        },
        "type": "object",
        "required": [
          "hasTip"
        ],
        "title": "TipState",
        "description": "Information about the tip, if any, currently attached to a pipette."
      },
      "TouchTip": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "touchTip"
            ],
            "const": "touchTip",
            "title": "Commandtype",
            "default": "touchTip"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/TouchTipParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TouchTipResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "TouchTip",
        "description": "Touch up tip command model."
      },
      "TouchTipCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "touchTip"
            ],
            "const": "touchTip",
            "title": "Commandtype",
            "default": "touchTip"
          },
          "params": {
            "$ref": "#/components/schemas/TouchTipParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "TouchTipCreate",
        "description": "Touch tip command creation request model."
      },
      "TouchTipParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/WellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "radius": {
            "type": "number",
            "title": "Radius",
            "description": "The proportion of the target well's radius the pipette tip will move towards.",
            "default": 1
          },
          "mmFromEdge": {
            "type": "number",
            "title": "Mmfromedge",
            "description": "Offset away from the the well edge, in millimeters.Incompatible when a radius is included as a non 1.0 value."
          },
          "speed": {
            "type": "number",
            "title": "Speed",
            "description": "Override the travel speed in mm/s. This controls the straight linear speed of motion."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "pipetteId"
        ],
        "title": "TouchTipParams",
        "description": "Payload needed to touch a pipette tip the sides of a specific well."
      },
      "TouchTipProperties": {
        "properties": {
          "enable": {
            "type": "boolean",
            "title": "Enable",
            "description": "Whether touch-tip is enabled."
          },
          "params": {
            "$ref": "#/components/schemas/LiquidClassTouchTipParams",
            "title": "Params",
            "description": "Parameters for the touch-tip function."
          }
        },
        "type": "object",
        "required": [
          "enable"
        ],
        "title": "TouchTipProperties",
        "description": "Shared properties for the touch-tip function."
      },
      "TouchTipResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        },
        "type": "object",
        "title": "TouchTipResult",
        "description": "Result data from the execution of a TouchTip."
      },
      "TryLiquidProbe": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "tryLiquidProbe"
            ],
            "const": "tryLiquidProbe",
            "title": "Commandtype",
            "default": "tryLiquidProbe"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/TryLiquidProbeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TryLiquidProbeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OverpressureError"
              },
              {
                "$ref": "#/components/schemas/StallOrCollisionError"
              },
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "TryLiquidProbe",
        "description": "The model for a full `tryLiquidProbe` command."
      },
      "TryLiquidProbeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "tryLiquidProbe"
            ],
            "const": "tryLiquidProbe",
            "title": "Commandtype",
            "default": "tryLiquidProbe"
          },
          "params": {
            "$ref": "#/components/schemas/TryLiquidProbeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "TryLiquidProbeCreate",
        "description": "The request model for a `tryLiquidProbe` command."
      },
      "TryLiquidProbeParams": {
        "properties": {
          "labwareId": {
            "type": "string",
            "title": "Labwareid",
            "description": "Identifier of labware to use."
          },
          "wellName": {
            "type": "string",
            "title": "Wellname",
            "description": "Name of well to use in labware."
          },
          "wellLocation": {
            "$ref": "#/components/schemas/WellLocation",
            "description": "Relative well location at which to perform the operation"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "labwareId",
          "wellName",
          "pipetteId"
        ],
        "title": "TryLiquidProbeParams",
        "description": "Parameters required for a `tryLiquidProbe` command."
      },
      "TryLiquidProbeResult": {
        "properties": {
          "position": {
            "$ref": "#/components/schemas/DeckPoint",
            "description": "The (x,y,z) coordinates of the pipette's critical point in deck space after the move was completed.",
            "default": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          },
          "z_position": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatedProbeResult"
              },
              {
                "type": "number"
              }
            ],
            "title": "Z Position",
            "description": "The Z coordinate, in mm, of the found liquid in deck space. If no liquid was found, `null` or omitted."
          }
        },
        "type": "object",
        "required": [
          "z_position"
        ],
        "title": "TryLiquidProbeResult",
        "description": "Result data from the execution of a `tryLiquidProbe` command."
      },
      "UnexpectedFileFormat": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "UnexpectedFileFormat"
            ],
            "const": "UnexpectedFileFormat",
            "title": "Id",
            "default": "UnexpectedFileFormat"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Unexpected file format"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "UnexpectedFileFormat",
        "description": "An error returned when specified file is not in expected format."
      },
      "UnknownLabwareOffsetLocationSequenceComponent": {
        "properties": {
          "kind": {
            "type": "string",
            "enum": [
              "unknown"
            ],
            "const": "unknown",
            "title": "Kind",
            "default": "unknown"
          },
          "storedKind": {
            "type": "string",
            "title": "Storedkind"
          },
          "primaryValue": {
            "type": "string",
            "title": "Primaryvalue"
          }
        },
        "type": "object",
        "required": [
          "storedKind",
          "primaryValue"
        ],
        "title": "UnknownLabwareOffsetLocationSequenceComponent",
        "description": "A labware offset location sequence component from the future."
      },
      "UnsafeBlowOutInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/blowOutInPlace"
            ],
            "const": "unsafe/blowOutInPlace",
            "title": "Commandtype",
            "default": "unsafe/blowOutInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeBlowOutInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UnsafeBlowOutInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UnsafeBlowOutInPlace",
        "description": "UnsafeBlowOutInPlace command model."
      },
      "UnsafeBlowOutInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/blowOutInPlace"
            ],
            "const": "unsafe/blowOutInPlace",
            "title": "Commandtype",
            "default": "unsafe/blowOutInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeBlowOutInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UnsafeBlowOutInPlaceCreate",
        "description": "UnsafeBlowOutInPlace command request model."
      },
      "UnsafeBlowOutInPlaceParams": {
        "properties": {
          "flowRate": {
            "type": "number",
            "exclusiveMinimum": 0,
            "title": "Flowrate",
            "description": "Speed in L/s configured for the pipette"
          },
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          }
        },
        "type": "object",
        "required": [
          "flowRate",
          "pipetteId"
        ],
        "title": "UnsafeBlowOutInPlaceParams",
        "description": "Payload required to blow-out in place while position is unknown."
      },
      "UnsafeBlowOutInPlaceResult": {
        "properties": {},
        "type": "object",
        "title": "UnsafeBlowOutInPlaceResult",
        "description": "Result data from an UnsafeBlowOutInPlace command."
      },
      "UnsafeDropTipInPlace": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/dropTipInPlace"
            ],
            "const": "unsafe/dropTipInPlace",
            "title": "Commandtype",
            "default": "unsafe/dropTipInPlace"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeDropTipInPlaceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UnsafeDropTipInPlaceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UnsafeDropTipInPlace",
        "description": "Drop tip in place command model."
      },
      "UnsafeDropTipInPlaceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/dropTipInPlace"
            ],
            "const": "unsafe/dropTipInPlace",
            "title": "Commandtype",
            "default": "unsafe/dropTipInPlace"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeDropTipInPlaceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UnsafeDropTipInPlaceCreate",
        "description": "Drop tip in place command creation request model."
      },
      "UnsafeDropTipInPlaceParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "homeAfter": {
            "type": "boolean",
            "title": "Homeafter",
            "description": "Whether to home this pipette's plunger after dropping the tip. You should normally leave this unspecified to let the robot choose a safe default depending on its hardware."
          }
        },
        "type": "object",
        "required": [
          "pipetteId"
        ],
        "title": "UnsafeDropTipInPlaceParams",
        "description": "Payload required to drop a tip in place even if the plunger position is not known."
      },
      "UnsafeDropTipInPlaceResult": {
        "properties": {},
        "type": "object",
        "title": "UnsafeDropTipInPlaceResult",
        "description": "Result data from the execution of an UnsafeDropTipInPlace command."
      },
      "UnsafeEngageAxes": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/engageAxes"
            ],
            "const": "unsafe/engageAxes",
            "title": "Commandtype",
            "default": "unsafe/engageAxes"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeEngageAxesParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UnsafeEngageAxesResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UnsafeEngageAxes",
        "description": "UnsafeEngageAxes command model."
      },
      "UnsafeEngageAxesCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/engageAxes"
            ],
            "const": "unsafe/engageAxes",
            "title": "Commandtype",
            "default": "unsafe/engageAxes"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeEngageAxesParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UnsafeEngageAxesCreate",
        "description": "UnsafeEngageAxes command request model."
      },
      "UnsafeEngageAxesParams": {
        "properties": {
          "axes": {
            "items": {
              "$ref": "#/components/schemas/MotorAxis"
            },
            "type": "array",
            "title": "Axes",
            "description": "The axes for which to enable."
          }
        },
        "type": "object",
        "required": [
          "axes"
        ],
        "title": "UnsafeEngageAxesParams",
        "description": "Payload required for an UnsafeEngageAxes command."
      },
      "UnsafeEngageAxesResult": {
        "properties": {},
        "type": "object",
        "title": "UnsafeEngageAxesResult",
        "description": "Result data from the execution of an UnsafeEngageAxes command."
      },
      "UnsafePlaceLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/placeLabware"
            ],
            "const": "unsafe/placeLabware",
            "title": "Commandtype",
            "default": "unsafe/placeLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafePlaceLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UnsafePlaceLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UnsafePlaceLabware",
        "description": "UnsafePlaceLabware command model."
      },
      "UnsafePlaceLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/placeLabware"
            ],
            "const": "unsafe/placeLabware",
            "title": "Commandtype",
            "default": "unsafe/placeLabware"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafePlaceLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UnsafePlaceLabwareCreate",
        "description": "UnsafePlaceLabware command request model."
      },
      "UnsafePlaceLabwareParams": {
        "properties": {
          "labwareURI": {
            "type": "string",
            "title": "Labwareuri",
            "description": "Labware URI for labware."
          },
          "location": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DeckSlotLocation"
              },
              {
                "$ref": "#/components/schemas/ModuleLocation"
              },
              {
                "$ref": "#/components/schemas/OnLabwareLocation"
              },
              {
                "$ref": "#/components/schemas/AddressableAreaLocation"
              }
            ],
            "title": "Location",
            "description": "Where to place the labware."
          }
        },
        "type": "object",
        "required": [
          "labwareURI",
          "location"
        ],
        "title": "UnsafePlaceLabwareParams",
        "description": "Payload required for an UnsafePlaceLabware command."
      },
      "UnsafePlaceLabwareResult": {
        "properties": {},
        "type": "object",
        "title": "UnsafePlaceLabwareResult",
        "description": "Result data from the execution of an UnsafePlaceLabware command."
      },
      "UnsafeUngripLabware": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/ungripLabware"
            ],
            "const": "unsafe/ungripLabware",
            "title": "Commandtype",
            "default": "unsafe/ungripLabware"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeUngripLabwareParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UnsafeUngripLabwareResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UnsafeUngripLabware",
        "description": "UnsafeUngripLabware command model."
      },
      "UnsafeUngripLabwareCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/ungripLabware"
            ],
            "const": "unsafe/ungripLabware",
            "title": "Commandtype",
            "default": "unsafe/ungripLabware"
          },
          "params": {
            "$ref": "#/components/schemas/UnsafeUngripLabwareParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UnsafeUngripLabwareCreate",
        "description": "UnsafeEngageAxes command request model."
      },
      "UnsafeUngripLabwareParams": {
        "properties": {},
        "type": "object",
        "title": "UnsafeUngripLabwareParams",
        "description": "Payload required for an UngripLabware command."
      },
      "UnsafeUngripLabwareResult": {
        "properties": {},
        "type": "object",
        "title": "UnsafeUngripLabwareResult",
        "description": "Result data from the execution of an UngripLabware command."
      },
      "UpdatePositionEstimators": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/updatePositionEstimators"
            ],
            "const": "unsafe/updatePositionEstimators",
            "title": "Commandtype",
            "default": "unsafe/updatePositionEstimators"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/UpdatePositionEstimatorsParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdatePositionEstimatorsResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "UpdatePositionEstimators",
        "description": "UpdatePositionEstimators command model."
      },
      "UpdatePositionEstimatorsCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "unsafe/updatePositionEstimators"
            ],
            "const": "unsafe/updatePositionEstimators",
            "title": "Commandtype",
            "default": "unsafe/updatePositionEstimators"
          },
          "params": {
            "$ref": "#/components/schemas/UpdatePositionEstimatorsParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "UpdatePositionEstimatorsCreate",
        "description": "UpdatePositionEstimators command request model."
      },
      "UpdatePositionEstimatorsParams": {
        "properties": {
          "axes": {
            "items": {
              "$ref": "#/components/schemas/MotorAxis"
            },
            "type": "array",
            "title": "Axes",
            "description": "The axes for which to update the position estimators. Any axes that are not physically present will be ignored."
          }
        },
        "type": "object",
        "required": [
          "axes"
        ],
        "title": "UpdatePositionEstimatorsParams",
        "description": "Payload required for an UpdatePositionEstimators command."
      },
      "UpdatePositionEstimatorsResult": {
        "properties": {},
        "type": "object",
        "title": "UpdatePositionEstimatorsResult",
        "description": "Result data from the execution of an UpdatePositionEstimators command."
      },
      "UpdateProgressData": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique ID for the update process."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the update was posted."
          },
          "subsystem": {
            "$ref": "#/components/schemas/SubSystem",
            "description": "The subsystem that is being updated."
          },
          "updateStatus": {
            "$ref": "#/components/schemas/UpdateState",
            "description": "Whether an update is queued, in progress or completed. "
          },
          "updateProgress": {
            "type": "integer",
            "title": "Updateprogress",
            "description": "Progress of the update depicted as an integer from 0 to 100."
          },
          "updateError": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updateerror",
            "description": "If the process failed, this will contain a string description of the reason."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "subsystem",
          "updateStatus",
          "updateProgress",
          "updateError"
        ],
        "title": "UpdateProgressData",
        "description": "Model for status of firmware update progress."
      },
      "UpdateProgressSummary": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique ID for the update process."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "When the update was posted."
          },
          "subsystem": {
            "$ref": "#/components/schemas/SubSystem",
            "description": "The subsystem that is being updated."
          },
          "updateStatus": {
            "$ref": "#/components/schemas/UpdateState",
            "description": "Whether an update is queued, in progress or completed"
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "subsystem",
          "updateStatus"
        ],
        "title": "UpdateProgressSummary",
        "description": "Model for a quick summary of an update's progress."
      },
      "UpdateState": {
        "type": "string",
        "enum": [
          "queued",
          "updating",
          "done",
          "failed"
        ],
        "title": "UpdateState",
        "description": "The high-level state of an ongoing update."
      },
      "UsbPort": {
        "properties": {
          "port": {
            "type": "integer",
            "title": "Port",
            "description": "The USB port the module is plugged into. If connected via a hub, ``port`` represents the port the hub is plugged into."
          },
          "portGroup": {
            "type": "string",
            "title": "Portgroup",
            "description": "The physical USB port bank the module is plugged into."
          },
          "hub": {
            "type": "boolean",
            "title": "Hub",
            "description": "If the module is connected via a USB hub."
          },
          "hubPort": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hubport",
            "description": "If the module is connected via a USB hub, the port on the hub the module is plugged into."
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "The virtual path of the USB port in the system."
          }
        },
        "type": "object",
        "required": [
          "port",
          "portGroup",
          "hub",
          "hubPort",
          "path"
        ],
        "title": "UsbPort",
        "description": "The USB port the module is connected to."
      },
      "V1BasicResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A human-readable message"
          }
        },
        "type": "object",
        "required": [
          "message"
        ],
        "title": "V1BasicResponse",
        "description": "A response with a human readable message"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "Vec3f": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X"
          },
          "y": {
            "type": "number",
            "title": "Y"
          },
          "z": {
            "type": "number",
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "Vec3f",
        "description": "A 3D vector of floats."
      },
      "Vector": {
        "properties": {
          "x": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "X"
          },
          "y": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Y"
          },
          "z": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Z"
          }
        },
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "title": "Vector"
      },
      "VerifyTipPresence": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "verifyTipPresence"
            ],
            "const": "verifyTipPresence",
            "title": "Commandtype",
            "default": "verifyTipPresence"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/VerifyTipPresenceParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VerifyTipPresenceResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "VerifyTipPresence",
        "description": "VerifyTipPresence command model."
      },
      "VerifyTipPresenceCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "verifyTipPresence"
            ],
            "const": "verifyTipPresence",
            "title": "Commandtype",
            "default": "verifyTipPresence"
          },
          "params": {
            "$ref": "#/components/schemas/VerifyTipPresenceParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "VerifyTipPresenceCreate",
        "description": "VerifyTipPresence command creation request model."
      },
      "VerifyTipPresenceParams": {
        "properties": {
          "pipetteId": {
            "type": "string",
            "title": "Pipetteid",
            "description": "Identifier of pipette to use for liquid handling."
          },
          "expectedState": {
            "$ref": "#/components/schemas/TipPresenceStatus",
            "description": "The expected tip presence status on the pipette."
          },
          "followSingularSensor": {
            "$ref": "#/components/schemas/InstrumentSensorId",
            "title": "Followsingularsensor",
            "description": "The sensor id to follow if the other can be ignored."
          }
        },
        "type": "object",
        "required": [
          "pipetteId",
          "expectedState"
        ],
        "title": "VerifyTipPresenceParams",
        "description": "Payload required for a VerifyTipPresence command."
      },
      "VerifyTipPresenceResult": {
        "properties": {},
        "type": "object",
        "title": "VerifyTipPresenceResult",
        "description": "Result data from the execution of a VerifyTipPresence command."
      },
      "WaitForBlockTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/waitForBlockTemperature"
            ],
            "const": "thermocycler/waitForBlockTemperature",
            "title": "Commandtype",
            "default": "thermocycler/waitForBlockTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForBlockTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WaitForBlockTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForBlockTemperature",
        "description": "A command to wait for a Thermocycler's target block temperature."
      },
      "WaitForBlockTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/waitForBlockTemperature"
            ],
            "const": "thermocycler/waitForBlockTemperature",
            "title": "Commandtype",
            "default": "thermocycler/waitForBlockTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForBlockTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForBlockTemperatureCreate",
        "description": "A request to create Thermocycler's wait for block temperature command."
      },
      "WaitForBlockTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "WaitForBlockTemperatureParams",
        "description": "Input parameters to wait for Thermocycler's target block temperature."
      },
      "WaitForBlockTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForBlockTemperatureResult",
        "description": "Result data from wait for Thermocycler's target block temperature."
      },
      "WaitForDuration": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "waitForDuration"
            ],
            "const": "waitForDuration",
            "title": "Commandtype",
            "default": "waitForDuration"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForDurationParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WaitForDurationResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForDuration",
        "description": "Wait for duration command model."
      },
      "WaitForDurationCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "waitForDuration"
            ],
            "const": "waitForDuration",
            "title": "Commandtype",
            "default": "waitForDuration"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForDurationParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForDurationCreate",
        "description": "Wait for duration command request model."
      },
      "WaitForDurationParams": {
        "properties": {
          "seconds": {
            "type": "number",
            "title": "Seconds",
            "description": "Duration, in seconds, to wait for."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A user-facing message associated with the pause"
          }
        },
        "type": "object",
        "required": [
          "seconds"
        ],
        "title": "WaitForDurationParams",
        "description": "Payload required to pause the protocol."
      },
      "WaitForDurationResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForDurationResult",
        "description": "Result data from the execution of a wait for duration command."
      },
      "WaitForLidTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/waitForLidTemperature"
            ],
            "const": "thermocycler/waitForLidTemperature",
            "title": "Commandtype",
            "default": "thermocycler/waitForLidTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForLidTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WaitForLidTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForLidTemperature",
        "description": "A command to wait for a Thermocycler's lid temperature."
      },
      "WaitForLidTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/waitForLidTemperature"
            ],
            "const": "thermocycler/waitForLidTemperature",
            "title": "Commandtype",
            "default": "thermocycler/waitForLidTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForLidTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForLidTemperatureCreate",
        "description": "A request to create Thermocycler's wait for lid temperature command."
      },
      "WaitForLidTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler Module."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "WaitForLidTemperatureParams",
        "description": "Input parameters to wait for Thermocycler's lid temperature."
      },
      "WaitForLidTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForLidTemperatureResult",
        "description": "Result data from wait for Thermocycler's lid temperature."
      },
      "WaitForResume": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "waitForResume",
              "pause"
            ],
            "title": "Commandtype",
            "default": "waitForResume"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForResumeParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WaitForResumeResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForResume",
        "description": "Wait for resume command model."
      },
      "WaitForResumeCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "waitForResume",
              "pause"
            ],
            "title": "Commandtype",
            "default": "waitForResume"
          },
          "params": {
            "$ref": "#/components/schemas/WaitForResumeParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForResumeCreate",
        "description": "Wait for resume command request model."
      },
      "WaitForResumeParams": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A user-facing message associated with the pause"
          }
        },
        "type": "object",
        "title": "WaitForResumeParams",
        "description": "Payload required to pause the protocol."
      },
      "WaitForResumeResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForResumeResult",
        "description": "Result data from the execution of a WaitForResume command."
      },
      "WellLocation": {
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/WellOrigin",
            "default": "top"
          },
          "offset": {
            "$ref": "#/components/schemas/WellOffset"
          },
          "volumeOffset": {
            "type": "number",
            "title": "Volumeoffset",
            "description": "A volume of liquid, in L, to offset the z-axis offset.",
            "default": 0
          }
        },
        "type": "object",
        "title": "WellLocation",
        "description": "A relative location in reference to a well's location."
      },
      "WellOffset": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X",
            "default": 0
          },
          "y": {
            "type": "number",
            "title": "Y",
            "default": 0
          },
          "z": {
            "type": "number",
            "title": "Z",
            "default": 0
          }
        },
        "type": "object",
        "title": "WellOffset",
        "description": "An offset vector in (x, y, z)."
      },
      "WellOrigin": {
        "type": "string",
        "enum": [
          "top",
          "bottom",
          "center",
          "meniscus"
        ],
        "title": "WellOrigin",
        "description": "Origin of WellLocation offset.\n\nProps:\n    TOP: the top-center of the well\n    BOTTOM: the bottom-center of the well\n    CENTER: the middle-center of the well\n    MENISCUS: the meniscus-center of the well"
      },
      "WifiConfiguration": {
        "properties": {
          "ssid": {
            "type": "string",
            "title": "Ssid",
            "description": "The SSID to connect to. If this isn't an SSID that is being broadcast by a network, you should also set `hidden` to `true`."
          },
          "hidden": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hidden",
            "description": "`true` if the network is hidden (not broadcasting an SSID). `false` (default if key is not present) otherwise.",
            "default": false
          },
          "securityType": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NetworkingSecurityType"
              },
              {
                "type": "null"
              }
            ]
          },
          "psk": {
            "anyOf": [
              {
                "type": "string",
                "format": "password",
                "writeOnly": true
              },
              {
                "type": "null"
              }
            ],
            "title": "Psk",
            "description": "If this is a PSK-secured network (`securityType` is `\"wpa-psk\"`), the PSK"
          },
          "eapConfig": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "required": [
              "eapType"
            ],
            "title": "Eapconfig",
            "description": "All options required to configure EAP access to the Wi-Fi. All options should match one of the cases described in `/wifi/eap-options`; for instance, configuring for peap/mschapv2 should have `\"peap/mschapv2\"` as the `eapType`; it should have `\"identity\"` and `\"password\"` props, both of which are identified as mandatory in `/wifi/eap-options`; and it may also have `\"anonymousIdentity\"` and `\"caCert\"` properties, both of which are identified as present but not required."
          }
        },
        "type": "object",
        "required": [
          "ssid"
        ],
        "title": "WifiConfiguration",
        "examples": [
          {
            "ssid": "linksys"
          },
          {
            "psk": "psksrock",
            "securityType": "wpa-psk",
            "ssid": "linksys"
          },
          {
            "hidden": true,
            "psk": "letmein",
            "securityType": "wpa-psk",
            "ssid": "cantseeme"
          },
          {
            "eapConfig": {
              "eapType": "peap/mschapv2",
              "identity": "scientist@biology.org",
              "password": "leeuwenhoek"
            },
            "securityType": "wpa-eap",
            "ssid": "Eduroam"
          }
        ]
      },
      "WifiConfigurationResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A human-readable success message"
          },
          "ssid": {
            "type": "string",
            "title": "Ssid",
            "description": "The SSID configured"
          }
        },
        "type": "object",
        "required": [
          "message",
          "ssid"
        ],
        "title": "WifiConfigurationResponse",
        "description": "The OT-2 successfully connected to the specified network using the\nspecified parameters"
      },
      "WifiKeyFile": {
        "properties": {
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "A URI for the key (mostly for use with DELETE /wifi/keys/{key_id})"
          },
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A contents hash of the key used to specify the key in POST /wifi/configure (and also to determine the key URI)"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The original filename of the key"
          }
        },
        "type": "object",
        "required": [
          "uri",
          "id",
          "name"
        ],
        "title": "WifiKeyFile",
        "description": "Wifi Key File"
      },
      "WifiKeyFiles": {
        "properties": {
          "keys": {
            "items": {
              "$ref": "#/components/schemas/WifiKeyFile"
            },
            "type": "array",
            "title": "Keys",
            "description": "A list of keys in the system",
            "default": []
          }
        },
        "type": "object",
        "title": "WifiKeyFiles",
        "description": "The list of key files",
        "example": {
          "keys": [
            {
              "id": "abda234a234",
              "name": "client.pem",
              "uri": "/wifi/keys/abda234a234"
            }
          ]
        }
      },
      "WifiNetwork": {
        "properties": {
          "ssid": {
            "type": "string",
            "title": "Ssid",
            "description": "The network's SSID"
          }
        },
        "type": "object",
        "required": [
          "ssid"
        ],
        "title": "WifiNetwork",
        "description": "Identifier of a wifi network"
      },
      "WifiNetworkFull": {
        "properties": {
          "ssid": {
            "type": "string",
            "title": "Ssid",
            "description": "The network's SSID"
          },
          "signal": {
            "type": "integer",
            "title": "Signal",
            "description": "A unitless signal strength; a higher number is a better signal"
          },
          "active": {
            "type": "boolean",
            "title": "Active",
            "description": "Whether there is a connection active"
          },
          "security": {
            "type": "string",
            "title": "Security",
            "description": "The raw NetworkManager output about the Wi-Fi security"
          },
          "securityType": {
            "$ref": "#/components/schemas/NetworkingSecurityType"
          }
        },
        "type": "object",
        "required": [
          "ssid",
          "signal",
          "active",
          "security",
          "securityType"
        ],
        "title": "WifiNetworkFull",
        "description": "A visible Network"
      },
      "WifiNetworks": {
        "properties": {
          "list": {
            "items": {
              "$ref": "#/components/schemas/WifiNetworkFull"
            },
            "type": "array",
            "title": "List"
          }
        },
        "type": "object",
        "required": [
          "list"
        ],
        "title": "WifiNetworks",
        "description": "The list of networks",
        "example": {
          "list": [
            {
              "active": false,
              "security": "WPA2 802.1X",
              "securityType": "wpa-eap",
              "signal": 50,
              "ssid": "linksys"
            }
          ]
        }
      },
      "closeGripperJaw": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "robot/closeGripperJaw"
            ],
            "const": "robot/closeGripperJaw",
            "title": "Commandtype",
            "default": "robot/closeGripperJaw"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/closeGripperJawParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/closeGripperJawResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "closeGripperJaw",
        "description": "closeGripperJaw command model."
      },
      "closeGripperJawCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "robot/closeGripperJaw"
            ],
            "const": "robot/closeGripperJaw",
            "title": "Commandtype",
            "default": "robot/closeGripperJaw"
          },
          "params": {
            "$ref": "#/components/schemas/closeGripperJawParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "closeGripperJawCreate",
        "description": "closeGripperJaw command request model."
      },
      "closeGripperJawParams": {
        "properties": {
          "force": {
            "type": "number",
            "title": "Force",
            "description": "The force the gripper should use to hold the jaws, falls to default if none is provided."
          }
        },
        "type": "object",
        "title": "closeGripperJawParams",
        "description": "Payload required to close a gripper."
      },
      "closeGripperJawResult": {
        "properties": {},
        "type": "object",
        "title": "closeGripperJawResult",
        "description": "Result data from the execution of a closeGripperJaw command."
      },
      "openGripperJaw": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "robot/openGripperJaw"
            ],
            "const": "robot/openGripperJaw",
            "title": "Commandtype",
            "default": "robot/openGripperJaw"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/openGripperJawParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/openGripperJawResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "openGripperJaw",
        "description": "openGripperJaw command model."
      },
      "openGripperJawCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "robot/openGripperJaw"
            ],
            "const": "robot/openGripperJaw",
            "title": "Commandtype",
            "default": "robot/openGripperJaw"
          },
          "params": {
            "$ref": "#/components/schemas/openGripperJawParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "openGripperJawCreate",
        "description": "openGripperJaw command request model."
      },
      "openGripperJawParams": {
        "properties": {},
        "type": "object",
        "title": "openGripperJawParams",
        "description": "Payload required to release a gripper."
      },
      "openGripperJawResult": {
        "properties": {},
        "type": "object",
        "title": "openGripperJawResult",
        "description": "Result data from the execution of a openGripperJaw command."
      },
      "opentrons__calibration_storage__types__CalibrationStatus": {
        "properties": {
          "markedBad": {
            "type": "boolean",
            "title": "Markedbad",
            "default": false
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SourceType"
              },
              {
                "type": "null"
              }
            ]
          },
          "markedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Markedat"
          }
        },
        "type": "object",
        "title": "CalibrationStatus"
      },
      "opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/closeLid"
            ],
            "const": "absorbanceReader/closeLid",
            "title": "Commandtype",
            "default": "absorbanceReader/closeLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CloseLid",
        "description": "A command to close the lid on an Absorbance Reader."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/closeLid"
            ],
            "const": "absorbanceReader/closeLid",
            "title": "Commandtype",
            "default": "absorbanceReader/closeLid"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CloseLidCreate",
        "description": "A request to execute an Absorbance Reader close lid command."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the absorbance reader."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "CloseLidParams",
        "description": "Input parameters to close the lid on an absorbance reading."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__close_lid__CloseLidResult": {
        "properties": {},
        "type": "object",
        "title": "CloseLidResult",
        "description": "Result data from closing the lid on an aborbance reading."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/openLid"
            ],
            "const": "absorbanceReader/openLid",
            "title": "Commandtype",
            "default": "absorbanceReader/openLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "OpenLid",
        "description": "A command to open the lid on an Absorbance Reader."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "absorbanceReader/openLid"
            ],
            "const": "absorbanceReader/openLid",
            "title": "Commandtype",
            "default": "absorbanceReader/openLid"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "OpenLidCreate",
        "description": "A request to execute an Absorbance Reader open lid command."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the absorbance reader."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "OpenLidParams",
        "description": "Input parameters to open the lid on an absorbance reading."
      },
      "opentrons__protocol_engine__commands__absorbance_reader__open_lid__OpenLidResult": {
        "properties": {},
        "type": "object",
        "title": "OpenLidResult",
        "description": "Result data from opening the lid on an aborbance reading."
      },
      "opentrons__protocol_engine__commands__command__CommandStatus": {
        "type": "string",
        "enum": [
          "queued",
          "running",
          "succeeded",
          "failed"
        ],
        "title": "CommandStatus",
        "description": "Command execution status."
      },
      "opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/setTargetTemperature"
            ],
            "const": "heaterShaker/setTargetTemperature",
            "title": "Commandtype",
            "default": "heaterShaker/setTargetTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetTargetTemperature",
        "description": "A command to set a Heater-Shaker's target temperature."
      },
      "opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/setTargetTemperature"
            ],
            "const": "heaterShaker/setTargetTemperature",
            "title": "Commandtype",
            "default": "heaterShaker/setTargetTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetTargetTemperatureCreate",
        "description": "A request to create a Heater-Shaker's set temperature command."
      },
      "opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "celsius"
        ],
        "title": "SetTargetTemperatureParams",
        "description": "Input parameters to set a Heater-Shaker's target temperature."
      },
      "opentrons__protocol_engine__commands__heater_shaker__set_target_temperature__SetTargetTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "SetTargetTemperatureResult",
        "description": "Result data from setting a Heater-Shaker's target temperature."
      },
      "opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/waitForTemperature"
            ],
            "const": "heaterShaker/waitForTemperature",
            "title": "Commandtype",
            "default": "heaterShaker/waitForTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForTemperature",
        "description": "A command to wait for a Heater-Shaker's target temperature to be reached."
      },
      "opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "heaterShaker/waitForTemperature"
            ],
            "const": "heaterShaker/waitForTemperature",
            "title": "Commandtype",
            "default": "heaterShaker/waitForTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForTemperatureCreate",
        "description": "A request to create a Heater-Shaker's wait for temperature command."
      },
      "opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Heater-Shaker Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C. If not specified, will default to the module's target temperature. Specifying a celsius parameter other than the target temperature could lead to unpredictable behavior and hence is not recommended for use. This parameter can be removed in a future version without prior notice."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "WaitForTemperatureParams",
        "description": "Input parameters to wait for a Heater-Shaker's target temperature."
      },
      "opentrons__protocol_engine__commands__heater_shaker__wait_for_temperature__WaitForTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForTemperatureResult",
        "description": "Result data from waiting for a Heater-Shaker's target temperature."
      },
      "opentrons__protocol_engine__commands__move_labware__ErrorDetails": {
        "properties": {
          "originLocationSequence": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/InStackerHopperLocation"
                }
              ]
            },
            "type": "array",
            "title": "Originlocationsequence"
          },
          "immediateDestinationLocationSequence": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/InStackerHopperLocation"
                }
              ]
            },
            "type": "array",
            "title": "Immediatedestinationlocationsequence"
          },
          "eventualDestinationLocationSequence": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/OnLabwareLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnModuleLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnAddressableAreaLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/NotOnDeckLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/OnCutoutFixtureLocationSequenceComponent"
                },
                {
                  "$ref": "#/components/schemas/InStackerHopperLocation"
                }
              ]
            },
            "type": "array",
            "title": "Eventualdestinationlocationsequence"
          }
        },
        "type": "object",
        "required": [
          "originLocationSequence",
          "immediateDestinationLocationSequence",
          "eventualDestinationLocationSequence"
        ],
        "title": "ErrorDetails",
        "description": "Location details for a failed gripper move."
      },
      "opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/setTargetTemperature"
            ],
            "const": "temperatureModule/setTargetTemperature",
            "title": "Commandtype",
            "default": "temperatureModule/setTargetTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "SetTargetTemperature",
        "description": "A command to set a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/setTargetTemperature"
            ],
            "const": "temperatureModule/setTargetTemperature",
            "title": "Commandtype",
            "default": "temperatureModule/setTargetTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "SetTargetTemperatureCreate",
        "description": "A request to create a Temperature Module's set temperature command."
      },
      "opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Temperature Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C."
          }
        },
        "type": "object",
        "required": [
          "moduleId",
          "celsius"
        ],
        "title": "SetTargetTemperatureParams",
        "description": "Input parameters to set a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__temperature_module__set_target_temperature__SetTargetTemperatureResult": {
        "properties": {
          "targetTemperature": {
            "type": "number",
            "title": "Targettemperature",
            "description": "The target temperature that was set after validation and type conversion (if any)."
          }
        },
        "type": "object",
        "required": [
          "targetTemperature"
        ],
        "title": "SetTargetTemperatureResult",
        "description": "Result data from setting a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperature": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/waitForTemperature"
            ],
            "const": "temperatureModule/waitForTemperature",
            "title": "Commandtype",
            "default": "temperatureModule/waitForTemperature"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "WaitForTemperature",
        "description": "A command to wait for a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "temperatureModule/waitForTemperature"
            ],
            "const": "temperatureModule/waitForTemperature",
            "title": "Commandtype",
            "default": "temperatureModule/waitForTemperature"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "WaitForTemperatureCreate",
        "description": "A request to create a Temperature Module's wait for temperature command."
      },
      "opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Temperature Module."
          },
          "celsius": {
            "type": "number",
            "title": "Celsius",
            "description": "Target temperature in C. If not specified, will default to the module's target temperature. Specifying a celsius parameter other than the target temperature could lead to unpredictable behavior and hence is not recommended for use. This parameter can be removed in a future version without prior notice."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "WaitForTemperatureParams",
        "description": "Input parameters to wait for a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__temperature_module__wait_for_temperature__WaitForTemperatureResult": {
        "properties": {},
        "type": "object",
        "title": "WaitForTemperatureResult",
        "description": "Result data from waiting for a Temperature Module's target temperature."
      },
      "opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/closeLid"
            ],
            "const": "thermocycler/closeLid",
            "title": "Commandtype",
            "default": "thermocycler/closeLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "CloseLid",
        "description": "A command to close a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/closeLid"
            ],
            "const": "thermocycler/closeLid",
            "title": "Commandtype",
            "default": "thermocycler/closeLid"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "CloseLidCreate",
        "description": "A request to close a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "CloseLidParams",
        "description": "Input parameters to close a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__close_lid__CloseLidResult": {
        "properties": {},
        "type": "object",
        "title": "CloseLidResult",
        "description": "Result data from closing a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLid": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier of this particular command instance"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Command creation timestamp"
          },
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/openLid"
            ],
            "const": "thermocycler/openLid",
            "title": "Commandtype",
            "default": "thermocycler/openLid"
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "An identifier representing this command as a step in a protocol. A command's `key` will be unique within a given run, but stable across all runs that perform the same exact procedure. Thus, `key` be used to compare/match commands across multiple runs of the same protocol."
          },
          "status": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__command__CommandStatus",
            "description": "Command execution status"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidParams"
          },
          "result": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidResult"
              },
              {
                "type": "null"
              }
            ]
          },
          "error": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorOccurrence"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to error occurrence, if execution failed"
          },
          "startedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Startedat",
            "description": "Command execution start timestamp, if started"
          },
          "completedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completedat",
            "description": "Command execution completed timestamp, if completed"
          },
          "intent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CommandIntent"
              },
              {
                "type": "null"
              }
            ],
            "description": "The reason the command was added to the run. If not specified or `protocol`, it is part of the protocol itself. If `setup`, it was added as part of setup; for example, a command that is part of a calibration procedure."
          },
          "notes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CommandNote"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Notes",
            "description": "Information not critical to the execution of the command derived from either the command's execution or the command's generation."
          },
          "failedCommandId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failedcommandid",
            "description": "FIXIT command use only. Reference of the failed command id we are trying to fix."
          }
        },
        "type": "object",
        "required": [
          "id",
          "createdAt",
          "key",
          "status",
          "params"
        ],
        "title": "OpenLid",
        "description": "A command to open a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidCreate": {
        "properties": {
          "commandType": {
            "type": "string",
            "enum": [
              "thermocycler/openLid"
            ],
            "const": "thermocycler/openLid",
            "title": "Commandtype",
            "default": "thermocycler/openLid"
          },
          "params": {
            "$ref": "#/components/schemas/opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidParams"
          },
          "intent": {
            "$ref": "#/components/schemas/CommandIntent",
            "title": "Intent",
            "description": "The reason the command was added. If not specified or `protocol`, the command will be treated as part of the protocol run itself, and added to the end of the existing command queue.\n\nIf `setup`, the command will be treated as part of run setup. A setup command may only be enqueued if the run has not started.\n\nUse setup commands for activities like pre-run calibration checks and module setup, like pre-heating."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "A key value, unique in this run, that can be used to track the same logical command across multiple runs of the same protocol. If a value is not provided, one will be generated."
          }
        },
        "type": "object",
        "required": [
          "params"
        ],
        "title": "OpenLidCreate",
        "description": "A request to open a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidParams": {
        "properties": {
          "moduleId": {
            "type": "string",
            "title": "Moduleid",
            "description": "Unique ID of the Thermocycler."
          }
        },
        "type": "object",
        "required": [
          "moduleId"
        ],
        "title": "OpenLidParams",
        "description": "Input parameters to open a Thermocycler's lid."
      },
      "opentrons__protocol_engine__commands__thermocycler__open_lid__OpenLidResult": {
        "properties": {},
        "type": "object",
        "title": "OpenLidResult",
        "description": "Result data from opening a Thermocycler's lid."
      },
      "opentrons__types__MountType": {
        "type": "string",
        "enum": [
          "left",
          "right",
          "extension"
        ],
        "title": "MountType"
      },
      "opentrons_shared_data__labware__labware_definition__Metadata": {
        "properties": {
          "displayName": {
            "type": "string",
            "title": "Displayname"
          },
          "displayCategory": {
            "$ref": "#/components/schemas/DisplayCategory"
          },
          "displayVolumeUnits": {
            "type": "string",
            "enum": [
              "L",
              "mL",
              "L"
            ],
            "title": "Displayvolumeunits"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags"
          }
        },
        "type": "object",
        "required": [
          "displayName",
          "displayCategory",
          "displayVolumeUnits"
        ],
        "title": "Metadata"
      },
      "robot_server__commands__router__CommandNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "StatelessCommandNotFound"
            ],
            "const": "StatelessCommandNotFound",
            "title": "Id",
            "default": "StatelessCommandNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Stateless Command Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "CommandNotFound",
        "description": "An error returned if the given command cannot be found."
      },
      "robot_server__errors__error_responses__ErrorBody_CommandNotAllowed___1": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__runs__router__commands_router__CommandNotAllowed"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[CommandNotAllowed]"
      },
      "robot_server__errors__error_responses__ErrorBody_CommandNotAllowed___2": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__maintenance_runs__router__commands_router__CommandNotAllowed"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[CommandNotAllowed]"
      },
      "robot_server__errors__error_responses__ErrorBody_CommandNotFound___1": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__runs__router__commands_router__CommandNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[CommandNotFound]"
      },
      "robot_server__errors__error_responses__ErrorBody_CommandNotFound___2": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__maintenance_runs__router__commands_router__CommandNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[CommandNotFound]"
      },
      "robot_server__errors__error_responses__ErrorBody_CommandNotFound___3": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__commands__router__CommandNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[CommandNotFound]"
      },
      "robot_server__errors__error_responses__ErrorBody_RunNotFound___1": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__runs__router__base_router__RunNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunNotFound]"
      },
      "robot_server__errors__error_responses__ErrorBody_RunNotFound___2": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/robot_server__maintenance_runs__router__base_router__RunNotFound"
            },
            "type": "array",
            "title": "Errors",
            "description": "Error details."
          },
          "links": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResourceLink"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Links",
            "description": "Links that leads to further details about this particular occurrence of the problem."
          }
        },
        "type": "object",
        "required": [
          "errors"
        ],
        "title": "ErrorBody[RunNotFound]"
      },
      "robot_server__errors__error_responses__ErrorDetails": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "A unique identifier for this type of error."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "A short, human readable name for this type of error"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "id",
          "title",
          "detail"
        ],
        "title": "ErrorDetails",
        "description": "An error response with error type and occurrence details.\n\nExtend this class to create specific error responses, and use it in your\nroute handlers.\n\nExample:\n    from fastapi import status\n    from typing_extensions import Literal\n    from robot_server.errors.error_responses import ErrorResponse, ErrorDetails\n\n    class BadRequest(ErrorDetails):\n        id: Literal[\"BadRequest\"] = \"BadRequest\"\n        title: str = \"Bad Request\"\n\n    # ...\n\n    @router.get(\n        path=\"/some/path\",\n        response_model=SomeModel,\n        responses={\n            status.HTTP_400_BAD_REQUEST: {\"model\": ErrorResponse[BadRequest]},\n        }\n    )\n    def get_some_model():\n        # ...\n        raise BadRequest.as_error(status.HTTP_400_BAD_REQUEST)"
      },
      "robot_server__maintenance_runs__router__base_router__RunNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunNotFound"
            ],
            "const": "RunNotFound",
            "title": "Id",
            "default": "RunNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunNotFound",
        "description": "An error if a given run is not found."
      },
      "robot_server__maintenance_runs__router__base_router__RunNotIdle": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunNotIdle"
            ],
            "const": "RunNotIdle",
            "title": "Id",
            "default": "RunNotIdle"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run is not idle."
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Run is currently active. Allow the run to finish or stop it with a `stop` action before attempting to modify it."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "title": "RunNotIdle",
        "description": "An error if one tries to delete a run that is not idle."
      },
      "robot_server__maintenance_runs__router__commands_router__CommandNotAllowed": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "CommandNotAllowed"
            ],
            "const": "CommandNotAllowed",
            "title": "Id",
            "default": "CommandNotAllowed"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Setup Command Not Allowed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "CommandNotAllowed",
        "description": "An error if a given run command is not allowed."
      },
      "robot_server__maintenance_runs__router__commands_router__CommandNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "CommandNotFound"
            ],
            "const": "CommandNotFound",
            "title": "Id",
            "default": "CommandNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Command Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "CommandNotFound",
        "description": "An error if a given run command is not found."
      },
      "robot_server__protocols__protocol_models__Metadata": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "Metadata",
        "description": "Extra, nonessential information about the protocol.\n\nThis can include data like:\n\n* A human-readable title and description.\n* A last-modified date.\n* A list of authors.\n\nMetadata may contain fields other than those explicitly\nlisted in this schema.\n\nThe metadata *should not* include information needed\nto run the protocol correctly. For historical reasons, Python\nprotocols define their `apiLevel` inside their metadata, but\nthis should be considered an exception to the rule."
      },
      "robot_server__robot__calibration__check__models__SessionCreateParams": {
        "properties": {
          "hasCalibrationBlock": {
            "type": "boolean",
            "title": "Hascalibrationblock",
            "description": "Whether to use a calibration block in thecalibration health check flow.",
            "default": false
          },
          "tipRacks": {
            "items": {
              "type": "object"
            },
            "type": "array",
            "title": "Tipracks",
            "description": "A list of labware definitions to use incalibration health check",
            "default": []
          }
        },
        "type": "object",
        "title": "SessionCreateParams",
        "description": "Calibration Health Check create params"
      },
      "robot_server__robot__calibration__helper_classes__AttachedPipette": {
        "properties": {
          "model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model",
            "description": "The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Short name of pipette model withoutgeneration version"
          },
          "tipLength": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiplength",
            "description": "The default tip length for this pipette"
          },
          "mount": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mount",
            "description": "The mount this pipette attached to"
          },
          "serial": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Serial",
            "description": "The serial number of the attached pipette"
          },
          "defaultTipracks": {
            "anyOf": [
              {
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Defaulttipracks",
            "description": "A list of default tipracks for this pipette"
          }
        },
        "type": "object",
        "title": "AttachedPipette",
        "description": "Pipette (if any) attached to the mount"
      },
      "robot_server__robot__calibration__models__SessionCreateParams": {
        "properties": {
          "mount": {
            "type": "string",
            "title": "Mount",
            "description": "The mount on which the pipette is attached, left or right"
          },
          "hasCalibrationBlock": {
            "type": "boolean",
            "title": "Hascalibrationblock",
            "description": "Whether to use a calibration block in theinstance of TLC + pipette offset flow. If no tip length is performed, this is ignored, but it should always be specified.",
            "default": false
          },
          "tipRackDefinition": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tiprackdefinition",
            "description": "The full labware definition of the tip rack to calibrate. If not specified, then a default will be used - either the same tiprack as in the current calibration, or, if there is no calibration, the default Opentrons tiprack for this pipette."
          },
          "shouldRecalibrateTipLength": {
            "type": "boolean",
            "title": "Shouldrecalibratetiplength",
            "description": "whether to perform TLC with the loaded tip rack, prior to recalibrating the pipette offset. If the tiprack used (either the one specified by tipRackDefinition or the default if not specified) does not have a tip length calibration, this will be forced to be true.",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "mount"
        ],
        "title": "SessionCreateParams",
        "description": "The parameters required to start the following types of sessions;\n1. Tip Length Calibration\n2. Pipette Offset Calibration\n3. Tip Length Calibration + Pipette Offset Calibration"
      },
      "robot_server__runs__router__base_router__RunNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunNotFound"
            ],
            "const": "RunNotFound",
            "title": "Id",
            "default": "RunNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "RunNotFound",
        "description": "An error if a given run is not found."
      },
      "robot_server__runs__router__base_router__RunNotIdle": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "RunNotIdle"
            ],
            "const": "RunNotIdle",
            "title": "Id",
            "default": "RunNotIdle"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run is not idle."
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "default": "Run is currently active. Allow the run to finish or stop it with a `stop` action before attempting to modify it."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "default": "4001"
          }
        },
        "type": "object",
        "title": "RunNotIdle",
        "description": "An error if one tries to delete a run that is not idle."
      },
      "robot_server__runs__router__commands_router__CommandNotAllowed": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "CommandNotAllowed"
            ],
            "const": "CommandNotAllowed",
            "title": "Id",
            "default": "CommandNotAllowed"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Command Not Allowed"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "CommandNotAllowed",
        "description": "An error if a given run command is not allowed."
      },
      "robot_server__runs__router__commands_router__CommandNotFound": {
        "properties": {
          "id": {
            "type": "string",
            "enum": [
              "CommandNotFound"
            ],
            "const": "CommandNotFound",
            "title": "Id",
            "default": "CommandNotFound"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "default": "Run Command Not Found"
          },
          "detail": {
            "type": "string",
            "title": "Detail",
            "description": "A human-readable message describing this specific occurrence of the error."
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ErrorSource"
              },
              {
                "type": "null"
              }
            ],
            "description": "An object containing references to the source of the error."
          },
          "meta": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "An object containing non-standard information about this occurrence of the error"
          },
          "errorCode": {
            "type": "string",
            "title": "Errorcode",
            "description": "The Opentrons error code associated with the error",
            "default": "4000"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "CommandNotFound",
        "description": "An error if a given run command is not found."
      },
      "robot_server__service__legacy__models__deck_calibration__CalibrationStatus": {
        "properties": {
          "deckCalibration": {
            "$ref": "#/components/schemas/DeckCalibrationStatus"
          },
          "instrumentCalibration": {
            "$ref": "#/components/schemas/InstrumentCalibrationStatus"
          }
        },
        "type": "object",
        "required": [
          "deckCalibration",
          "instrumentCalibration"
        ],
        "title": "CalibrationStatus",
        "description": "The calibration status"
      },
      "robot_server__service__legacy__models__pipettes__AttachedPipette": {
        "properties": {
          "model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model",
            "description": "The model of the attached pipette. These are snake case as in the Protocol API. This includes the full version string"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "The name of the attached pipette - the model without the version string"
          },
          "tip_length": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tip Length",
            "description": "The default tip length for this pipette, if attached"
          },
          "mount_axis": {
            "type": "string",
            "title": "Mount Axis",
            "description": "The axis that moves this pipette up and down"
          },
          "plunger_axis": {
            "type": "string",
            "title": "Plunger Axis",
            "description": "The axis that moves this pipette's plunger"
          },
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "The serial number of the attached pipette"
          }
        },
        "type": "object",
        "required": [
          "model",
          "name",
          "tip_length",
          "mount_axis",
          "plunger_axis",
          "id"
        ],
        "title": "AttachedPipette",
        "description": "Pipette (if any) attached to the mount"
      },
      "robot_server__service__pipette_offset__models__MountType": {
        "type": "string",
        "enum": [
          "left",
          "right"
        ],
        "title": "MountType",
        "description": "Pipette mount type"
      },
      "robot_server__service__session__models__command__CommandStatus": {
        "type": "string",
        "enum": [
          "executed",
          "queued",
          "failed"
        ],
        "title": "CommandStatus",
        "description": "The command status."
      },
      "robot_server__service__shared_models__calibration__CalibrationStatus": {
        "properties": {
          "markedBad": {
            "type": "boolean",
            "title": "Markedbad",
            "description": "Whether a calibration is invalid or not"
          },
          "source": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SourceType"
              },
              {
                "type": "null"
              }
            ],
            "description": "The source that marked the calibration bad."
          },
          "markedAt": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Markedat",
            "description": "The time the calibration was marked bad."
          }
        },
        "type": "object",
        "required": [
          "markedBad"
        ],
        "title": "CalibrationStatus",
        "description": "A model describing whether a calibration on the robot is valid\nor not. This should be used for all calibration data models."
      }
    }
  }
}